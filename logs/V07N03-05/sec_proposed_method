[MATH]個の要素からなる翻訳元言語のタームリストを[MATH]は一つのターム，[MATH]は[MATH]までの並びを表す)と記す．
ここで，タームリスト内の要素の順序には意味がない．
なお，[MATH]をタームリストの長さと呼ぶ．
各タームに対して対訳辞書（bilingual dictionary )などを参照して文脈独立に与えられた訳語の集合を訳語候補集合と呼ぶ．
なお，訳語は一つの単語であっても複数語から成る熟語であっても良い．
入力の各タームに対してその訳語候補を一つずつ選んで並べたものを翻訳タームリスト候補と呼び，[MATH]で表す．
たとえば，入力がsuitとprosecuteとから成っていて，これらに対する訳語候補がそれぞれ「スーツ」と「裁判」，「遂行」と「起訴」である場合，以下の４つの翻訳タームリスト候補が存在する．
（スーツ，遂行）,（スーツ，起訴）,（裁判，遂行）,（裁判，起訴）
本論文で対象とする翻訳多義解消とは，翻訳タームリスト候補の中から(入力タームリスト全体の与える文脈に照らして)最も適切なものを選ぶことである．
本論文で提案する手法は「翻訳タームリスト候補の中でターム同士の意味的関連性が高い方がそうでないものより妥当である」という仮定に基づいている．
ここで，単語同士の意味的関連性の高さはこれらの単語がどの程度類似した文脈で出現しうるかによって定義する．
たとえば，2章で挙げたsuitとprosecuteの場合，翻訳タームリスト候補内の意味的関連性が最も高いのは(裁判，起訴)であるからこれを選択する．
形式的には，[MATH]個のタームから成る入力タームリスト[MATH]に対する最適な翻訳タームリスト[MATH]は次の式で与えられる
ここで，[MATH]は翻訳ームリスト候補[MATH]に対する\ikanrenの値で\ikdあるいは単に\kdと呼ぶ．
本研究では以下で示すように\ikdを単語空間(WordSpace[CITE])と呼ばれる多次元ベクトル空間を用いて定義する．
単語空間を使った\ikdの定義を行なう準備として，コーパス中のタームの共起頻度をそのまま使った\ikdを定義する．
まず，ターム間の共起頻度を行列で表現する．
この行列の行と列はどちらも異なりタームに対応し，[MATH]要素は[MATH]行目のターム[MATH]と[MATH]列目のターム[MATH]とのコーパスにおける共起頻度である．
ここで，2つのタームの共起頻度とはこれらがあらかじめ決められた[MATH]語以内の近さでテキスト中に表れる頻度である．
以下ではこの行列のことを共起行列と呼ぶ．
表[REF_tab.cooc]に共起行列の例を示す．
この例は，たとえば「訴訟」と「法」とがコーパス中で246回共起していることを表している．
この共起行列の[MATH]行目の行ベクトル(長さを1に正規化したもの)をターム[MATH]に対する共起ベクトルと呼び[MATH]で表す．
共起ベクトルはそのタームが他のタームとどのような共起関係にあるかを表している．
この定義から明らかな通り，２つのタームが他のタームと同じような比率で共起しているならば，これら2つのタームに対応するベクトルは近い方向を向く．
そこで，2つのターム[MATH]の意味的な近さ[MATH]をこれらのタームに対応するベクトル[MATH]のなす角の余弦([MATH])として以下のように定義する．
この「近さ」の概念を[MATH]タームに拡張したものが[MATH]要素から成るタームリストの\ikdの定義である．
具体的には，ターム列[MATH]に関する共起頻度に基づく\ikd[MATH]を下記のように定式化する．
すなわち，n個のターム[MATH]に対応するn個のベクトルの重心[MATH]をまず計算し，この重心からそれぞれのベクトルまでの「近さ(式([REF_f.prox]))の平均」を共起行列における\ikdとする．
上記で定義した\kdはコーパス中のターム間の共起頻度をそのまま使っているためデータスパースネスの問題がある．
また行列の次元が大きくなりすぎて計算機での扱いが難しいという問題もある．
これらの問題を解決するために共起行列に固有値分解(Singular Value Decomposition:SVD)を適用し行列（の階数）を縮退させる(なおSVDによる行列の縮退については付録参照)．
このようにしてできた行列を縮退共起行列と呼ぶ．
縮退共起行列には元の共起行列では陽に現れていないターム間の間接的な共起関係が表れることが知られている(higher order co-occurence)．
すなわち，[MATH]と[MATH]がコーパス中で直接共起していなくても，[MATH]と[MATH]，[MATH]と[MATH]が数多く共起していれば，縮退した行列では[MATH]要素の値がある正の値になる．
この縮退されたベクトル空間を単語空間(word space)と呼ぶ．
この縮退共起行列の[MATH]番目の行ベクトルを[MATH]に対する縮退共起ベクトルと呼び[MATH]と表す．
単語空間に基づく\ikd[MATH]とは前節の\ikd([MATH])の定義において各単語([MATH])に対する共起ベクトル([MATH])を縮退共起ベクトル([MATH])に置き換えたものである．
３章で述べた\kdの定義には重心（平均）を求める操作が含まれているため，動的計画法などのような部分問題への分割を前提とした効率的なアルゴリズムが適用できない．
従って，基本的には各翻訳タームリスト候補に対して総当たり的に\kdを計算する方法によらざるを得ない．
この問題に対して本研究では以下に示すような枝刈りを適用して計算量の削減を図った．
根接点を1段目として[MATH]段目の節点から出るリンクが[MATH]番目のタームに対する訳語候補に対応するような探索木を考える(図[REF_FigTermList]に例を示す)．
この木の各葉接点(図の右端の節点)が一つの翻訳タームリスト候補に対応する．
枝刈りの前提となる総当たり法とはこの探索木を深さ優先で辿り，葉節点に到達するたびに\kdを計算することによって\ikdが最大の候補を決定する方法である．
入力タームリスト[MATH]を先頭の[MATH]個[MATH]からなる[MATH]の部分と残りの[MATH]の部分に分ける．
[MATH]に対する翻訳タームリスト候補のうち，[MATH]に対する訳語を[MATH]に固定した時，\kdが最大であるものを[MATH]で表わすと次の不等式が成立する(なお，付録にこの不等式の簡単な証明を示す)．
ここで，[MATH]は入力が[MATH]の場合の最適な翻訳タームリストである．
従って，式([REF_bound])の右辺は，[MATH]に対する\kdの値と[MATH]の部分のみを考えた場合の最適な翻訳タームリスト([MATH])の\kdの値をそれぞれのタームの個数で重みを付けて平均したものとなる．
この不等式は，[MATH]の部分に対する訳語を[MATH]に固定したとき，[MATH]以降のタームに対する訳語をどのように選んでもタームリスト全体の\kdの値が右辺を越えないこと（上限）を表している．
なお，等号が成り立つのは[MATH]の重心と[MATH]の重心（の方向）が一致する時である．
前記の不等式([REF_bound])を用いて「総当たり法」に対する次のような枝刈りを行なう．
まず，タームリストの末端(右端)から[MATH]個の各部分に対する最適翻訳タームリストの\ikdの値[MATH]を計算しておく．
これらの値は次に述べる「枝刈り」ステップにおいて利用する．
ここで[MATH]は[MATH]より小さいある値で「枝刈り判定ターム数」と呼ぶ．
なお，この前処理自体に最適な翻訳タームリストを求める処理が入っているが，これは本アルゴリズム全体を再帰的に適用することによって行なう．
総当たり法と同様の深さ優先の探索によって，探索木を根（タームリストの左端）から[MATH]番目の深さのある節点(X)まで進んだとする(図[REF_FigStree]の節点X)．
根節点からXまでの経路に対応する(先頭から[MATH]個分の)訳語の列を[MATH]とし，既に生成された翻訳タームリスト(すでに辿った葉節点)の\ikdの値のうち最大のものをmaxとする(図[REF_FigStree]のmax)．
この[MATH]に対して先の前処理で計算した[MATH]を使って式([REF_bound])の右辺の値（\ikdの上限値）を計算し，この値がmaxより小さいならば，節点X以降のパスの探索(図[REF_FigStree]の斜線部分)を中止する．
この枝刈りを含んだアルゴリズム全体の計算量は最悪の場合，すなわち，枝刈りが一回も起こらなかった場合，元の総当たり法の計算量と前処理の計算量の和になるため，元の総当たり法より計算量が増える．
しかし，実際には後述するように50%以上計算時間が短縮される．
