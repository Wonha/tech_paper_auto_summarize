タームリスト翻訳における多義解消タスク
 
  $n$ 個の要素からなる翻訳元言語のタームリストを 
$ S = s_1^n = s_1, s_2, \ldots, s_n (s_i $ は一つのターム，$s_i^j$ 
は $s_i から s_j $までの並びを表す) と記す． 
ここで，タームリスト内の要素の順序には意味がない
\footnote{順序を考慮しない複数の語句の集まりは
``bag of words''とも呼ばれる．}．
なお， $n$ を{\bf タームリストの長さ}と呼ぶ． 

  各タームに対して対訳辞書（bilingual dictionary )などを参照して
文脈独立に与えられた訳語の集合を  {\bf 訳語候補集合} と呼ぶ． 
なお，訳語は一つの単語であっても複数語から成る熟語であっても良い．

  入力の各タームに対してその訳語候補を一つずつ選んで並べたものを
{\bf 翻訳タームリスト候補} と呼び，$T = t_1^n = t_1, t_2, \ldots, t_n (t_i は
s_i に対する訳語候補の一つ)$ で表す． たとえば，入力がsuit と 
prosecuteとから成っていて，これらに対する
訳語候補がそれぞれ「スーツ」と「裁判」，「遂行」と「起訴」である
場合，以下の４つの翻訳タームリスト候補が存在する．

\begin{verbatim}
（スーツ，遂行）,（スーツ，起訴）,（裁判，遂行）,（裁判，起訴）
\end{verbatim}

  本論文で対象とする翻訳多義解消とは， 翻訳タームリスト候補 の中から
(入力タームリスト全体の与える文脈に照らして)最も適切なものを選ぶこと
である． 

翻訳多義解消モデル

  本論文で提案する手法は「翻訳タームリスト候補の中でターム同士の
意味的関連性が
高い方がそうでないものより妥当である」という仮定に基づいている．
ここで，単語同士の意味的関連性の高さはこれらの単語がどの程度類似した
文脈で出現しうるかによって定義する．

たとえば，2章で挙げたsuit と prosecuteの場合，翻訳タームリスト候補
内の意味的関連性が最も高いのは(裁判，起訴)であるからこれを選択する．

形式的には，$ n$個のタームから成る入力タームリスト $ S = s_1^n $ に
対する最適な翻訳タームリスト $ B(s_1^n) = \hat{T}= \hat{t_1^n} = 
\hat{t_1}, \ldots, \hat{t_n}$ は次の式で与えられる


\vspace{5mm}

\renewcommand{\arraystretch}{}
\[
\begin{array}{cccc}
\hat{T} & = & \arg & \hspace{-3mm} \max rel(T) \nonumber \\
	&   & {\it T} & \nonumber
\end{array}
\]

\renewcommand{\arraystretch}{}

ここで，
$ rel(T) $は翻訳ームリスト候補$ T$に対する \ikanren の値で {\bf 
\ikd }あるいは単に{\bf \kd }と呼ぶ．本研究では以下で示すように 
\ikd を{\bf 単語空間(WordSpace\cite{Schuetze97})}と呼ばれる多次元
ベクトル空間を用いて定義する．

\subsection{共起頻度による \ikd の定義}

  単語空間を使った \ikd の定義を行なう準備として，
コーパス中のタームの共起頻度をそのまま使った \ikd を定義する． 

  まず，ターム間の共起頻度を行列で表現する．この行列の行と列はどちら
も異なりタームに対応し，$(i, j)$
要素は $ i $行目のターム$ w_i $と$ j $列目のターム $ w_j $ とのコーパスに
おける共起頻度である．ここで，2つのタームの共起頻度とは
これらがあらかじめ決められた $p$語以内の近さでテキスト中に表れる
頻度である\footnote{sliding windowによる共起関係の定義}．以下では
この行列のことを{\bf 共起行列}と呼ぶ．

  表 \ref{tab.cooc} に共起行列の例を示す．
この例は，たとえば「訴訟」と「法」とがコーパス中で246回共起している
ことを表している．
 

\begin{table}[htb]
\caption{共起行列の例(An example of a co-occurrence matrix).}
\label{tab.cooc}
\begin{minipage}{\columnwidth}
\vspace{3mm}
\small
\begin{center}
\begin{tabular}{l||l|l|l|l|l}
 & $\ldots$  & 法(law) & $\ldots$ &  百貨店(department store)& $\ldots$\\\hline\hline
   &  &              & &          &  \\\hline
訴訟(law:suit) & $\ldots$ & 246 & & 1  &   \\\hline
   &  &              & &            &\\\hline
スーツ(garment:  suit)  &$\ldots$   & 9 &$\ldots$ & 88     &\\ \hline
&  &              & &            &\\\hline
   &  &              & &          &  \\
\end{tabular}  
\end{center}
\end{minipage}
\end{table}

  この共起行列の$i$行目の行ベクトル(長さを1に正規化したもの)を
ターム $w_i$に対する{\bf 共起ベクトル}と呼び $\vec{w_i'}$
で表す．共起ベクトルはそのタームが他のタームと
どのような共起関係にあるかを表している．この定義から明らかな通り，
２つのタームが他のタームと
同じような比率で共起しているならば，これら2つのタームに対応するベクトル
は近い方向を向く． 

そこで，2つのターム$w_i, w_j$の意味的な近さ$prox(w_i, w_j)$をこれらの
タームに対応するベクトル$\vec{w_i'}, \vec{w_j'}$のなす角の余弦
($cos(\vec{w_i'}, \vec{w_j'})$)として以下のように定義する
\footnote{$\bullet$は二つのベクトルの内積を表す記号}．

\begin{eqnarray}
prox(w_i, w_j)  =  cos(\vec{w_i'}, \vec{w_j'}) \label{f.prox}\\
\:  where \:\: cos(\vec{a}, \vec{b}) = 
\frac{\vec{a} \bullet \vec{b}}{ \sqrt{\mid \vec{a}
 \mid ^2  \mid \vec{b} \mid ^2}}\nonumber
\end{eqnarray}

この「近さ」の概念を$ n$タームに拡張したものが$n$要素から成る
タームリストの\ikd の定義である．
具体的には，ターム列 $  w_1^n = w_1, w_2, \ldots, w_n $ に関す
る共起頻度に基づく \ikd  $rel'(w_1^n)$ を下記のように定式化する．
\begin{eqnarray}
rel'(w_1^n) & = & \frac{1}{n}\sum_{i=1}^n cos(\vec{w_i'}, \vec{c}(w_1^n))  \label{f.coh}\\
where \:\: \vec{c}(w_1^n) & = &\frac{1}{n}\sum_i^n \vec{w_i'}  
\end{eqnarray}

すなわち，n個のターム$(w_1^n)$に対応するn個のベクトルの重心$\vec{c}(w_1^n)$
をまず計算し，この重心からそれぞれのベクトルまでの
「近さ(式(\ref{f.prox}))の平均」を共起行列における 
\ikd とする\footnote{空間上の複数の点の「ちらばりの程度」 
を表す尺度として一般的に使われるのは平均からの自乗偏差であるが，
本研究では点の間の近さを余弦を使って定義したので式(\ref{f.coh})を用いた．}．
 
\subsection{単語空間における\ikd }

  上記で定義した\kd はコーパス中のターム間の共起頻度をそのまま使って
いるためデータスパースネスの問題がある．また行列の次元が大きくなりすぎ
て計算機での扱いが難しいという問題もある．

これらの問題を解決するために共起行列に固有値分解(Singular Value
Decomposition:SVD)を適用し行列（の階数）を縮退させる
(なおSVDによる行列の縮退については付録参照)．
このようにしてできた行列を{\bf 縮退共起行列}と呼ぶ．
縮退共起行列には元の共起行列では陽に現れていないターム
間の間接的な共起関係が表れることが知られている
(higher order co-occurence)\footnote{文献\cite{Schuetze97}p.91}．
すなわち，$w_i$と$w_j$がコーパス中で直接共起していなくても，
$w_i$と$w_k$，$w_j$と$w_k$が数多く共起していれば，
縮退した行列では$(i,j)$要素の値がある正の値になる．

この縮退されたベクトル空間を単語空間
(word space)と呼ぶ\footnote{「単語空間」はLSI(Latent Semantic Indexing)
\cite{Deerwester90}
と密接な関係がある．
前者はタームとタームの共起行列にSVDを適用したものであ
り，後者は文書に対する各タームの生起行列にSVDを適用したものである．
これらの情報検索における相違点に関しては\cite{Schuetze97b}を参照のこと．
}．

この縮退共起行列の $i$ 番目の行ベクトルを$w_i$に対する縮退共起
ベクトルと呼び $ \vec{w_i}$ と表す．

単語空間に基づく\ikd $rel(w_1^n)$ とは前節の\ikd ($rel'(w_1^n)$)の定義に
おいて各単語($w_i$)に対する共起ベクトル($\vec{w_i'}$)を
縮退共起ベクトル($\vec{w_i}$)に置き換えたものである．
 
アルゴリズム\label{S.Algorithm}

  ３章で述べた\kd の定義には重心（平均）を求める操作が
含まれているため，動的計画法などのような部分問題への分割を
前提とした効率的なアルゴリズムが適用できない．
従って，基本的には各翻訳タームリスト候補に対して総当たり的に
\kd を計算する方法によらざるを得ない．
この問題に対して
本研究では以下に示すような枝刈りを適用して計算量の
削減を図った．

\subsection{総当たり法（基本アルゴリズム）}


根接点を1段目として$i$段目の節点から出るリンクが
$i$番目のタームに対する訳語候補に対応するような探索木を考える
(図 \ref{FigTermList}に例を示す)． 
この木の各葉接点(図の右端の節点)が一つの翻訳タームリスト
候補に対応する． 

\begin{figure}
\begin{center}
\epsfile{file=Fig1_termlist.eps,width=5cm}
\end{center}
\caption{翻訳タームリスト候補に対する探索木(A search tree for possible translations).}
\label{FigTermList}
\end{figure}

枝刈りの前提となる{\bf 総当たり法}とはこの探索木を深さ
優先で辿り，葉節点に到達するたびに\kd を計算することによって
\ikd が最大の候補を決定する方法である．
  
\subsection{枝刈り}

\subsubsection{準備}  

  入力タームリスト $S = s_1^n $ を先頭の
 $ m \: $ 個 $(m<n)$からなる $ s_1^m$の部分と残りの$s_{m+1}^n$ の部分
に分ける． 
$ s_1^n $に対する翻訳タームリスト候補のうち， $ s_1^m $に対する訳語
を $ u_1^m $ に固定した時，\kd が最大であるものを $ C_m(S, u_1^m) $ 
で表わすと次の不等式が成立する(なお，付録にこの不等式の簡単な証明を示す)．

\begin{eqnarray}
rel(C_m(S, u_1^m))  \leq  
   \frac{m * rel(u_1^m) + (n - m) * rel(B(s_{m+1}^n))}{n} \label{bound}
\end{eqnarray}

ここで，$B(s_{m+1}^n)$ は 入力が  $s_{m+1}^n$ の場合の最適な
翻訳タームリストである．
従って，式(\ref{bound})の右辺は，$ u_1^m $に対する\kd の値と $s_{m+1}^n$
の部分のみを考えた場合の最適な翻訳タームリスト($B(s_{m+1}^n)$)の\kd の
値をそれぞれのタームの個数で重みを付けて平均したものとなる． 

  この不等式は，$ s_1^m $の部分に対する訳語を $ u_1^m $に固定し
たとき，$ m+1$ 以降の
タームに対する訳語を どのように選んでもタームリスト全体の 
\kd の値が右辺を越えないこと（上限）を表している．
なお，等号が成り立つのは $ u_1^m $の重心と$ B(s_{m+1}^n)$ の
重心（の方向）が一致する時である．

\subsubsection{枝刈り手法}  

  前記の不等式(\ref{bound})を用いて「総当たり法」に対する
次のような枝刈りを行なう．

\begin{quote}
\begin{description}
\item [前処理] まず，タームリストの末端(右端)から 
$ l (l = 1, \ldots, k)$ 個の各部分に対する最適翻訳タームリストの
\ikd の値 $rel(B(s_{n-l+1}^n))$を計算しておく．これらの値は
次に述べる「枝刈り」ステップにおいて利用する． 
ここで$k $ は $n $より小さいある値で「枝刈り判定ターム数」
と呼ぶ．
なお，この前処理自体に最適な翻訳タームリストを求める処理が入って
いるが，これは本アルゴリズム全体を再帰的に適用することによって
行なう．

\item [枝刈り] 総当たり法と同様の深さ優先の探索によって，探索木
を根（タームリストの左端）から$m + 1 (但し， n - k \leq m)$番目の
深さのある節点(X)まで進んだとする
(図\ref{FigStree}の節点X)．根節点からXまでの経路に対応
する(先頭から$m$個分の)訳語の列を$ u_1^m $とし，
既に生成された翻訳タームリスト(すでに辿った葉節点)の\ikd の値の
うち最大のものを max とする(図\ref{FigStree}のmax)．

この $ u_1^m $ に対して先の前処理で計算した  $rel(B(s_{n-l+1}^n))$
を使って式(\ref{bound})の右辺の値（\ikd の上限値）を
計算し，この値がmaxより小さいならば，節点X以降のパスの探索
(図\ref{FigStree}の斜線部分)を中止する．
\end{description}
\end{quote}

\begin{figure}
\begin{center}
\epsfile{file=Fig2_Stree.eps,height=4cm}
\end{center}
\caption{枝刈り(An example of pruning).}
\label{FigStree}
\end{figure}

この枝刈りを含んだアルゴリズム全体の計算量は最悪の場合，すなわち，
枝刈りが一回も起こらなかった場合，元の総当たり法の計算量と
前処理の計算量の和になるため，元の総当たり法より計算量が増える．
しかし，実際には後述するように50\%以上計算時間が短縮される．

SVDによる共起行列の縮退

行列 $ A $に対するSVDとは次の式を満たす 
$U_{0}, S_{0}, V_0^{-1}$を求めることである．
\begin{eqnarray*}
A & = & U_0 S_0 V_0^T
\end{eqnarray*}
ここで，$U_0U_0^T = V_0V_0^T = I (I は単位行列)$, 
$ S_0 $ は対角行列 $diag(s_0, ... ,s_n) $ で 
$ s_i > s_j > 0 if (i > j) $を満たす．

$ S_0 $の対角要素のうち $ k $より大きいものを全て 
0 と置いたものを $S$とし，$U_0, V_0$の先頭
から$ k $列目までの部分行列をそれぞれ$U, V$とすると，
\begin{eqnarray*}
 \hat{A} = USV^{T} 
\end{eqnarray*}
は$ A $の階数を$k$に落した近似になっている．

Aを共起行列と考えると $w_i,w_j$の類似性を表す
行列は $ AA^{T}$で得られる．
$A$ の代わりに $\hat{A}$を使うと， 
\begin{eqnarray*}
\hat{A}\hat{A}^{T} = LSR^{T}(LSR^{T})^{T} = LS(LS)^{T} \label{aa}
\end{eqnarray*}
となり，L, Sという次元の小さい行列によって単語間の
類似性が計算できることが分かる．なお，さらに詳しい説明は
文献\cite{Deerwester90}\cite{Schuetze97}を参照されたい．

不等式(4)の証明

$S = s_1, \ldots, s_n $に対応する任意の翻訳タームリストを 
$ T = t_1, \ldots , t_n $ その最初の$ m (m \leq n)$個からなる
タームリストを $ t_1^m $，残りを $ t_{m+1}^n$ とすると次の式が成立する． 
\begin{eqnarray}
rel(T) \leq \frac{m * rel(t_1^m) + (n-m) * rel(t_{m+1}^n)}{n} \label{f1}
\end{eqnarray}

\begin{quotation}
\noindent
[証明]\\
\noindent
$T$の各タームに対応するベクトル(長さを1に正規化したもの)
を$\vec{x_1}, \ldots, \vec{x_n}$, ターム集合 $T, t_1^m,t_{m+1}^n$ 
それぞれに対するベクトル集合の重心をそれぞれ $\vec{g}, \vec{g_1}, 
\vec{g_2}$とすると，式 (\ref{f1})の左辺は
\begin{eqnarray}
rel(T) =  \frac{1}{n}\sum_{i = 1}^n prox(\vec{x_i}, \vec{g})  
  =   \frac{1}{n}\sum_{i = 1}^n \frac{\vec{x_i} \bullet \vec{g}}
    {\mid \vec{g} \mid} 
  =  \frac{1}{n}\frac{n \vec{g} \bullet \vec{g}}{\mid \vec{g} \mid} = 
    \mid \vec{g} \mid \label{f1.l}
\end{eqnarray}
\noindent
となる($ \mid \vec{g} \mid $ は$\vec{g}$の長さを表す)． 右辺も同様に書き換
えると
\begin{eqnarray}
\frac{m * rel(t_1^m) + (n-m) * rel(t_{m+1}^n)}{n} 
  =  \frac{m * \mid \vec{g_1} \mid + (n-m) * \mid \vec{g_2} \mid}{n} \label{f1.r}
\end{eqnarray}
\noindent
のようになる． ここで 重心の定義から
\begin{eqnarray}
n\vec{g} = n * \frac{1}{n} \sum_{i = 1}^n \vec{x_i} 
         = \sum_{i = 1}^m \vec{x_i} + \sum_{i = m+1}^n \vec{x_i}
         = m\vec{g_1} + (n-m)\vec{g_2} 
\end{eqnarray}
が成立しているので，(\ref{f1.r})の値は(\ref{f1.l})と同じか大きい． 
なお，等号が成立するのはベクトル$\vec{g}, \vec{g_1}, \vec{g_2}$の向
きが同じ時である． 
\begin{flushright}
(証明終)
\end{flushright}
\end{quotation}

式(\ref{f1})の$T$の部分に $ C_m(S, u_1^m) = u_1, \ldots, u_m, z_{m+1}, 
\ldots,  z_n = u_1^m, z_{m+1}^n$ を代入すると次の式が得られる．
\begin{eqnarray}
rel(C_m(S, u_1^m)) \leq  \frac{m * rel(u_1^m) + (n-m) * rel(z_{m+1}^n)}{n} \label{cent}
\end{eqnarray}

一方， $B(S)$の定義より
\begin{eqnarray}
rel(z_{m+1}^n) \leq rel(B(s_{m+1}^n)) \label{tcbest}
\end{eqnarray}
であるから，(\ref{tcbest})と(\ref{cent})を組み合わせれば
不等式(\ref{bound})が得られる．

\begin{flushright}
(証明終)
\end{flushright}



\bibliographystyle{jnlpbbl}
\bibliography{v07n3_05}


\begin{biography}
\biotitle{略歴}
\bioauthor{菊井 玄一郎}{
1986年京都大学工学部電気工学第二専攻修士課程修了.
同年NTTに入社，現在に至る．自然言語処理，特に自動翻訳，多言語情報検索
等の研究開発に従事．
1990年から1994年までATR自動翻訳電話研究所に出向．
1997年7月より1年間Stanford大学CSLI研究員．}

\bioreceived{受付}
\biorevised{再受付}
\bioaccepted{採録}

\end{biography}
