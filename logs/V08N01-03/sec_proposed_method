はじめに，文脈自由文法[MATH]を4つ組[MATH]で定義する．
ただし，[MATH]は非終端記号の集合，[MATH]は終端記号の集合，[MATH]は規則の集合，[MATH]は開始記号[MATH]である．
[MATH]中の各規則[MATH]は[MATH]の形をしており，記号列[MATH]中に非終端記号[MATH]が出現するとき，[MATH]を[MATH]に置き換えることが可能であることを表す．
我々は常に最左の非終端記号を置き換えるように規則を適用する（最左導出に固定する）．
規則[MATH]の適用により記号列[MATH]が[MATH]に置き換えられるとき[MATH]と書く．
このような置き換えを0回以上行なって[MATH]から[MATH]が得られるとき，[MATH]と書く．
特に，置換えが1回以上であることを強調する場合は[MATH]と書く．
[MATH]から導出可能な非終端記号列[MATH]を文と呼ぶ．
CFG [MATH]における文の集合を[MATH]の言語と呼び，[MATH]と書く．
そして，[MATH]に基づくPCFGを[MATH]で表す．
逆に[MATH]を「PCFG [MATH]の文法構造」と呼ぶ．
[MATH]は[MATH]次元ベクトルであり，以降パラメタと呼ぶ．
[MATH]の各要素は[MATH]で参照され，[MATH]が成り立つとする([MATH])．
PCFGでは「適用する規則は他に影響を受けずに選択される」と仮定される．
従って[MATH]における規則の適用列[MATH]の出現確率[MATH]は
と計算される．
また，[MATH]を適用規則列[MATH]中に規則[MATH]が出現する数とすると，
と書くこともできる．
[MATH]を実現する適用規則列すべてから成る集合を[MATH]とおく．
文[MATH]は適用規則列[MATH]から一意に定まるので，文と適用規則列の同時分布[MATH]に関し
が成り立つ．
式[REF_eq:joint-prob]より開始記号[MATH]から[MATH]が導出される確率[MATH]は次のように求まる：
パラメタ[MATH]が文脈より明らかなときは[MATH], [MATH]を各々[MATH], [MATH]と書く．
先述した規則適用の独立性に加え，以降で考えるPCFG [MATH]は次を満たすとする．
[MATH]は整合的である．
すなわち[MATH]が成り立つ．
右辺が[MATH]である規則（[MATH]規則）や[MATH]となるような[MATH]が存在しない．
ChiとZemanは，2番目の条件を満たす文法構造[MATH]と有限長の文から成る括弧なしコーパス[MATH]が与えられたとき，I-Oアルゴリズムで得られる訓練パラメタ[MATH]の下でのPCFG [MATH]が整合的であることを示した[CITE]．
平文[MATH]に対して個々の[MATH]は単語である([MATH], [MATH])．
[MATH]に対して単語位置[MATH]を与える．
[MATH]について[MATH]と[MATH]の間にある部分単語列[MATH]を[MATH]と書く（[MATH]である）．
また，（部分）単語列[MATH]をリスト[MATH]で表すことがある．
[MATH]に対して，[MATH]の構文木は[MATH]の導出過程を木構造で表現したものである．
我々は導出戦略を最左導出に固定しているので，[MATH]の適用規則列[MATH]から[MATH]の構文木[MATH]が一意に決まり，逆も真である．
従って[MATH]が成り立つ．
先に我々は対象とするPCFGが[MATH]規則をもたないこと，[MATH]という導出が起こらないと仮定した．
この仮定より，[MATH]の構文木[MATH]の部分構文木（以下，部分木）[MATH]はその根ノードの非終端記号[MATH]と葉ノードを構成する部分単語列の開始／終了位置の対[MATH]によって一意に定まるので，以降，我々は部分木[MATH]をラベル[MATH]で参照する．
[MATH]の構文木[MATH]は，葉ノードを除く[MATH]の部分木ラベルから成る集合[MATH]（[MATH]のラベル集合と呼ぶ）と同一視できる．
また，[MATH]は一つの括弧づけに相当する．
[MATH]と定め，[MATH]の括弧集合と呼ぶ．
また，[MATH]の展開によって得られた[MATH]を根とする部分木[MATH]を考える（図[REF_fig:parse-tree]）．
このとき[MATH]なる部分木に関する半順序関係[MATH]を導入する([MATH])．
この関係を以降では「[MATH]は[MATH]の親である」，また逆に「[MATH]は[MATH]の子である」などということがある．
そして親[MATH]とその子をすべてまとめて
と表し，これを「部分木の親子対」と呼ぶことにする．
構文木[MATH]中に出現する部分木の親子対をすべて集めた集合を[MATH]で表す．
構文木[MATH]に対応する適用規則列[MATH]に対して[MATH], [MATH], [MATH]をそれぞれ[MATH], [MATH], [MATH]と同一視する．
PCFGの訓練用のコーパスとして我々は(1)構造つきコーパス(labeled corpus)，(2)完全括弧つきコーパス(fully bracketed corpus)，(3)部分括弧つきコーパス(partially bracketed corpus)，(4)括弧なしコーパス(unbracketed corpus)の4つを考える．
我々は訓練法として最尤推定法(maximum likelihood estimation)を考えており，[MATH]文を含むコーパス[MATH]はPCFG [MATH]に基づく独立な[MATH]回のサンプリング導出の結果であると仮定する．
[MATH], [MATH]を[MATH]回目のサンプリングで得られた平文および適用規則列とすると([MATH])，[MATH]が構造つきコーパスのとき[MATH],完全括弧つきコーパスのとき[MATH],部分括弧つきコーパスのとき[MATH],括弧なしコーパスのとき[MATH]となる([MATH], [MATH], [MATH])．
[MATH]の部分単語列を[MATH]とおき[MATH]，[MATH]の[MATH]番目の単語を[MATH]とおく．
ただし[MATH]である．
CYKパーザはChomsky標準形であるCFGに適用可能なパーザである．
我々は括弧なしコーパス[MATH]中の文[MATH]に対して[MATH]の三角行列[MATH]を用意する([MATH])．
[MATH]行[MATH]列の要素[MATH]には部分単語列[MATH]に対する解析結果が格納される．
CYKパーザを実現する手続き[MATH]を図[REF_alg:CYK]に示す．
対角要素から順に部分木を組み上げ（行[REF_list:CYK:fill-diagonal:begin]--[REF_list:CYK:fill-non-diag:end]），[MATH]に[MATH]が含まれていたら解析が成功したものとし，含まれていなかったら失敗したものとする（行[REF_list:CYK:accept]）．
解析が成功したら[MATH]に含まれる[MATH]から順に部分木の親子対を辿って構文木が取り出される．
図[REF_gram:ichiro-CNF]に示したCFG [MATH]において文[MATH]に対する三角行列を図[REF_fig:CYK-table]に示す．
図[REF_fig:CYK-table]の○印のついた部分木の親子から図[REF_fig:parse-tree-ichiro-CNF]の構文木[MATH]が取り出され，●印のついた部分木の親子から[MATH]が取り出される．
先にも述べたように，我々はPCFGのパラメタをコーパス[MATH]から最尤推定法に基づき訓練することを考えている．
[MATH]が構造つきコーパスの場合，相対頻度法で得られる各規則[MATH]の相対出現頻度が最尤推定値となるので，これを[MATH]の訓練パラメタ[MATH]とすればよい．
しかし，構造つきコーパスの作成コストを考えると，より安価な括弧なしコーパスしか利用できない場合が十分考えられる．
括弧なしコーパスでは構文構造が明らかでないため，相対頻度法が適用できず，代わりにI-OアルゴリズムというPCFGに特化された形のEMアルゴリズムが広く知られている．
I-Oアルゴリズムは，括弧なしコーパス[MATH]が与えられたときに尤度[MATH]あるいはその対数[MATH]（対数尤度）を局所的に最大にする[MATH]を見つける．
つまりI-Oアルゴリズムもまた最尤推定法である．
[CITE]をはじめとする多くの文献の記述では，文法構造[MATH]のうち規則集合[MATH]を明示的に与えず，終端記号集合[MATH]と非終端記号集合[MATH]を与えた場合を考えている．
提案手法との対比のため，本節では[MATH]を明示的に与えた場合のI-Oアルゴリズムを記述する．
[MATH]と[MATH]のみを与えた場合のI-Oアルゴリズムは
（以下では[MATH]と略すことがある）を考え，規則集合を[MATH]として与えた場合と同一である．
ただし，いずれの場合でも[MATH]はChomsky標準形でなければならない．
[CITE]では規則集合[MATH]を含めた学習を目的にI-Oアルゴリズムを使用しているが，我々はパラメタ[MATH]の学習に焦点を絞る．
I-Oアルゴリズムの中心は内側確率[MATH]と外側確率[MATH]という2つの確率値の計算である([MATH], [MATH], [MATH])．
各確率値を配列変数[MATH], [MATH]に格納する．
これらの配列変数はCYKアルゴリズムで用いた三角行列[MATH]中に設けられているものとする．
[MATH]より[MATH]に文[MATH]の生起確率[MATH]が格納される点に注意する．
[b]
\rw{procedure} [MATH] \rw{begin} \itemi\rw{for} [MATH] \rw{to} [MATH] \rw{do} \rw{begin} \itemii\rw{for} [MATH] \rw{to} [MATH] \rw{do} \q\progcomment{三角行列の対角要素について計算} \itemiii\rw{foreach} [MATH] such that [MATH] \rw{do} \itemiiii[MATH];  \itemii\rw{for} [MATH] \rw{to} [MATH] \rw{do} \q\progcomment{三角行列の非対角要素について計算} \itemiii\rw{for} [MATH] \rw{to} [MATH] \rw{do} \itemiiii\rw{foreach} [MATH] \rw{do} \itemiiiii[MATH]  \itemi\rw{end}
\rw{end}.
\rw{procedure} [MATH] \rw{begin} \itemi\rw{for} [MATH] \rw{to} [MATH] \rw{do} \rw{begin} \itemii[MATH]; \q\progcomment{右上隅の[MATH]については特別に1に初期化}   \itemii\rw{for} [MATH] \rw{downto} [MATH] \rw{do}  \itemiii\rw{for} [MATH] \rw{to} [MATH] \rw{do} \itemiiii\rw{foreach} [MATH] \rw{do} \itemiiiii[MATH]  \itemiiiiiiiiii[MATH]  \itemi\rw{end}
\rw{end}.
内側確率と外側確率を計算する手続き[MATH], [MATH]を図[REF_alg:get-beta-alpha]に示す．
記述を簡単にするため，配列変数[MATH]および[MATH]は手続きが呼び出される度に0に初期化されるものとする．
[MATH]はCYKパーザにおいて部分木を組み上げるのと同じように，三角行列の対角要素から出発し，右上隅[MATH]に至るまで段階的に内側確率を計算していく．
また，逆に[MATH]では右上隅[MATH]から対角要素に向かって外側確率を計算する．
このように内側・外側確率は動的計画法(dynamic programming)に基づき，一方向に従って計算が進められる．
内側・外側確率を計算し終ったら，コーパス[MATH]が与えられた下での規則[MATH], [MATH]の適用回数の条件つき期待値（以下，期待適用回数という）が次のように計算される:
{
}
更に，上で計算された期待値からパラメタ[MATH]が更新（再推定）される:
I-Oアルゴリズムでは，まず[MATH]を適当な値に初期化し，次いで手続き[MATH], [MATH]および式[REF_eq:eta-ABC], [REF_eq:eta-Aa], [REF_eq:update]によって[MATH]を更新する．
そして，このように更新を繰り返すと対数尤度[MATH]が単調増加しながら最終的には収束する．
収束したら，そのときのパラメタの値を最終的な推定値としてI-Oアルゴリズムは終了する．
ここで，I-Oアルゴリズムの計算量を考える．
収束までのパラメタ更新回数は初期値に依存するため，事前には分からない．
従って1回のパラメタ更新に必要な計算量をI-Oアルゴリズムの計算量とする．
非終端記号集合[MATH],終端記号集合[MATH]を固定した場合の最悪計算量を測る場合には[MATH]の場合を考えればよい．
訓練コーパス[MATH]に対して最長の文の長さを[MATH]とする．
手続き[MATH], [MATH]（図[REF_alg:get-beta-alpha]）中のfor, foreachループと[MATH]の引数に注目すれば，I-Oアルゴリズムの最悪計算量は[MATH]であることが容易に分かる．
アルゴリズム中で最もコストが高いのは，[MATH]行[REF_list:get-beta:calc-beta]における内側確率の計算，[MATH]行[REF_list:get-alpha:calc-op:begin]--[REF_list:get-alpha:calc-op:end]における外側確率の計算である．
[MATH]行[REF_list:get-beta:calc-beta]において図[REF_fig:get-beta-alpha] (1)という状況すべてを考慮して内側確率が計算される．
一方，[MATH]の行[REF_list:get-alpha:calc-op:begin]--[REF_list:get-alpha:calc-op:end]における右辺第1項，第2項ではそれぞれ図[REF_fig:get-beta-alpha] (2), (3)という状況がすべて考慮されている．
考えられるすべての状況について計算をすすめるという意味でI-Oアルゴリズムの動作は仮説駆動（トップダウン）型パーザの動作と同じである．
一般に仮説駆動型は入力文[MATH]の情報とは無関係に計算をすすめるために効率が悪いとされている．
文法構造が与えられていてもI-Oアルゴリズムの計算速度が低いのは，仮説駆動型であることが原因であると考えられる．
そもそもI-Oアルゴリズムは
という規則[MATH]の期待適用回数[MATH]の計算を
から得られる手続き[MATH], [MATH]および式[REF_eq:eta-ABC], [REF_eq:eta-Aa]によって効率化したものである[CITE]．
ただし，節[REF_sec:PCFG:PCFG]で定めたように[MATH]は規則列[MATH]に出現する規則[MATH]の数である．
式[REF_eq:naive-eta2]で，[MATH]とおいたとき，I-Oアルゴリズムでは[MATH]を次のように計算する（添字の[MATH], [MATH]は省略）．
式[REF_eq:with-position]の変形は入力文[MATH]や実際の構文木[MATH]とは無関係に行なわれており，I-Oアルゴリズムが仮説駆動型であるというのはこの点に由来する．
それに対し，式[REF_eq:joint-prob]より式[REF_eq:naive-eta]を下の式[REF_eq:naive-eta3]に変形し，構文木情報[MATH]を直接利用する方法を考える．
[MATH]はパーザを利用することによって事前に獲得しておく．
また，式[REF_eq:naive-eta3]はFujisakiらの計算方法[CITE]に他ならない．
式[REF_eq:naive-eta3]を用いればI-Oアルゴリズムのように[MATH]と無関係な部分を計算することはなくなる．
ただし，一般に[MATH]は文長[MATH]に対して指数オーダになってしまうため，これをそのまま計算するのは現実的ではない．
提案手法ではI-Oアルゴリズムのように再計算を防ぐ仕組みを取り入れ，パーザのもつWFSTを利用して式[REF_eq:naive-eta3]を効率的に計算する．
従って，提案手法をFujisakiらの方法とI-Oアルゴリズム双方の長所を取り入れた方法と見ることもできる．
提案手法の概要を図[REF_fig:scheme]に示す．
入力として確率文脈文法[MATH]の文法構造[MATH]と括弧なしコーパス[MATH]が与えられるものとする．
そして訓練パラメタ[MATH]を出力として返す．
提案手法において，我々は全体の訓練過程を構文解析とEM学習に分離する．
はじめに我々はパーザで[MATH]中の各文[MATH]をすべて解析する．
すると[MATH]を細切れにした，しかし[MATH]と等価な構文情報[MATH]がパーザのWFSTに格納されているので，これらを抽出する．
[MATH]を表現するデータ構造を支持グラフと呼ぶ．
次に，支持グラフに基づきgEMアルゴリズムを動作させ[MATH]を得る．
図[REF_gram:ichiro-CNF]のCFG [MATH]と文[MATH]の例を考えると，支持グラフは図[REF_fig:CYK-table]において○印と●印がついた部分木の親子から得られる．
この例から分かるように，文法によってはgEMアルゴリズムで参照する支持グラフは三角行列全体に比べて非常に小さくなる可能性があり，その場合は三角行列全体を走査しなければならないI-Oアルゴリズムに比べ大幅な速度向上が得られる（提案手法の特長2）．
提案手法を記述する前に形式化を行なう．
[MATH]について以下をおこなう．
まず，[MATH], [MATH]と定める．
そして，[MATH]の要素を[MATH]を満たすように並べた[MATH]を[MATH]とする．
また，次を導入する．
[MATH]はコーパス中の文[MATH]の構文木のいずれかに現れる部分木の親子対の集合である．
同様に[MATH]は[MATH]の構文木のいずれかに現れる部分木ラベルの集合である．
[MATH]は[MATH]の要素を[MATH]中の半順序関係（親子関係）[MATH]を満たすように順序づけたものである．
[MATH]の第一要素[MATH]は必ず[MATH]になる．
[MATH]は部分木と規則の論理的な関係を表現する．
例えば，
に対しては，「[MATH]に対して部分木[MATH]を作るためには，規則[MATH]を適用し，部分木[MATH]と部分木[MATH]を作る，もしくは規則[MATH]を適用し，部分木[MATH]と部分木[MATH]を作る，のいずれかである（他の場合はあり得ない）」と解釈する．
[MATH]と[MATH]は次節で説明する支持グラフを構成する．
例として，図[REF_gram:ichiro-CNF]のCFG [MATH]と[MATH]に対して図[REF_fig:parse-tree-ichiro-CNF]の2つの構文木[MATH], [MATH]を考える．
各々に対応する適用規則列を[MATH]とおくと，[MATH]である．
このとき[MATH]は
{
}
となる．
また，[MATH]は一意には決まらないが，どの場合でも第一要素は必ず[MATH]になる点に注意する．
例えば下のような[MATH]が考えられる．
{
}
また[MATH]を[MATH]の順に示す．
[MATH]という組を支持グラフ[MATH]というデータ構造で捉えるとgEMアルゴリズムが理解しやすくなる．
「グラフィカルEM」の名もここに由来する．
まず，前節で示した[MATH], [MATH]の例に対応する支持グラフを図[REF_fig:support-graph-ichiro] (a)に示す．
支持グラフ[MATH]は再帰遷移ネットワーク（recursive transition network;以下RTN）に似た構造をもつ非循環有向グラフ(DAG)であり，共通の辺をもたない部分グラフ[MATH]の集まりから成る（ただし[MATH]）．
各[MATH]は「[MATH]の部分支持グラフ」と呼ばれ，[MATH]が付与されている．
また，[MATH]は開始ノード，終了ノードと呼ばれる2つの特殊なノードをもち（図[REF_fig:support-graph-ichiro]では各々start, endと書かれている），各[MATH]に対して開始ノード，[MATH]の各要素（規則[MATH]または部分木ラベル[MATH]）が付与されたノード，終了ノードが一列に連結されている．
複数のノードに同じ規則または部分木ラベルが付与されることもある点に注意する．
有向辺はすべて開始ノードから終了ノードに向かっている．
開始ノードから終了ノードに至るパスを局所パスと呼び，これも[MATH]で参照する．
局所パスにおいて，規則[MATH]が付与されたノードを基本ノード，部分木ラベル[MATH]が付与されたノードを中間ノードと呼び，各々図[REF_fig:support-graph-ichiro]のように○と◎で表す．
支持グラフは次の特徴をもつ．
支持グラフ[MATH]に対してRTNのように再帰的な巡回を行なうことができる．
複数の巡回パスの一部が共有される．
部分支持グラフ[MATH]の[MATH]に対して，どの[MATH]についても[MATH]が成り立つ．
一つの局所パス中に存在する基本ノードと中間ノードの数に制限がない．
1つ目の特徴である再帰的な巡回は次のようにして行なわれる．
[MATH]の開始ノードから出発し，辺に沿って各ノードを訪問していくが，途中に中間ノード[MATH]があったら，[MATH]が付与された部分支持グラフ[MATH]の開始ノードにジャンプする．
そして終了ノードに至ったらジャンプ元のノードに戻る．
これを再帰的に繰り返し，[MATH]の終了ノードに至ったら一回の巡回を終了する．
分岐がある場合はその中のどれかを選ぶ．
このような巡回の途中で中間ノードに付与される部分木ラベルを集めると[MATH]の構文木いずれか一つのラベル集合が得られる．
また，局所パス中のノードの順序を図[REF_fig:support-graph-ichiro]のようにして，巡回中に基本ノードに付与されている規則を順に集めると[MATH]の最左導出における適用規則列[MATH]が一つ得られる．
再帰的巡回を全通り行なえば[MATH]中の適用規則列をすべて見つけることができる．
この考えは後に記述するgEMアルゴリズムの正当性を示すときに用いる（付録[REF_sec:GEM-validity]）．
図[REF_fig:support-graph-ichiro] (b)に再帰的巡回の例を示す．
2つ目の特徴が得られるのは，ある再帰的巡回において，同じ部分木ラベル[MATH]が付与されたノードでは同じ部分支持グラフ[MATH]にジャンプするためである．
このような共有構造により支持グラフのサイズが圧縮され，我々はgEMアルゴリズムを支持グラフの上で動作させることによって効率的な確率計算を実現する．
例えば，図[REF_fig:support-graph-ichiro] (a)において[MATH]が付与されたノード（[MATH]印）では同じ部分支持グラフ[MATH]にジャンプする．
3つ目の特徴は，[MATH]規則およびサイクル[MATH]が存在しないという仮定と，[MATH], [MATH]の定義から明らかであり，「[MATH]であるとき，[MATH]の部分支持グラフ[MATH]中のノードは[MATH]を参照しない」と言い替えることもできる．
この事実に基づき，I-Oアルゴリズムの内側・外側確率計算における動的計画法（節[REF_sec:PCFG:IO]）の考えを一般化したものがgEMアルゴリズムに導入されている．
また，4つ目の特徴は支持グラフの構造の一般性を示しているが，gEMアルゴリズムはこの一般性を保持するように記述される．
次に，支持グラフ[MATH]をパーザがもつWFSTから効率的に抽出する方法を説明する．
[MATH]は[MATH]の要素を[MATH]における半順序関係[MATH]を満たすように全順序に並べたものである．
一般に，半順序関係の全順序関係への変換はトポロジカルソーティングによって実現される．
従って，我々はトポロジカルソーティングの考えに基づき[MATH]を獲得する．
また，ソーティングの途中で[MATH]が計算できる．
以上を実現する支持グラフ抽出ルーチン[MATH]を図[REF_alg:extract-sg]（上）に示す．
ただし，そのサブルーチンは利用するパーザのWFSTの形式に特化したものを用意する．
図[REF_alg:extract-sg]（下）にCYK用サブルーチン[MATH]を示す．
我々は大域的にスタック[MATH]とフラグ[MATH]を用意し，再帰的手続き[MATH]で三角行列（CYKのWFST）の右上隅から部分木[MATH]を次々に訪問する（[MATH]行[REF_list:preproc-CYK:call-visit]）．
そして訪問が終ったら，部分木のラベルをスタック[MATH]に積む（[MATH]行[REF_list:visit-CYK:push]）．
また，訪問の途中で[MATH]を記録していく（[MATH]行[REF_list:visit-CYK:add1], [REF_list:visit-CYK:add2]）．
フラグ[MATH]に訪問したことを記録し，一度訪問した部分木には行かない（[MATH]行[REF_list:visit-RB:mark], [REF_list:visit-CYK:recursion:begin]--[REF_list:visit-CYK:recursion:end]）．
最後にスタック[MATH]に積んであった部分木ラベルを順に取り出せば（[MATH]行[REF_list:preproc-CYK:pop:begin]--[REF_list:preproc-CYK:pop:end]），それが[MATH]になっている．
[b]
\rw{procedure} [MATH] \rw{begin} \itemi\rw{for} [MATH] \rw{to} [MATH] \rw{do} \rw{begin} \itemii Initialize all [MATH] to [MATH] and all [MATH] to [MATH]; \itemii[MATH]; \q\progcomment{スタックを初期化}  \itemii[MATH]; \q\progcomment{各パーザ専用ルーチン;三角行列右上隅から巡回}  \itemii\rw{for} [MATH] \rw{to} [MATH] \rw{do} [MATH]; \q\progcomment{スタック中の整列結果を順に取り出す}  \itemii[MATH]  \itemi\rw{end}
\rw{end}.
\rw{procedure} [MATH] \rw{begin} \itemi Put [MATH] and then [MATH]; \q\progcomment{訪問を記録}  \itemi\rw{if} [MATH] \rw{and} [MATH] \rw{then} Add a set [MATH] to [MATH]  \itemi\rw{else} \itemii\rw{foreach} [MATH] \rw{do} \rw{begin}  \itemiii Add a set [MATH] to [MATH];  \itemiii\rw{if} [MATH] \rw{then}  [MATH]; \q\progcomment{再帰} \itemiii\rw{if} [MATH] \rw{then} [MATH] \q\progcomment{再帰}  \itemii\rw{end}; \itemi[MATH]
\rw{end}.
GLRパーザのWFSTである共有圧縮統語森は[MATH]を木（森）構造で捉えたものと見ることができる．
GLRパーザは文法構造にChomsky標準形を要求しないので，[MATH]よりも一般的な形で記述する必要があるが，スタック[MATH],フラグ[MATH]を用いる点や再帰手続きになる点など基本手続きは[MATH]と変わらない．
また，支持グラフ抽出ルーチンの動作はパーザ備え付けの構文木出力ルーチンや構文木数え上げルーチンによく似ている．
従って，支持グラフ抽出ルーチンを実装するときにはこれらのルーチンを基にすればよい．
提案手法によるPCFG訓練のメインルーチン[MATH]は図[REF_alg:learn-PCFG]のようになる．
2つのサブルーチン[MATH]と[MATH]は先に説明した．
本節ではgEMアルゴリズムを実現する手続き[MATH]を記述する．
I-Oアルゴリズムと同様，gEMアルゴリズムでも内側・外側確率という2つの確率値の計算が中心になる．
各[MATH]の内側確率，外側確率の値は[MATH], [MATH]という配列変数に格納される．
これは各部分支持グラフ[MATH]によって保持される．
また，[MATH]は各局所パス[MATH]ごとに配列変数[MATH]をもつ．
また，配列変数[MATH]に規則[MATH]の期待適用回数が格納される．
[MATH]は内側確率を計算する[MATH],外側確率と規則の期待適用回数を同時に計算する[MATH]という2つのサブルーチンをもつ．
[MATH]を図[REF_alg:GEM]に示す．
[MATH]では，はじめにすべてのパラメタを初期化する（行[REF_list:gEM:init]）．
そして，[MATH], [MATH],パラメタの更新（行[REF_list:gEM:update:begin]--[REF_list:gEM:update:end]）をこの順に繰り返す．
対数尤度[MATH]が収束したら（行[REF_list:gEM:repeat:end]），その時点でのパラメタ値[MATH]を推定値[MATH]として終了する．
[MATH]に文[MATH]の生起確率[MATH]が格納されており，対数尤度の計算にはこの値を使う（行[REF_list:gEM:loglike:1], [REF_list:gEM:loglike:2]）．
図[REF_alg:GEM-sub]にサブルーチン[MATH], [MATH]を示す．
また，図[REF_fig:GEM-sub]は支持グラフ上における各々の計算イメージである．
[t]
\rw{procedure} [MATH] \rw{begin} \itemi\rw{for} [MATH] \rw{to} [MATH] \rw{do} \rw{begin} \itemii Put [MATH]; \itemii\rw{for} [MATH] \rw{downto} [MATH] \rw{do} \rw{begin}  \itemiii\rw{foreach} [MATH] \rw{do} \rw{begin}  \itemiiii[MATH]; \itemiiii\rw{foreach} [MATH] \rw{do}  \itemiiiii\rw{if} [MATH] \rw{then} [MATH] \rw{else} [MATH]  \itemiii\rw{end};\q\progcomment{foreach} [MATH] \itemiii[MATH]  \itemii\rw{end}\q\progcomment{for} [MATH]  \itemi\rw{end}\q\progcomment{for} [MATH]
\rw{end}.
\rw{procedure} [MATH] \rw{begin} \itemi\rw{foreach} [MATH] \rw{do} [MATH];  \itemi\rw{for} [MATH] \rw{to} [MATH] \rw{do} \rw{begin} \itemii Put [MATH]; \itemii\rw{for} [MATH] \rw{to} [MATH] \rw{do} [MATH];  \itemii[MATH]; \q\progcomment{[MATH]は特別に1に初期化}  \itemii\rw{for} [MATH] \rw{to} [MATH] \rw{do}  \itemiii\rw{foreach} [MATH] \rw{do}  \itemiiii\rw{foreach} [MATH] \rw{do} \itemiiiii\rw{if} [MATH] \rw{then} [MATH]  \itemiiiii\rw{else} \rw{if} [MATH] \rw{then} [MATH]  \itemi\rw{end}\q\progcomment{for} [MATH]
\rw{end}.
[MATH]における内側確率[MATH]の計算は[MATH]の最後尾の部分支持グラフから順に行なう．
[MATH]の部分支持グラフ[MATH] ([MATH])の各局所パス[MATH]ではパス中の各ノードの確率積を計算し，[MATH]に格納する（行[REF_list:get-ip:for-tau:begin]--[REF_list:get-ip:for-tau:end],図[REF_fig:GEM-sub] (1)）．
その際，基本ノード[MATH]に対してパラメタ[MATH]を乗じ，中間ノード[MATH]に対して内側確率[MATH]を乗じる（図[REF_fig:GEM-sub] (2)）．
最後に[MATH]の和によって[MATH]を計算する（行[REF_list:get-ip:calc-P],図[REF_fig:GEM-sub] (3)）．
一方，[MATH]では[MATH]とは逆に[MATH]の先頭の部分支持グラフから順に計算を進める．
はじめに配列変数[MATH]と[MATH]を初期化する．
特に外側確率[MATH]について[MATH]の先頭要素[MATH]のみを1,他は0にする点に注意する（行[REF_list:get-exp:init:s:1]--[REF_list:get-exp:init:s:2]）．
次に，ある[MATH]について[MATH]の部分支持グラフ[MATH]の局所パス[MATH]を考える（行[REF_list:get-exp:foreach-E]）．
更に，行[REF_list:get-exp:updateQ]で外側確率[MATH]が書き換えられる[MATH]を考える．
また，行[REF_list:get-exp:updateQ]の式で[MATH]に加算されるのは，[MATH]における[MATH]の局所的な外側確率（パス[MATH]に現れる[MATH]以外のノードの確率積）と[MATH]の親部分木[MATH]の外側確率[MATH]の積である（図[REF_fig:GEM-sub] (4)）．
また，行[REF_list:get-exp:updateON]において，基本ノード[MATH]に対しては局所パスの確率[MATH]と親部分木[MATH]の外側確率[MATH]の積を文[MATH]の生起確率[MATH]で割って[MATH]に足し込む（図[REF_fig:GEM-sub] (5)）．
こうして[MATH]の内容を書き換えていくと，[MATH]の終了時には[MATH]に[MATH]の期待適用回数が格納されている．
gEMアルゴリズムの計算は支持グラフの1つ目の特徴である支持グラフ[MATH]の再帰的巡回（節[REF_sec:GEM:support-graph]）に基づいて正当化される．
それを付録[REF_sec:GEM-validity]で示す．
一般に，EMアルゴリズムは尤度関数の山登りを行なうため局所的な最尤推定しか保証しない．
従って訓練されたパラメタの質は初期パラメタ値に依存する．
LariとYoungはHMMを利用して初期パラメタ値を与える方法を提案している[CITE]．
最も簡便な解決法としては，初期パラメタをランダムに設定することとEMアルゴリズムを動作させることを[MATH]回繰り返し，その中で収束時の対数尤度が最も高かった回の収束パラメタ値を訓練パラメタ値とする．
この方法を以降では簡単に再出発法と呼ぶ．
いったんパラメタ[MATH]が訓練されたら，括弧なしであるテストコーパスの各文[MATH]に対して[MATH]なる[MATH]を計算することができる．
[MATH]に対応する構文木[MATH]を予測構文木（以下，単に予測木）という．
この予測木[MATH]によって入力文[MATH]に対する構文的曖昧性が解消される．
ただし，[MATH]は指数オーダなので，ここでも支持グラフに基づいて[MATH]を計算する．
予測木[MATH]を計算する手続き[MATH]およびそのサブルーチン[MATH]を図[REF_alg:predict]に示す．
[MATH]はテストコーパス[MATH]を受けとり，各[MATH]に対する予測木中の部分木ラベルの集合[MATH]を[MATH]に格納する．
[MATH]では，はじめにパーザ，支持グラフ抽出ルーチン，内側確率計算ルーチン[MATH]の3つを走らせる（行[REF_line:predict-tree:parser]）．
次に，[MATH]が計算した確率値[MATH]を参照しながら，[MATH]に最も確率の高い[MATH]の局所パスを記録する（行[REF_line:predict-tree:record]）．
再帰手続き[MATH]では，支持グラフ[MATH]の再帰的巡回に基づき，[MATH]中のラベル[MATH]を[MATH]に追加する（行[REF_line:const-pred-tree:add]）ことで予測木を構築する．
[MATH]に複数の局所パス候補を格納するように拡張すれば，生起確率上位[MATH]個の予測木が獲得できる．
[t]
\rw{procedure} [MATH] \rw{begin} \itemi Put [MATH]; \itemi[MATH];\q[MATH]; \q[MATH];  \itemi\rw{for} [MATH] \rw{to} [MATH] \rw{do} \rw{begin} \itemii Put [MATH]; \itemii\rw{for} [MATH] \rw{to} [MATH] \rw{do} [MATH];  \itemii[MATH]; \itemii[MATH] \q\progcomment{必ず[MATH]である．
} \itemi\rw{end}
\rw{end}.
\rw{procedure} [MATH] \rw{begin} \itemi\rw{foreach} [MATH] such that [MATH] \rw{do} \rw{begin} \itemii Add [MATH] to [MATH];  \itemii[MATH] \itemi\rw{end}
\rw{end}.
節[REF_sec:PCFG:IO]のI-Oアルゴリズムの計算量評価で述べたように，収束までのパラメタ更新回数は初期値に依存するため，1回のパラメタ更新に要する計算量をgEMアルゴリズムの計算量とする．
手続き[MATH]ではrepeatループ内の計算量をはかればよい．
まず，各[MATH]について[MATH]とおく．
[MATH]に呼び出される[MATH]はその内部処理において[MATH]について[MATH]の要素を一回ずつ訪れることから，
を導入すると，手続き[MATH]の計算量は[MATH]である．
同様に手続き[MATH]においても[MATH]の計算量を要する．
I-Oアルゴリズムの計算量評価と同様，訓練コーパス[MATH]に対して最長の文の長さを[MATH]とし，非終端記号集合[MATH],終端記号集合[MATH]を固定する．
我々はChomsky標準形を満たす文法に対する最悪計算量を考える．
そのために，まずChomsky標準形を満たす最大のPCFGとして節[REF_sec:PCFG:IO]式[REF_eq:Rmax]で導入した規則集合[MATH]を考える．
このとき，[MATH], [MATH], [MATH]なる[MATH], [MATH], [MATH]について下が成り立つ（[MATH]の場合は無視できる）：
[MATH]かつ[MATH]が成り立ち，定義より[MATH]となる．
同様に定義より[MATH]である．
また，[MATH]の更新に要する計算量は[MATH]だが，[MATH]なので無視できる．
以上より手続き[MATH]のrepeatループ内の計算量は[MATH]である．
以上よりgEMアルゴリズムの最悪計算量はI-Oアルゴリズムと同じ[MATH]である．
Chomsky標準形を仮定したとき，CYKパーザ[MATH]と支持グラフ抽出ルーチン[MATH]の最悪計算量はEMの一更新ステップの最悪計算量と同じ[MATH]である．
ただ，EMアルゴリズムでは更新ステップを数10から数100回繰り返すのが通常なので[MATH]が訓練全体に占める割合は小さい．
同様にChomsky標準形を仮定したとき，一つの文に対する生起確率計算，予測木の計算いずれの計算量も[MATH]である([MATH])．
また，式[REF_eq:parent-children]の形をした部分木の親子対を構成要素とするWFSTをもつパーザ（例えばCYKやGLR）では，抽出される[MATH], [MATH]は全く同じになるので，提案手法の計算量は組み合わせたパーザによる差はない．
Earleyパーザを用いた場合に関する評価は付録[REF_sec:Stolcke]に示す．
これまでPCFGに文脈依存性を採り入れたモデル（PCFGの拡張文法と呼ぶ）が数多く提案されているが，Charniakらの疑似確率文脈依存文法(pseudo probabilistic context-sensitive grammars) [CITE]を除けばEMアルゴリズムを具体的に記述した文献は見当たらない．
本節では，提案手法がPCFGの拡張文法に対する多項式オーダのEMアルゴリズムを包含する（提案手法の特長3）ことを示すため，一例としてKitaらの規則バイグラムモデル[CITE]を取り上げ，その多項式オーダのEMアルゴリズムを導出する．
まず，我々はPCFGのときと同様に導出戦略は最左導出に固定する．
規則バイグラムモデルでは，節[REF_sec:PCFG:PCFG]で述べたPCFGの「規則選択は他と独立」という仮定の代わりに，「規則選択は直前の選択のみに依存する」という仮定をおく．
従って，規則バイグラムモデルではPCFGでは扱えなかった文脈依存性も若干考慮できる．
この仮定の下で適用規則列[MATH]の出現確率は
と計算される．
#は境界を表すマーカ，[MATH]は各規則[MATH]に付与されるパラメタである([MATH])．
各[MATH], [MATH]に対し[MATH]が成り立つ．
[CITE]で示された，括弧なしコーパス[MATH]に基づく[MATH]の推定式は式[REF_eq:kita]のとおりである．
適用規則列[MATH]に対して，[MATH]は[MATH]において[MATH]が[MATH]の直後に出現する頻度を表す．
定義より明らかに[MATH]が成り立つ．
ところが式[REF_eq:update], [REF_eq:naive-eta3]から類推できるように，EMアルゴリズムの考えに基づく更新式は次のようになる([MATH])．
つまり式[REF_eq:kita]は相対頻度法，EMアルゴリズムのいずれにもなっていない．
式[REF_eq:kita:EM]の更新式により（局所）最尤推定は実現されるが，これまで述べてきたように一般に[MATH]は文長[MATH]に対して指数オーダになるため，式[REF_eq:kita:EM]は現実時間で計算できない．
一方，提案手法に基づき，式[REF_eq:kita:EM]と等価な規則バイグラムモデルの多項式オーダのEMアルゴリズムを導出することができる．
次節でアルゴリズムを記述するが，その前にいくつかの記号を導入する．
まず，次のような文[MATH]の最左導出列[MATH]を考える:
を考える．
式[REF_eq:RB-derivation]において[MATH]は[MATH]を展開する直前に適用された規則，[MATH]は導出[MATH]で用いられた最後の規則である．
[MATH]と[MATH]を考慮した，[MATH]を統治する部分木ラベルを[MATH]で表す．
また，式[REF_eq:RB-derivation]において[MATH]を[MATH]で参照し，[MATH]の次に適用された規則[MATH]を[MATH]で参照する．
前節で述べた[MATH]の確率で[MATH]が適用される．
また，[MATH]の構文木中の部分木[MATH]を導出するとき最後に使われた規則の集合を[MATH]と定める．
ここではCYKパーザと組み合わせた場合の規則バイグラムモデルのEM学習法を示す．
規則バイグラムモデルを対象にする場合，パーザに新たな変更を加える必要はない．
また，gEMアルゴリズムもその汎用性により，対象とする確率値の意味が変わるだけで制御構造に変化はない．
従って，我々は支持グラフ抽出ルーチンを変更するだけである．
例えば，図[REF_fig:parse-tree-ichiro-CNF]の[MATH]にでは次のような関係[MATH]が得られる．
節[REF_sec:GEM:preliminary]で示したPCFGの場合に比べて，部分木ラベル[MATH]が，その導出直前に適用された規則と自身の導出において最後に適用された規則の組（``[MATH]''記号の後ろ）によって細分化されており，この細分化によって文脈依存性が表現される．
規則バイグラム用の支持グラフ抽出ルーチン[MATH]とそのサブルーチン[MATH]をそれぞれ図[REF_alg:extract-CYK-RB],図[REF_alg:visit-CYK-RB]に示す．
[MATH]は[MATH]の構文木中の部分木[MATH]を訪問し，大域的配列変数[MATH]に[MATH]を格納する再帰手続きである．
後はgEMアルゴリズム（手続き[MATH], [MATH], [MATH]）において[MATH], [MATH], [MATH]を各々[MATH], [MATH], [MATH]といった規則バイグラム用の確率値，期待値に書き換え，[MATH]行[REF_list:gEM:update:begin]--[REF_list:gEM:update:end]と[MATH]行[REF_list:get-exp:init:eta]の\rw{foreach}ループに``\rw{foreach} [MATH]''ループを重ねるだけでよい．
次に，規則バイグラム用EMアルゴリズムの最悪計算量を評価する．
[MATH]を考えたとき，最悪計算量は[MATH]となる．
これは非常に大きなオーダであるが，文長[MATH]に対して3乗のオーダである点はI-Oアルゴリズムと変わらない．
また，節[REF_sec:experiment]の実験結果はPCFGに対する現実の計算時間と最悪時の計算時間[MATH]に大きな差があることを示しており，これは規則バイグラムモデルでも成り立つと考えられる．
実際森らは，節[REF_sec:experiment]の実験で用いたCFG [MATH]に対し本節で述べた方法を適用した結果，規則バイグラムのEM学習におけるパラメタ更新時間がPCFG（図[REF_graph:1]右）の1.5倍程度で収まることを報告している[CITE]．
はじめに，文脈自由文法[MATH]を4つ組[MATH]で定義する．
ただし，[MATH]は非終端記号の集合，[MATH]は終端記号の集合，[MATH]は規則の集合，[MATH]は開始記号[MATH]である．
[MATH]中の各規則[MATH]は[MATH]の形をしており，記号列[MATH]中に非終端記号[MATH]が出現するとき，[MATH]を[MATH]に置き換えることが可能であることを表す．
我々は常に最左の非終端記号を置き換えるように規則を適用する（最左導出に固定する）．
規則[MATH]の適用により記号列[MATH]が[MATH]に置き換えられるとき[MATH]と書く．
このような置き換えを0回以上行なって[MATH]から[MATH]が得られるとき，[MATH]と書く．
特に，置換えが1回以上であることを強調する場合は[MATH]と書く．
[MATH]から導出可能な非終端記号列[MATH]を文と呼ぶ．
CFG [MATH]における文の集合を[MATH]の言語と呼び，[MATH]と書く．
そして，[MATH]に基づくPCFGを[MATH]で表す．
逆に[MATH]を「PCFG [MATH]の文法構造」と呼ぶ．
[MATH]は[MATH]次元ベクトルであり，以降パラメタと呼ぶ．
[MATH]の各要素は[MATH]で参照され，[MATH]が成り立つとする([MATH])．
PCFGでは「適用する規則は他に影響を受けずに選択される」と仮定される．
従って[MATH]における規則の適用列[MATH]の出現確率[MATH]は
と計算される．
また，[MATH]を適用規則列[MATH]中に規則[MATH]が出現する数とすると，
と書くこともできる．
[MATH]を実現する適用規則列すべてから成る集合を[MATH]とおく．
文[MATH]は適用規則列[MATH]から一意に定まるので，文と適用規則列の同時分布[MATH]に関し
が成り立つ．
式[REF_eq:joint-prob]より開始記号[MATH]から[MATH]が導出される確率[MATH]は次のように求まる：
パラメタ[MATH]が文脈より明らかなときは[MATH], [MATH]を各々[MATH], [MATH]と書く．
先述した規則適用の独立性に加え，以降で考えるPCFG [MATH]は次を満たすとする．
[MATH]は整合的である．
すなわち[MATH]が成り立つ．
右辺が[MATH]である規則（[MATH]規則）や[MATH]となるような[MATH]が存在しない．
ChiとZemanは，2番目の条件を満たす文法構造[MATH]と有限長の文から成る括弧なしコーパス[MATH]が与えられたとき，I-Oアルゴリズムで得られる訓練パラメタ[MATH]の下でのPCFG [MATH]が整合的であることを示した[CITE]．
平文[MATH]に対して個々の[MATH]は単語である([MATH], [MATH])．
[MATH]に対して単語位置[MATH]を与える．
[MATH]について[MATH]と[MATH]の間にある部分単語列[MATH]を[MATH]と書く（[MATH]である）．
また，（部分）単語列[MATH]をリスト[MATH]で表すことがある．
[MATH]に対して，[MATH]の構文木は[MATH]の導出過程を木構造で表現したものである．
我々は導出戦略を最左導出に固定しているので，[MATH]の適用規則列[MATH]から[MATH]の構文木[MATH]が一意に決まり，逆も真である．
従って[MATH]が成り立つ．
先に我々は対象とするPCFGが[MATH]規則をもたないこと，[MATH]という導出が起こらないと仮定した．
この仮定より，[MATH]の構文木[MATH]の部分構文木（以下，部分木）[MATH]はその根ノードの非終端記号[MATH]と葉ノードを構成する部分単語列の開始／終了位置の対[MATH]によって一意に定まるので，以降，我々は部分木[MATH]をラベル[MATH]で参照する．
[MATH]の構文木[MATH]は，葉ノードを除く[MATH]の部分木ラベルから成る集合[MATH]（[MATH]のラベル集合と呼ぶ）と同一視できる．
また，[MATH]は一つの括弧づけに相当する．
[MATH]と定め，[MATH]の括弧集合と呼ぶ．
また，[MATH]の展開によって得られた[MATH]を根とする部分木[MATH]を考える（図[REF_fig:parse-tree]）．
このとき[MATH]なる部分木に関する半順序関係[MATH]を導入する([MATH])．
この関係を以降では「[MATH]は[MATH]の親である」，また逆に「[MATH]は[MATH]の子である」などということがある．
そして親[MATH]とその子をすべてまとめて
と表し，これを「部分木の親子対」と呼ぶことにする．
構文木[MATH]中に出現する部分木の親子対をすべて集めた集合を[MATH]で表す．
構文木[MATH]に対応する適用規則列[MATH]に対して[MATH], [MATH], [MATH]をそれぞれ[MATH], [MATH], [MATH]と同一視する．
PCFGの訓練用のコーパスとして我々は(1)構造つきコーパス(labeled corpus)，(2)完全括弧つきコーパス(fully bracketed corpus)，(3)部分括弧つきコーパス(partially bracketed corpus)，(4)括弧なしコーパス(unbracketed corpus)の4つを考える．
我々は訓練法として最尤推定法(maximum likelihood estimation)を考えており，[MATH]文を含むコーパス[MATH]はPCFG [MATH]に基づく独立な[MATH]回のサンプリング導出の結果であると仮定する．
[MATH], [MATH]を[MATH]回目のサンプリングで得られた平文および適用規則列とすると([MATH])，[MATH]が構造つきコーパスのとき[MATH],完全括弧つきコーパスのとき[MATH],部分括弧つきコーパスのとき[MATH],括弧なしコーパスのとき[MATH]となる([MATH], [MATH], [MATH])．
[MATH]の部分単語列を[MATH]とおき[MATH]，[MATH]の[MATH]番目の単語を[MATH]とおく．
ただし[MATH]である．
CYKパーザはChomsky標準形であるCFGに適用可能なパーザである．
我々は括弧なしコーパス[MATH]中の文[MATH]に対して[MATH]の三角行列[MATH]を用意する([MATH])．
[MATH]行[MATH]列の要素[MATH]には部分単語列[MATH]に対する解析結果が格納される．
CYKパーザを実現する手続き[MATH]を図[REF_alg:CYK]に示す．
対角要素から順に部分木を組み上げ（行[REF_list:CYK:fill-diagonal:begin]--[REF_list:CYK:fill-non-diag:end]），[MATH]に[MATH]が含まれていたら解析が成功したものとし，含まれていなかったら失敗したものとする（行[REF_list:CYK:accept]）．
解析が成功したら[MATH]に含まれる[MATH]から順に部分木の親子対を辿って構文木が取り出される．
図[REF_gram:ichiro-CNF]に示したCFG [MATH]において文[MATH]に対する三角行列を図[REF_fig:CYK-table]に示す．
図[REF_fig:CYK-table]の○印のついた部分木の親子から図[REF_fig:parse-tree-ichiro-CNF]の構文木[MATH]が取り出され，●印のついた部分木の親子から[MATH]が取り出される．
先にも述べたように，我々はPCFGのパラメタをコーパス[MATH]から最尤推定法に基づき訓練することを考えている．
[MATH]が構造つきコーパスの場合，相対頻度法で得られる各規則[MATH]の相対出現頻度が最尤推定値となるので，これを[MATH]の訓練パラメタ[MATH]とすればよい．
しかし，構造つきコーパスの作成コストを考えると，より安価な括弧なしコーパスしか利用できない場合が十分考えられる．
括弧なしコーパスでは構文構造が明らかでないため，相対頻度法が適用できず，代わりにI-OアルゴリズムというPCFGに特化された形のEMアルゴリズムが広く知られている．
I-Oアルゴリズムは，括弧なしコーパス[MATH]が与えられたときに尤度[MATH]あるいはその対数[MATH]（対数尤度）を局所的に最大にする[MATH]を見つける．
つまりI-Oアルゴリズムもまた最尤推定法である．
[CITE]をはじめとする多くの文献の記述では，文法構造[MATH]のうち規則集合[MATH]を明示的に与えず，終端記号集合[MATH]と非終端記号集合[MATH]を与えた場合を考えている．
提案手法との対比のため，本節では[MATH]を明示的に与えた場合のI-Oアルゴリズムを記述する．
[MATH]と[MATH]のみを与えた場合のI-Oアルゴリズムは
（以下では[MATH]と略すことがある）を考え，規則集合を[MATH]として与えた場合と同一である．
ただし，いずれの場合でも[MATH]はChomsky標準形でなければならない．
[CITE]では規則集合[MATH]を含めた学習を目的にI-Oアルゴリズムを使用しているが，我々はパラメタ[MATH]の学習に焦点を絞る．
I-Oアルゴリズムの中心は内側確率[MATH]と外側確率[MATH]という2つの確率値の計算である([MATH], [MATH], [MATH])．
各確率値を配列変数[MATH], [MATH]に格納する．
これらの配列変数はCYKアルゴリズムで用いた三角行列[MATH]中に設けられているものとする．
[MATH]より[MATH]に文[MATH]の生起確率[MATH]が格納される点に注意する．
[b]
\rw{procedure} [MATH] \rw{begin} \itemi\rw{for} [MATH] \rw{to} [MATH] \rw{do} \rw{begin} \itemii\rw{for} [MATH] \rw{to} [MATH] \rw{do} \q\progcomment{三角行列の対角要素について計算} \itemiii\rw{foreach} [MATH] such that [MATH] \rw{do} \itemiiii[MATH];  \itemii\rw{for} [MATH] \rw{to} [MATH] \rw{do} \q\progcomment{三角行列の非対角要素について計算} \itemiii\rw{for} [MATH] \rw{to} [MATH] \rw{do} \itemiiii\rw{foreach} [MATH] \rw{do} \itemiiiii[MATH]  \itemi\rw{end}
\rw{end}.
\rw{procedure} [MATH] \rw{begin} \itemi\rw{for} [MATH] \rw{to} [MATH] \rw{do} \rw{begin} \itemii[MATH]; \q\progcomment{右上隅の[MATH]については特別に1に初期化}   \itemii\rw{for} [MATH] \rw{downto} [MATH] \rw{do}  \itemiii\rw{for} [MATH] \rw{to} [MATH] \rw{do} \itemiiii\rw{foreach} [MATH] \rw{do} \itemiiiii[MATH]  \itemiiiiiiiiii[MATH]  \itemi\rw{end}
\rw{end}.
内側確率と外側確率を計算する手続き[MATH], [MATH]を図[REF_alg:get-beta-alpha]に示す．
記述を簡単にするため，配列変数[MATH]および[MATH]は手続きが呼び出される度に0に初期化されるものとする．
[MATH]はCYKパーザにおいて部分木を組み上げるのと同じように，三角行列の対角要素から出発し，右上隅[MATH]に至るまで段階的に内側確率を計算していく．
また，逆に[MATH]では右上隅[MATH]から対角要素に向かって外側確率を計算する．
このように内側・外側確率は動的計画法(dynamic programming)に基づき，一方向に従って計算が進められる．
内側・外側確率を計算し終ったら，コーパス[MATH]が与えられた下での規則[MATH], [MATH]の適用回数の条件つき期待値（以下，期待適用回数という）が次のように計算される:
{
}
更に，上で計算された期待値からパラメタ[MATH]が更新（再推定）される:
I-Oアルゴリズムでは，まず[MATH]を適当な値に初期化し，次いで手続き[MATH], [MATH]および式[REF_eq:eta-ABC], [REF_eq:eta-Aa], [REF_eq:update]によって[MATH]を更新する．
そして，このように更新を繰り返すと対数尤度[MATH]が単調増加しながら最終的には収束する．
収束したら，そのときのパラメタの値を最終的な推定値としてI-Oアルゴリズムは終了する．
ここで，I-Oアルゴリズムの計算量を考える．
収束までのパラメタ更新回数は初期値に依存するため，事前には分からない．
従って1回のパラメタ更新に必要な計算量をI-Oアルゴリズムの計算量とする．
非終端記号集合[MATH],終端記号集合[MATH]を固定した場合の最悪計算量を測る場合には[MATH]の場合を考えればよい．
訓練コーパス[MATH]に対して最長の文の長さを[MATH]とする．
手続き[MATH], [MATH]（図[REF_alg:get-beta-alpha]）中のfor, foreachループと[MATH]の引数に注目すれば，I-Oアルゴリズムの最悪計算量は[MATH]であることが容易に分かる．
アルゴリズム中で最もコストが高いのは，[MATH]行[REF_list:get-beta:calc-beta]における内側確率の計算，[MATH]行[REF_list:get-alpha:calc-op:begin]--[REF_list:get-alpha:calc-op:end]における外側確率の計算である．
[MATH]行[REF_list:get-beta:calc-beta]において図[REF_fig:get-beta-alpha] (1)という状況すべてを考慮して内側確率が計算される．
一方，[MATH]の行[REF_list:get-alpha:calc-op:begin]--[REF_list:get-alpha:calc-op:end]における右辺第1項，第2項ではそれぞれ図[REF_fig:get-beta-alpha] (2), (3)という状況がすべて考慮されている．
考えられるすべての状況について計算をすすめるという意味でI-Oアルゴリズムの動作は仮説駆動（トップダウン）型パーザの動作と同じである．
一般に仮説駆動型は入力文[MATH]の情報とは無関係に計算をすすめるために効率が悪いとされている．
文法構造が与えられていてもI-Oアルゴリズムの計算速度が低いのは，仮説駆動型であることが原因であると考えられる．
そもそもI-Oアルゴリズムは
という規則[MATH]の期待適用回数[MATH]の計算を
から得られる手続き[MATH], [MATH]および式[REF_eq:eta-ABC], [REF_eq:eta-Aa]によって効率化したものである[CITE]．
ただし，節[REF_sec:PCFG:PCFG]で定めたように[MATH]は規則列[MATH]に出現する規則[MATH]の数である．
式[REF_eq:naive-eta2]で，[MATH]とおいたとき，I-Oアルゴリズムでは[MATH]を次のように計算する（添字の[MATH], [MATH]は省略）．
式[REF_eq:with-position]の変形は入力文[MATH]や実際の構文木[MATH]とは無関係に行なわれており，I-Oアルゴリズムが仮説駆動型であるというのはこの点に由来する．
それに対し，式[REF_eq:joint-prob]より式[REF_eq:naive-eta]を下の式[REF_eq:naive-eta3]に変形し，構文木情報[MATH]を直接利用する方法を考える．
[MATH]はパーザを利用することによって事前に獲得しておく．
また，式[REF_eq:naive-eta3]はFujisakiらの計算方法[CITE]に他ならない．
式[REF_eq:naive-eta3]を用いればI-Oアルゴリズムのように[MATH]と無関係な部分を計算することはなくなる．
ただし，一般に[MATH]は文長[MATH]に対して指数オーダになってしまうため，これをそのまま計算するのは現実的ではない．
提案手法ではI-Oアルゴリズムのように再計算を防ぐ仕組みを取り入れ，パーザのもつWFSTを利用して式[REF_eq:naive-eta3]を効率的に計算する．
従って，提案手法をFujisakiらの方法とI-Oアルゴリズム双方の長所を取り入れた方法と見ることもできる．
提案手法の概要を図[REF_fig:scheme]に示す．
入力として確率文脈文法[MATH]の文法構造[MATH]と括弧なしコーパス[MATH]が与えられるものとする．
そして訓練パラメタ[MATH]を出力として返す．
提案手法において，我々は全体の訓練過程を構文解析とEM学習に分離する．
はじめに我々はパーザで[MATH]中の各文[MATH]をすべて解析する．
すると[MATH]を細切れにした，しかし[MATH]と等価な構文情報[MATH]がパーザのWFSTに格納されているので，これらを抽出する．
[MATH]を表現するデータ構造を支持グラフと呼ぶ．
次に，支持グラフに基づきgEMアルゴリズムを動作させ[MATH]を得る．
図[REF_gram:ichiro-CNF]のCFG [MATH]と文[MATH]の例を考えると，支持グラフは図[REF_fig:CYK-table]において○印と●印がついた部分木の親子から得られる．
この例から分かるように，文法によってはgEMアルゴリズムで参照する支持グラフは三角行列全体に比べて非常に小さくなる可能性があり，その場合は三角行列全体を走査しなければならないI-Oアルゴリズムに比べ大幅な速度向上が得られる（提案手法の特長2）．
提案手法を記述する前に形式化を行なう．
[MATH]について以下をおこなう．
まず，[MATH], [MATH]と定める．
そして，[MATH]の要素を[MATH]を満たすように並べた[MATH]を[MATH]とする．
また，次を導入する．
[MATH]はコーパス中の文[MATH]の構文木のいずれかに現れる部分木の親子対の集合である．
同様に[MATH]は[MATH]の構文木のいずれかに現れる部分木ラベルの集合である．
[MATH]は[MATH]の要素を[MATH]中の半順序関係（親子関係）[MATH]を満たすように順序づけたものである．
[MATH]の第一要素[MATH]は必ず[MATH]になる．
[MATH]は部分木と規則の論理的な関係を表現する．
例えば，
に対しては，「[MATH]に対して部分木[MATH]を作るためには，規則[MATH]を適用し，部分木[MATH]と部分木[MATH]を作る，もしくは規則[MATH]を適用し，部分木[MATH]と部分木[MATH]を作る，のいずれかである（他の場合はあり得ない）」と解釈する．
[MATH]と[MATH]は次節で説明する支持グラフを構成する．
例として，図[REF_gram:ichiro-CNF]のCFG [MATH]と[MATH]に対して図[REF_fig:parse-tree-ichiro-CNF]の2つの構文木[MATH], [MATH]を考える．
各々に対応する適用規則列を[MATH]とおくと，[MATH]である．
このとき[MATH]は
{
}
となる．
また，[MATH]は一意には決まらないが，どの場合でも第一要素は必ず[MATH]になる点に注意する．
例えば下のような[MATH]が考えられる．
{
}
また[MATH]を[MATH]の順に示す．
[MATH]という組を支持グラフ[MATH]というデータ構造で捉えるとgEMアルゴリズムが理解しやすくなる．
「グラフィカルEM」の名もここに由来する．
まず，前節で示した[MATH], [MATH]の例に対応する支持グラフを図[REF_fig:support-graph-ichiro] (a)に示す．
支持グラフ[MATH]は再帰遷移ネットワーク（recursive transition network;以下RTN）に似た構造をもつ非循環有向グラフ(DAG)であり，共通の辺をもたない部分グラフ[MATH]の集まりから成る（ただし[MATH]）．
各[MATH]は「[MATH]の部分支持グラフ」と呼ばれ，[MATH]が付与されている．
また，[MATH]は開始ノード，終了ノードと呼ばれる2つの特殊なノードをもち（図[REF_fig:support-graph-ichiro]では各々start, endと書かれている），各[MATH]に対して開始ノード，[MATH]の各要素（規則[MATH]または部分木ラベル[MATH]）が付与されたノード，終了ノードが一列に連結されている．
複数のノードに同じ規則または部分木ラベルが付与されることもある点に注意する．
有向辺はすべて開始ノードから終了ノードに向かっている．
開始ノードから終了ノードに至るパスを局所パスと呼び，これも[MATH]で参照する．
局所パスにおいて，規則[MATH]が付与されたノードを基本ノード，部分木ラベル[MATH]が付与されたノードを中間ノードと呼び，各々図[REF_fig:support-graph-ichiro]のように○と◎で表す．
支持グラフは次の特徴をもつ．
支持グラフ[MATH]に対してRTNのように再帰的な巡回を行なうことができる．
複数の巡回パスの一部が共有される．
部分支持グラフ[MATH]の[MATH]に対して，どの[MATH]についても[MATH]が成り立つ．
一つの局所パス中に存在する基本ノードと中間ノードの数に制限がない．
1つ目の特徴である再帰的な巡回は次のようにして行なわれる．
[MATH]の開始ノードから出発し，辺に沿って各ノードを訪問していくが，途中に中間ノード[MATH]があったら，[MATH]が付与された部分支持グラフ[MATH]の開始ノードにジャンプする．
そして終了ノードに至ったらジャンプ元のノードに戻る．
これを再帰的に繰り返し，[MATH]の終了ノードに至ったら一回の巡回を終了する．
分岐がある場合はその中のどれかを選ぶ．
このような巡回の途中で中間ノードに付与される部分木ラベルを集めると[MATH]の構文木いずれか一つのラベル集合が得られる．
また，局所パス中のノードの順序を図[REF_fig:support-graph-ichiro]のようにして，巡回中に基本ノードに付与されている規則を順に集めると[MATH]の最左導出における適用規則列[MATH]が一つ得られる．
再帰的巡回を全通り行なえば[MATH]中の適用規則列をすべて見つけることができる．
この考えは後に記述するgEMアルゴリズムの正当性を示すときに用いる（付録[REF_sec:GEM-validity]）．
図[REF_fig:support-graph-ichiro] (b)に再帰的巡回の例を示す．
2つ目の特徴が得られるのは，ある再帰的巡回において，同じ部分木ラベル[MATH]が付与されたノードでは同じ部分支持グラフ[MATH]にジャンプするためである．
このような共有構造により支持グラフのサイズが圧縮され，我々はgEMアルゴリズムを支持グラフの上で動作させることによって効率的な確率計算を実現する．
例えば，図[REF_fig:support-graph-ichiro] (a)において[MATH]が付与されたノード（[MATH]印）では同じ部分支持グラフ[MATH]にジャンプする．
3つ目の特徴は，[MATH]規則およびサイクル[MATH]が存在しないという仮定と，[MATH], [MATH]の定義から明らかであり，「[MATH]であるとき，[MATH]の部分支持グラフ[MATH]中のノードは[MATH]を参照しない」と言い替えることもできる．
この事実に基づき，I-Oアルゴリズムの内側・外側確率計算における動的計画法（節[REF_sec:PCFG:IO]）の考えを一般化したものがgEMアルゴリズムに導入されている．
また，4つ目の特徴は支持グラフの構造の一般性を示しているが，gEMアルゴリズムはこの一般性を保持するように記述される．
次に，支持グラフ[MATH]をパーザがもつWFSTから効率的に抽出する方法を説明する．
[MATH]は[MATH]の要素を[MATH]における半順序関係[MATH]を満たすように全順序に並べたものである．
一般に，半順序関係の全順序関係への変換はトポロジカルソーティングによって実現される．
従って，我々はトポロジカルソーティングの考えに基づき[MATH]を獲得する．
また，ソーティングの途中で[MATH]が計算できる．
以上を実現する支持グラフ抽出ルーチン[MATH]を図[REF_alg:extract-sg]（上）に示す．
ただし，そのサブルーチンは利用するパーザのWFSTの形式に特化したものを用意する．
図[REF_alg:extract-sg]（下）にCYK用サブルーチン[MATH]を示す．
我々は大域的にスタック[MATH]とフラグ[MATH]を用意し，再帰的手続き[MATH]で三角行列（CYKのWFST）の右上隅から部分木[MATH]を次々に訪問する（[MATH]行[REF_list:preproc-CYK:call-visit]）．
そして訪問が終ったら，部分木のラベルをスタック[MATH]に積む（[MATH]行[REF_list:visit-CYK:push]）．
また，訪問の途中で[MATH]を記録していく（[MATH]行[REF_list:visit-CYK:add1], [REF_list:visit-CYK:add2]）．
フラグ[MATH]に訪問したことを記録し，一度訪問した部分木には行かない（[MATH]行[REF_list:visit-RB:mark], [REF_list:visit-CYK:recursion:begin]--[REF_list:visit-CYK:recursion:end]）．
最後にスタック[MATH]に積んであった部分木ラベルを順に取り出せば（[MATH]行[REF_list:preproc-CYK:pop:begin]--[REF_list:preproc-CYK:pop:end]），それが[MATH]になっている．
[b]
\rw{procedure} [MATH] \rw{begin} \itemi\rw{for} [MATH] \rw{to} [MATH] \rw{do} \rw{begin} \itemii Initialize all [MATH] to [MATH] and all [MATH] to [MATH]; \itemii[MATH]; \q\progcomment{スタックを初期化}  \itemii[MATH]; \q\progcomment{各パーザ専用ルーチン;三角行列右上隅から巡回}  \itemii\rw{for} [MATH] \rw{to} [MATH] \rw{do} [MATH]; \q\progcomment{スタック中の整列結果を順に取り出す}  \itemii[MATH]  \itemi\rw{end}
\rw{end}.
\rw{procedure} [MATH] \rw{begin} \itemi Put [MATH] and then [MATH]; \q\progcomment{訪問を記録}  \itemi\rw{if} [MATH] \rw{and} [MATH] \rw{then} Add a set [MATH] to [MATH]  \itemi\rw{else} \itemii\rw{foreach} [MATH] \rw{do} \rw{begin}  \itemiii Add a set [MATH] to [MATH];  \itemiii\rw{if} [MATH] \rw{then}  [MATH]; \q\progcomment{再帰} \itemiii\rw{if} [MATH] \rw{then} [MATH] \q\progcomment{再帰}  \itemii\rw{end}; \itemi[MATH]
\rw{end}.
GLRパーザのWFSTである共有圧縮統語森は[MATH]を木（森）構造で捉えたものと見ることができる．
GLRパーザは文法構造にChomsky標準形を要求しないので，[MATH]よりも一般的な形で記述する必要があるが，スタック[MATH],フラグ[MATH]を用いる点や再帰手続きになる点など基本手続きは[MATH]と変わらない．
また，支持グラフ抽出ルーチンの動作はパーザ備え付けの構文木出力ルーチンや構文木数え上げルーチンによく似ている．
従って，支持グラフ抽出ルーチンを実装するときにはこれらのルーチンを基にすればよい．
提案手法によるPCFG訓練のメインルーチン[MATH]は図[REF_alg:learn-PCFG]のようになる．
2つのサブルーチン[MATH]と[MATH]は先に説明した．
本節ではgEMアルゴリズムを実現する手続き[MATH]を記述する．
I-Oアルゴリズムと同様，gEMアルゴリズムでも内側・外側確率という2つの確率値の計算が中心になる．
各[MATH]の内側確率，外側確率の値は[MATH], [MATH]という配列変数に格納される．
これは各部分支持グラフ[MATH]によって保持される．
また，[MATH]は各局所パス[MATH]ごとに配列変数[MATH]をもつ．
また，配列変数[MATH]に規則[MATH]の期待適用回数が格納される．
[MATH]は内側確率を計算する[MATH],外側確率と規則の期待適用回数を同時に計算する[MATH]という2つのサブルーチンをもつ．
[MATH]を図[REF_alg:GEM]に示す．
[MATH]では，はじめにすべてのパラメタを初期化する（行[REF_list:gEM:init]）．
そして，[MATH], [MATH],パラメタの更新（行[REF_list:gEM:update:begin]--[REF_list:gEM:update:end]）をこの順に繰り返す．
対数尤度[MATH]が収束したら（行[REF_list:gEM:repeat:end]），その時点でのパラメタ値[MATH]を推定値[MATH]として終了する．
[MATH]に文[MATH]の生起確率[MATH]が格納されており，対数尤度の計算にはこの値を使う（行[REF_list:gEM:loglike:1], [REF_list:gEM:loglike:2]）．
図[REF_alg:GEM-sub]にサブルーチン[MATH], [MATH]を示す．
また，図[REF_fig:GEM-sub]は支持グラフ上における各々の計算イメージである．
[t]
\rw{procedure} [MATH] \rw{begin} \itemi\rw{for} [MATH] \rw{to} [MATH] \rw{do} \rw{begin} \itemii Put [MATH]; \itemii\rw{for} [MATH] \rw{downto} [MATH] \rw{do} \rw{begin}  \itemiii\rw{foreach} [MATH] \rw{do} \rw{begin}  \itemiiii[MATH]; \itemiiii\rw{foreach} [MATH] \rw{do}  \itemiiiii\rw{if} [MATH] \rw{then} [MATH] \rw{else} [MATH]  \itemiii\rw{end};\q\progcomment{foreach} [MATH] \itemiii[MATH]  \itemii\rw{end}\q\progcomment{for} [MATH]  \itemi\rw{end}\q\progcomment{for} [MATH]
\rw{end}.
\rw{procedure} [MATH] \rw{begin} \itemi\rw{foreach} [MATH] \rw{do} [MATH];  \itemi\rw{for} [MATH] \rw{to} [MATH] \rw{do} \rw{begin} \itemii Put [MATH]; \itemii\rw{for} [MATH] \rw{to} [MATH] \rw{do} [MATH];  \itemii[MATH]; \q\progcomment{[MATH]は特別に1に初期化}  \itemii\rw{for} [MATH] \rw{to} [MATH] \rw{do}  \itemiii\rw{foreach} [MATH] \rw{do}  \itemiiii\rw{foreach} [MATH] \rw{do} \itemiiiii\rw{if} [MATH] \rw{then} [MATH]  \itemiiiii\rw{else} \rw{if} [MATH] \rw{then} [MATH]  \itemi\rw{end}\q\progcomment{for} [MATH]
\rw{end}.
[MATH]における内側確率[MATH]の計算は[MATH]の最後尾の部分支持グラフから順に行なう．
[MATH]の部分支持グラフ[MATH] ([MATH])の各局所パス[MATH]ではパス中の各ノードの確率積を計算し，[MATH]に格納する（行[REF_list:get-ip:for-tau:begin]--[REF_list:get-ip:for-tau:end],図[REF_fig:GEM-sub] (1)）．
その際，基本ノード[MATH]に対してパラメタ[MATH]を乗じ，中間ノード[MATH]に対して内側確率[MATH]を乗じる（図[REF_fig:GEM-sub] (2)）．
最後に[MATH]の和によって[MATH]を計算する（行[REF_list:get-ip:calc-P],図[REF_fig:GEM-sub] (3)）．
一方，[MATH]では[MATH]とは逆に[MATH]の先頭の部分支持グラフから順に計算を進める．
はじめに配列変数[MATH]と[MATH]を初期化する．
特に外側確率[MATH]について[MATH]の先頭要素[MATH]のみを1,他は0にする点に注意する（行[REF_list:get-exp:init:s:1]--[REF_list:get-exp:init:s:2]）．
次に，ある[MATH]について[MATH]の部分支持グラフ[MATH]の局所パス[MATH]を考える（行[REF_list:get-exp:foreach-E]）．
更に，行[REF_list:get-exp:updateQ]で外側確率[MATH]が書き換えられる[MATH]を考える．
また，行[REF_list:get-exp:updateQ]の式で[MATH]に加算されるのは，[MATH]における[MATH]の局所的な外側確率（パス[MATH]に現れる[MATH]以外のノードの確率積）と[MATH]の親部分木[MATH]の外側確率[MATH]の積である（図[REF_fig:GEM-sub] (4)）．
また，行[REF_list:get-exp:updateON]において，基本ノード[MATH]に対しては局所パスの確率[MATH]と親部分木[MATH]の外側確率[MATH]の積を文[MATH]の生起確率[MATH]で割って[MATH]に足し込む（図[REF_fig:GEM-sub] (5)）．
こうして[MATH]の内容を書き換えていくと，[MATH]の終了時には[MATH]に[MATH]の期待適用回数が格納されている．
gEMアルゴリズムの計算は支持グラフの1つ目の特徴である支持グラフ[MATH]の再帰的巡回（節[REF_sec:GEM:support-graph]）に基づいて正当化される．
それを付録[REF_sec:GEM-validity]で示す．
一般に，EMアルゴリズムは尤度関数の山登りを行なうため局所的な最尤推定しか保証しない．
従って訓練されたパラメタの質は初期パラメタ値に依存する．
LariとYoungはHMMを利用して初期パラメタ値を与える方法を提案している[CITE]．
最も簡便な解決法としては，初期パラメタをランダムに設定することとEMアルゴリズムを動作させることを[MATH]回繰り返し，その中で収束時の対数尤度が最も高かった回の収束パラメタ値を訓練パラメタ値とする．
この方法を以降では簡単に再出発法と呼ぶ．
いったんパラメタ[MATH]が訓練されたら，括弧なしであるテストコーパスの各文[MATH]に対して[MATH]なる[MATH]を計算することができる．
[MATH]に対応する構文木[MATH]を予測構文木（以下，単に予測木）という．
この予測木[MATH]によって入力文[MATH]に対する構文的曖昧性が解消される．
ただし，[MATH]は指数オーダなので，ここでも支持グラフに基づいて[MATH]を計算する．
予測木[MATH]を計算する手続き[MATH]およびそのサブルーチン[MATH]を図[REF_alg:predict]に示す．
[MATH]はテストコーパス[MATH]を受けとり，各[MATH]に対する予測木中の部分木ラベルの集合[MATH]を[MATH]に格納する．
[MATH]では，はじめにパーザ，支持グラフ抽出ルーチン，内側確率計算ルーチン[MATH]の3つを走らせる（行[REF_line:predict-tree:parser]）．
次に，[MATH]が計算した確率値[MATH]を参照しながら，[MATH]に最も確率の高い[MATH]の局所パスを記録する（行[REF_line:predict-tree:record]）．
再帰手続き[MATH]では，支持グラフ[MATH]の再帰的巡回に基づき，[MATH]中のラベル[MATH]を[MATH]に追加する（行[REF_line:const-pred-tree:add]）ことで予測木を構築する．
[MATH]に複数の局所パス候補を格納するように拡張すれば，生起確率上位[MATH]個の予測木が獲得できる．
[t]
\rw{procedure} [MATH] \rw{begin} \itemi Put [MATH]; \itemi[MATH];\q[MATH]; \q[MATH];  \itemi\rw{for} [MATH] \rw{to} [MATH] \rw{do} \rw{begin} \itemii Put [MATH]; \itemii\rw{for} [MATH] \rw{to} [MATH] \rw{do} [MATH];  \itemii[MATH]; \itemii[MATH] \q\progcomment{必ず[MATH]である．
} \itemi\rw{end}
\rw{end}.
\rw{procedure} [MATH] \rw{begin} \itemi\rw{foreach} [MATH] such that [MATH] \rw{do} \rw{begin} \itemii Add [MATH] to [MATH];  \itemii[MATH] \itemi\rw{end}
\rw{end}.
節[REF_sec:PCFG:IO]のI-Oアルゴリズムの計算量評価で述べたように，収束までのパラメタ更新回数は初期値に依存するため，1回のパラメタ更新に要する計算量をgEMアルゴリズムの計算量とする．
手続き[MATH]ではrepeatループ内の計算量をはかればよい．
まず，各[MATH]について[MATH]とおく．
[MATH]に呼び出される[MATH]はその内部処理において[MATH]について[MATH]の要素を一回ずつ訪れることから，
を導入すると，手続き[MATH]の計算量は[MATH]である．
同様に手続き[MATH]においても[MATH]の計算量を要する．
I-Oアルゴリズムの計算量評価と同様，訓練コーパス[MATH]に対して最長の文の長さを[MATH]とし，非終端記号集合[MATH],終端記号集合[MATH]を固定する．
我々はChomsky標準形を満たす文法に対する最悪計算量を考える．
そのために，まずChomsky標準形を満たす最大のPCFGとして節[REF_sec:PCFG:IO]式[REF_eq:Rmax]で導入した規則集合[MATH]を考える．
このとき，[MATH], [MATH], [MATH]なる[MATH], [MATH], [MATH]について下が成り立つ（[MATH]の場合は無視できる）：
[MATH]かつ[MATH]が成り立ち，定義より[MATH]となる．
同様に定義より[MATH]である．
また，[MATH]の更新に要する計算量は[MATH]だが，[MATH]なので無視できる．
以上より手続き[MATH]のrepeatループ内の計算量は[MATH]である．
以上よりgEMアルゴリズムの最悪計算量はI-Oアルゴリズムと同じ[MATH]である．
Chomsky標準形を仮定したとき，CYKパーザ[MATH]と支持グラフ抽出ルーチン[MATH]の最悪計算量はEMの一更新ステップの最悪計算量と同じ[MATH]である．
ただ，EMアルゴリズムでは更新ステップを数10から数100回繰り返すのが通常なので[MATH]が訓練全体に占める割合は小さい．
同様にChomsky標準形を仮定したとき，一つの文に対する生起確率計算，予測木の計算いずれの計算量も[MATH]である([MATH])．
また，式[REF_eq:parent-children]の形をした部分木の親子対を構成要素とするWFSTをもつパーザ（例えばCYKやGLR）では，抽出される[MATH], [MATH]は全く同じになるので，提案手法の計算量は組み合わせたパーザによる差はない．
Earleyパーザを用いた場合に関する評価は付録[REF_sec:Stolcke]に示す．
これまでPCFGに文脈依存性を採り入れたモデル（PCFGの拡張文法と呼ぶ）が数多く提案されているが，Charniakらの疑似確率文脈依存文法(pseudo probabilistic context-sensitive grammars) [CITE]を除けばEMアルゴリズムを具体的に記述した文献は見当たらない．
本節では，提案手法がPCFGの拡張文法に対する多項式オーダのEMアルゴリズムを包含する（提案手法の特長3）ことを示すため，一例としてKitaらの規則バイグラムモデル[CITE]を取り上げ，その多項式オーダのEMアルゴリズムを導出する．
まず，我々はPCFGのときと同様に導出戦略は最左導出に固定する．
規則バイグラムモデルでは，節[REF_sec:PCFG:PCFG]で述べたPCFGの「規則選択は他と独立」という仮定の代わりに，「規則選択は直前の選択のみに依存する」という仮定をおく．
従って，規則バイグラムモデルではPCFGでは扱えなかった文脈依存性も若干考慮できる．
この仮定の下で適用規則列[MATH]の出現確率は
と計算される．
#は境界を表すマーカ，[MATH]は各規則[MATH]に付与されるパラメタである([MATH])．
各[MATH], [MATH]に対し[MATH]が成り立つ．
[CITE]で示された，括弧なしコーパス[MATH]に基づく[MATH]の推定式は式[REF_eq:kita]のとおりである．
適用規則列[MATH]に対して，[MATH]は[MATH]において[MATH]が[MATH]の直後に出現する頻度を表す．
定義より明らかに[MATH]が成り立つ．
ところが式[REF_eq:update], [REF_eq:naive-eta3]から類推できるように，EMアルゴリズムの考えに基づく更新式は次のようになる([MATH])．
つまり式[REF_eq:kita]は相対頻度法，EMアルゴリズムのいずれにもなっていない．
式[REF_eq:kita:EM]の更新式により（局所）最尤推定は実現されるが，これまで述べてきたように一般に[MATH]は文長[MATH]に対して指数オーダになるため，式[REF_eq:kita:EM]は現実時間で計算できない．
一方，提案手法に基づき，式[REF_eq:kita:EM]と等価な規則バイグラムモデルの多項式オーダのEMアルゴリズムを導出することができる．
次節でアルゴリズムを記述するが，その前にいくつかの記号を導入する．
まず，次のような文[MATH]の最左導出列[MATH]を考える:
を考える．
式[REF_eq:RB-derivation]において[MATH]は[MATH]を展開する直前に適用された規則，[MATH]は導出[MATH]で用いられた最後の規則である．
[MATH]と[MATH]を考慮した，[MATH]を統治する部分木ラベルを[MATH]で表す．
また，式[REF_eq:RB-derivation]において[MATH]を[MATH]で参照し，[MATH]の次に適用された規則[MATH]を[MATH]で参照する．
前節で述べた[MATH]の確率で[MATH]が適用される．
また，[MATH]の構文木中の部分木[MATH]を導出するとき最後に使われた規則の集合を[MATH]と定める．
ここではCYKパーザと組み合わせた場合の規則バイグラムモデルのEM学習法を示す．
規則バイグラムモデルを対象にする場合，パーザに新たな変更を加える必要はない．
また，gEMアルゴリズムもその汎用性により，対象とする確率値の意味が変わるだけで制御構造に変化はない．
従って，我々は支持グラフ抽出ルーチンを変更するだけである．
例えば，図[REF_fig:parse-tree-ichiro-CNF]の[MATH]にでは次のような関係[MATH]が得られる．
節[REF_sec:GEM:preliminary]で示したPCFGの場合に比べて，部分木ラベル[MATH]が，その導出直前に適用された規則と自身の導出において最後に適用された規則の組（``[MATH]''記号の後ろ）によって細分化されており，この細分化によって文脈依存性が表現される．
規則バイグラム用の支持グラフ抽出ルーチン[MATH]とそのサブルーチン[MATH]をそれぞれ図[REF_alg:extract-CYK-RB],図[REF_alg:visit-CYK-RB]に示す．
[MATH]は[MATH]の構文木中の部分木[MATH]を訪問し，大域的配列変数[MATH]に[MATH]を格納する再帰手続きである．
後はgEMアルゴリズム（手続き[MATH], [MATH], [MATH]）において[MATH], [MATH], [MATH]を各々[MATH], [MATH], [MATH]といった規則バイグラム用の確率値，期待値に書き換え，[MATH]行[REF_list:gEM:update:begin]--[REF_list:gEM:update:end]と[MATH]行[REF_list:get-exp:init:eta]の\rw{foreach}ループに``\rw{foreach} [MATH]''ループを重ねるだけでよい．
次に，規則バイグラム用EMアルゴリズムの最悪計算量を評価する．
[MATH]を考えたとき，最悪計算量は[MATH]となる．
これは非常に大きなオーダであるが，文長[MATH]に対して3乗のオーダである点はI-Oアルゴリズムと変わらない．
また，節[REF_sec:experiment]の実験結果はPCFGに対する現実の計算時間と最悪時の計算時間[MATH]に大きな差があることを示しており，これは規則バイグラムモデルでも成り立つと考えられる．
実際森らは，節[REF_sec:experiment]の実験で用いたCFG [MATH]に対し本節で述べた方法を適用した結果，規則バイグラムのEM学習におけるパラメタ更新時間がPCFG（図[REF_graph:1]右）の1.5倍程度で収まることを報告している[CITE]．
