
提案手法の基本的な能力を調査するために，以下の方針に従って原始格フレーム表を作成して格フレーム木獲得実験を行った[CITE]．
文の種類に応じて格フレーム木を作成
従来，動詞の訳語選択を行う場合，その動詞がどういう文型で使われていても同じ格フレームを利用していた．
しかし，同じ動詞でも平叙文，疑問文，関係節，不定詞句の中では共起する格要素は異なることが予想される．
そこで文型ごとに格フレーム木の作成を行う．
コーパスに出現する格要素すべてを利用
これは著者らの使うアルゴリズムによって，どのような格要素が選択されるかを調査するためである．
格要素の制約としては，主辞の語形と機能語を利用
これらは，それぞれの統語単位を代表する成分であるため，まずこれを利用する．
学習に利用したプログラムはC4.5(オプションなし，枝刈りなし)である．
各動詞の各文型パターンについて格フレーム木の作成実験を行った．
訳し分けの対象にしたのは各動詞とも，頻度が10以上である．
これは頻度が小さいと有効なデータとならないからである．
表3に，入力とした原始格フレーム表の諸元と結果の一覧を示す．
ここでは，平叙文のデータから作成した格フレーム木の結果のみを示した．
また図5に獲得された``take''の格フレーム木の一部を示す．
この図では左がルートノードである．
また各行の右端の数字は，学習に利用した事例を格フレーム木で分類した場合に(そのリーフに分類された事例数/事例とリーフの訳語が一致しなかった数[あれば])である．
以下に結果の特徴を記す．
通常の辞書との類似
図5に示すように，格フレーム木は直感的に理解しやすいものであった．
これは，格フレーム木に使われた格要素の多くが，通常の辞書に使われていたことによる．
例えば``take''の格フレーム木では，AX (助動詞相当語句)，D (副詞小詞)，ON (直接目的語名詞句)，SIN (主語の不定詞句)，SN (主語名詞句)が使われていた．
この中の，SN，ON，Dは通常の冊子辞書でも頻繁に使われている．
さらにこの場合，ルートノード，すなわち訳し分けに最も有効な格要素はDとなっていた．
冊子辞書でも副詞小詞は重要な要素と見なされており，動詞と組み合わせて別項として記述されていることが多い．
同様の特徴はその他の動詞にも見られた．
表3の第2行と第4行を比べると，入力に与えられた格要素の内，実際に格フレーム木で利用された格要素は少ないことがわかる．
また，利用された格要素の多くは冊子辞書でもよく利用されるものであった．
それぞれの動詞の格フレーム木に利用された格要素を付録Cの表8に示す．
訳し分けの精度
得られた格フレーム木は，直観では気付きにくい情報を学習していた．
図5のAに示した部分では，ONが何もないときの訳語は「かかる」と学習されている．
``take''は通常他動詞として用いられるため，目的語がないというのは不自然な印象を受ける．
しかし，対訳コーパスを調査してみると``take awhile'', ``take long''といった時間表現があることがわかった．
これらの表現では，目的語ではなく副詞を伴って「かかる」の意味になっており，妥当な学習と言える．
また図5のBで示した部分では，``take part''で「参加する」と学習されており，``in''は冗長だとされている．
これは通常の辞書の記述とは異なっている．
しかし，これも対訳コーパス中に実際に``in''を伴わない用法が見つかり，むしろ望ましい学習と言える．
このように格フレーム木の細部を見た場合には，コーパスの動詞を訳し分けるのに適した情報が学習されていた．
また，表3の第5行目には誤訳率を記している．
これは，学習に利用した事例を格フレーム木で分類した場合に，誤った訳語が出力された割合である．
学習データであっても誤訳率がゼロにならない理由は，
格フレーム木を作成するアルゴリズムが，過剰学習を避けるため多少の誤訳を許すように設定されていること(付録A，脚注10, 11参照)
1文の範囲では訳し分けができない場合があることである．
以下具体的に説明する．
(I)に該当する例は図5のCの部分に見られる．
ここでは``take hour'' (11例)は「かかる」と訳すように学習されたが，3例は誤っている．
これらは「必要とする」と訳されなくてはならない．
原始格フレーム表を調べてみると，``take hour''の11事例の主語はすべて異なっていた．
そこで，このノードの下をさらに主語で分岐すると上記の2つの訳語は正しく分類することができる．
ただしこの場合，主語の語形によって11の枝が生成され，リーフには1事例しか分類されない．
このためこれは予測力の低い過剰学習であると判定され，このような分岐は実行されない．
(II)に相当するのは同一の文でありながら動詞の訳が違う場合である．
``make''のコーパスには``I am going to make it.''という同一の文章で``make''の訳語が「作る」と「成功する」になる2通りの場合が収録されている．
これらの訳語はこの文の格要素だけで訳し分けることはできないため，誤りを含んだまま枝の生成は停止せざるを得ない．
この誤りは文脈を扱わない本手法の限界を示すものである．
補償的な学習
図5のDでは``take place''が「獲得する」と「行われる」に訳し分けられている．
前者は``take third place''「3位を獲得する」というコーパスの例文から学習されており，後者は成句表現を学習したものである．
前者は通常の辞書には記述されていない．
ここで興味深いのは学習された訳し分けの条件である．
ここでは主語の性質によって訳し分けられている．
すなわち，主語が「人間」の時は「獲得する」となり，「動作名詞」の時は「行われる」となっている．
これは言語学的に納得できる条件である．
しかし，この訳し分けは``place''の前の修飾語の有無で行うことも可能である．
前者は``third''という修飾を受けているが，後者は成句表現であるため，修飾は基本的に受けないからである．
この実験の原始格フレーム表には修飾語を利用していないため，このような学習は起こりえない．
そこで，これに替わる条件を学習しているのである．
このような学習を本論文では「補償的な学習」と呼ぶ．
この「補償的な学習」は，その他の格フレーム木でも数多く見られた．
例えば図6 (``come''の格フレーム木の一部)では，主語が``it''の場合に，その内容を参照することなく，前置詞を条件として動詞の訳し分けが行われている．
また，この条件で事例の分類を行った結果，15事例の内12事例で訳語が正しく選択されている．
補償的な学習は，与えられた情報の中で最適な訳し分け条件を見つけ出すアルゴリズムの性質を反映したものであり，ここで述べたように人手で見つけにくい有効な格要素を発見する上で有用である．
しかし，この性質は格フレーム木のノードとして本来使うべき格要素を選ばずに，たまたま原始格フレーム表の訳語をきれいに分類する格要素を選択することにつながる場合もある．
このため，必ずしも言語学的な直観にあわない格要素が格フレーム木に含まれる場合もあり，その正しさは人間が判定する必要がある．
文型による格フレーム木の違い
平叙文に比べてその他の文型の事例数が少ないため同列の比較はできないが，文型による格フレーム木の違いはかなり顕著であった．
例えば比較的事例数の多かった「to不定詞として用いられた``take''と``make''」の格フレーム木に使われた格要素はON (直接目的語名詞句)だけであった．
また，これらの格フレーム木には平叙文で重要であったD (副詞小詞)は出現しなかった．
これらのことは，格フレーム木は文型に合わせて作成する必要があることを示唆している．
本章では，語形を利用した格フレーム木の学習を行った結果，大局的には人間の直観に近い，わかりやすい格フレーム木が獲得された．
また，細かく見ると人手で獲得するよりも精密な条件が抽出される場合や，人手では気がつきにくい条件が抽出されることがわかった．
ここで問題になるのは格フレーム木の一般性である．
本手法では，格要素の制約として語形を使ったため，未学習の事例の動詞を訳し分ける性能には疑問がある．
なぜなら，未学習の事例を格フレーム木のルートからリーフへ照合する過程で，制約(アークのラベル)が未知の語形になり，格フレーム木をたどれなくなるからである．
そこで，次章ではこの問題を解決する手法を提案して実験を行う[CITE]．

著者らが利用している学習プログラムでは，事例と格フレーム木との照合中に，あるノードで行き詰まった場合には訳語を予測して出力するようになっている．
このプログラムでは格フレーム木の作成と同時に各学習事例がどのリーフに分類されるかを計算しており，リーフにはその頻度が付与されるようになっている(図5の右端の数字)．
そして訳語の予測にはこの頻度を利用している．
今，図5の格フレーム木で，``D=0''かつ``ON=place''かつ``SN=war''という事例を分類しようとすると，SNの制約(war)が未知語であるため訳語が決定できない．
このように行き詰まった場合には，先に述べた頻度を利用して，そのノードの下で最も頻度の高い訳語を予測値として出力する．
今の場合，行き詰まったノードSNの下で最高の頻度であった「行われる」が出力される．
このような予測機能のおかげで未知語は表面上は問題にはならない．
しかし，この「局所的な多数決原理」のヒューリスティクスがどれだけ有効であるかは不明である．
未知語になる可能性が高いのはオープンクラスの語彙，特に名詞である．
これを軽減する手法としては，名詞を意味コードで置換することが考えられる．
これによって膨大な数の名詞を一定の分類数で押さえることができるからである．
そこで本章では，名詞を意味コードで置換した格フレーム木の獲得を行い，これが未学習の事例の動詞の訳し分けにどの程度有効かを評価する．
語形の代わりに意味コードを利用した格フレーム木を獲得するには，原始格フレーム表の語形を意味コードで置き換えて学習すればよい．
これには英語の語形がどの意味で使われたかを決定する必要があるが，意味的な曖昧性があるため，英語の語形だけを見たのでは自動的には決定できない．
そこで対訳コーパスに意味コードを付与して，これを原始格フレーム表に変換することにした．
対訳コーパスには日本語の訳語があり，これが英語の語形の意味を表しているため，比較的容易に英語の語形の意味を決定できるからである．
本論文で利用した意味コードは類語国語辞典[CITE]のコードである．
これは，基本的には3桁の10進分類であり，補助的に4桁目が利用されている．
4桁すべてを利用すると2,794個の分類となる．
意味コードを付与したのは名詞を主辞に取る格要素である: SN (主語名詞句), ON (直接目的語名詞句), CN (補語名詞句), QN (間接目的語名詞句), PNc (前置詞句本体)．
意味コードの付与は，あらかじめ作成してあるテーブル，(英単語，日本語訳語，意味コード[，意味コード])の形式，を利用して半自動的に行った[CITE]．
具体的には対訳コーパスの英語と日本語の対応する格要素の主辞をこのテーブルで参照してコードを付与した．
意味コードが自動的に付与できない場合には，人手で付与できるものは付与し，それでもわからない名詞については不明を意味するコードを付与した．
これはほとんど固有名詞で，人名，地名の判別ができない単語であった．
図7のCODE行に意味コードを付与したデータを示す．
この図では2桁の意味コードを与えているが，任意の桁の意味コードを付与できる．
5章の実験で用いた平叙文のコーパスに対して，表4に示す5つの実験を行った．
原始格フレーム表に記述する格要素は5章と同じく，コーパスに現われたすべての格要素である．
これらの実験の違いは，格要素に与えた制約である．
実験1では，制約として語形を与えた．
この実験は評価方法を除けば5章の実験と基本的に同じである．
実験2--5は，意味コードの粗さと動詞の訳し分けの精度の関係を調べることを目的とし，4桁から1桁の意味コードを制約として与えた．
実験に用いたデータの諸元を表5に記す．
この表の第3行の基準誤訳率とは，各動詞での最高頻度の訳語を入力に関わらず出力した場合に発生する誤訳率である．
``take''は訳語の分布が平坦であるため，高い基準誤訳率になっている．
また第4行には基準誤訳率を与える訳語を記した．
格フレーム木の評価は，学習に利用した事例を入力した場合と，学習に利用していない事例を入力した場合の誤訳率で行った．
誤訳率は，事例と学習プログラム出力の訳語が一致しなかったものの相対頻度である．
このとき，誤訳率の精度を確保するために原始格フレーム表の事例を5分割してクロスバリデーション法で評価した．
この手法では，評価データでの誤訳率の計算は以下のように行われる．
原始格フレーム表を5つに分割して80%の事例で格フレーム木を学習する．
残りの20%の事例をこの格フレーム木で分類し，誤訳率を計算する．
この操作を5回，データをシフトしながら行い，訳語の平均誤訳率を算出する．
学習データ上での誤訳率も同様に算出した．
(以下，誤訳率は平均誤訳率のことである)格フレーム木の獲得に用いたプログラムは5章と同じC4.5 (オプションなし，枝刈りなし)である．
実験1--5の学習データ，評価データでの誤訳率を図8に示す．
このデータから次の特徴が読み取れる．
実験1:殆どの動詞で評価データでの誤訳率は最大である．
実験1--5:学習データ，評価データの誤訳率ともほぼ下に凸の曲線を描いた．
極小値を与える分類コードの桁数は動詞によって異なった．
いずれの実験でも，評価データ上の誤訳率は基準誤訳率より低い．
実験で得られた意味コード(2桁)付きの格フレーム木を図9に示す．
本章の実験によって，殆どの動詞で意味コードを抽象化すると評価データ上での誤訳率が一旦減少し，また上昇することが確認された．
この理由は，意味コードを利用すれば未知語が減るものの，意味コードが粗くなりすぎると格フレーム木の分類能力が低下するためだと思われる．
意味コードが有効に働いたのは，図9のAで示すような，事例が集中して，かつ訳語が正しく決定された部分である(意味分類コード34は「陳述」を表す)．
また，最小の誤訳率を与える意味コードの粒度は動詞によって異なっていた．
従来，固定的な意味コードを格フレームに与える場合が多かったが，そこには再考の余地があることをこの結果は示唆している．
付録Cの表9に格フレーム木に採用された格要素を記した．
5章の実験と同じように，多くの格要素は冊子辞書に利用されているものであり，得られた格フレーム木は言語学的な直観に合うものであった．
本実験での各動詞の評価データ上での最小の誤訳率は2.4%から32.2%となった．
これと基準誤訳率の差は13.6%から55.3%となり，かなりの改善が得られている．
すべての動詞で十分な精度が得られたわけではないが，``take''のように基準誤訳率が82.8%もあるような動詞に対して誤訳率27.5%が得られたことは，本手法の基本的な有効性を示したものと考えられる．
