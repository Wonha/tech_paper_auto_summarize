対訳文，特に原言語を翻訳して対訳を作成した場合，別語族の言語であっても同じ種類の句に翻訳されることが多いと考えられる．
たとえば，動詞句``arrive in New York''は，日本語も「ニューヨークに着く」という動詞句に翻訳される場合が多い．
このような性質を踏まえ，我々は「対訳文の連続領域が同じ情報を持ち，かつ句の種類が同じであれば，それは同等な句と見なせる」と仮定する．
これを処理可能な表現で置き換える必要があるため，ここでは，
「同じ情報を持つ」→「2文間で，対応づけられている単語に過不足がない」
「句の種類が同じ」→「構文カテゴリが同じ」
と解釈することとする．
上記2条件を満たす句を抽出するには，以下の処理手順となる(図[REF_fig-proc])．
\labelwidth=25pt
まず，日本語文，英語文ともに形態素解析，構文解析を行う．
次に，単語アライメントを行い，文間の単語レベルの対応をとる．
ここでは，[MATH]個の単語対(これを単語リンクと呼び，[MATH]と表現する)が抽出されたとする．
単語アライメント方法は，特に統計ベースの方法が多数提案されているため，その方式については本稿では特に議論しない．
次に，単語リンクのうち，[MATH]個のリンク([MATH])を選択し，それらをすべて含み，それ以外をまったく含まない構文解析木のノードをすべて取得する．
入力文1のノードと入力文2のノードを比較し，構文カテゴリが同じである場合，それを同等な句と見なす．
ただし，文または助動詞を含んだ動詞句が複数取得された場合は最大範囲を示すものを，それ以外の場合で同じ種類の句が複数取得された場合は最小範囲を示すものを取得する．
処理[REF_num-get-node], [REF_num-combination]を，すべての単語リンクの組み合わせについて試験する．
たとえば，英語``I have just arrived in New York.''と，その日本語訳「{ニューヨークに着いたばかりです．
}」があったとする．
単語リンクが[MATH], [MATH]の2つあり，構文木が図[REF_fig-example1]のようであったとすると，以下のとおり句の対応が取られる．
\labelwidth=25pt
葉に[MATH]のみを含む(つまり，[MATH]を含まない)英語構文木上のノードと，日本語構文木のノードを比較し，同じ種類のノードがある場合，それを同等句とする．
この例では，NP(1)同士，VMP(2)同士のノードがそれに該当する．
同様に，葉に[MATH]のみを含む英語ノードと日本語ノードを比較し，同じ種類のノードを同等句とする．
この例では，VP(3)同士のノードがそれに該当する．
次に，[MATH]と[MATH]の両方を含むノードを比較し，同じ種類のノードを同等句とする．
この例では，VP(4)同士，AUXVP(5)同士，S(6)同士が該当する．
従って，最終的に表[REF_tbl-alignment-result]に示す6つの同等句が得られる．
本例は，2つの単語リンクが存在する場合であるが，3単語の場合はリンク1を含みリンク2，3を含まない句，リンク1，2を含みリンク3を含まない句，リンク1，2，3をすべて含む句のように，組み合わせ的に句を取得する．
これにより，同等句が階層的に得られる．
なお，英語と日本語では，当然，構文カテゴリは異なるが，今回は両者の構文カテゴリを言語共通と考えられる表[REF_tab-phrase-type]に示すような7種類に分類した．
このような抽象化を行うことにより，異なる言語の構文カテゴリの比較が可能となる．
言語が異なると，単語同士が１対１に対応できたとしても，品詞が異なることも多い．
そのような句を構文カテゴリによる制約なしで対応づけると，不自然に短い単位となり，対訳として不適切になると考えられる．
しかし，本稿で述べる方式では，句の種類が同じもののみを同等句として取得するため，同等句が不自然に短くならない．
たとえば，英語``Business class is fully booked.''と日本語「{ビジネスクラスは予約で一杯です}」から同等句を抽出することを考える(図[REF_fig-example2])．
単語アライメントで[MATH], [MATH]の単語リンクが得られたとしても，どちらか一方の単語リンクのみを含んで構文カテゴリが同じノードはない．
しかし，両者を同時に含み，同じ構文カテゴリを持つノードとしてはVP(2)があるので，``be fully booked''と「{予約で一杯です}」が同等句として最初に抽出される．
意訳の例を図[REF_fig-example3]に示す．
この例では，英語``fly''を日本語「{飛行機で行く}」と訳しているため，両者は単語アライメントで対応づけられていないにも関わらず，最終的な出力では英語``fly to New York tomorrow''と日本語「{ニューヨークに明日飛行機で行く}」が対応づけられている．
つまり，間接的に``fly''と``{飛行機で行く}''が対応づけられる．
このように，本方式では，単語アライメントで対応が取れないような意味的な翻訳がされた句(言い換えると，単語の直訳でない句)もある程度対応づけることができる．
単語リンク不足のときの句アライメントについては，[REF_sec-wa-accuracy]で詳細を述べる．
[REF_sec-phrase-alignment]章で述べた方法は，構文解析結果が一意に決まったと仮定している．
しかし，構文解析結果を一意に決定した後に句アライメント処理を行うと，句アライメント結果が構文解析結果に直接影響される．
たとえば，構文解析器が解析出来ない文は，句アライメント処理を行えない．
また，誤った構文解析結果を元に句アライメント処理を行えば，句アライメント結果も誤る可能性が高い．
構文解析エラーは大きく以下の2種類に分類することができる．
\itemsep=0mm
曖昧性の問題
構文解析結果の候補が複数あり，それを選択ミスする場合．
この場合，構文解析結果が誤ったものになる．
解析木作成失敗
文法(書き換え規則)が不足しており，文全体をカバーする解析木の作成に失敗する場合．
この場合は通常，構文解析器からの出力がない．
このうち，曖昧性は単言語の構文解析では必ず発生する問題である．
一方，解析木作成失敗は，稠密な文法を用意すれば解決可能である．
しかし，対話翻訳をターゲットにする場合，文法的な崩れの多い話し言葉を扱わなければならないという問題がある．
また，機械翻訳のように複数の言語を扱う場合，言語によってツール・コーパス等の整備状況が異なっているため，すべての言語において失敗のない構文解析器を用意できる可能性は低い．
もし，用意できない場合は文法を人手で作成するしかなく，解析木作成失敗は必ず起こりうる問題となる．
本提案方式では，以下の特徴および手法を利用して句アライメント処理と構文解析を融合させることにより，曖昧性の問題，解析木作成失敗の解決を図る．
個々の言語の構文解析で発生した曖昧性は，2言語を対応づけることにより，ある程度解消することができる．
これは2言語間の構造の類似性を利用するものである[CITE]．
たとえば，英語におけるPPアタッチメントの曖昧性は，対応する日本語の構造が一意に決まると解消することができる．
図[REF_fig-pp]での`for breakfast'は，点線の構文木のように`need'と組み合わさってVPを形成することもできるし，実線の構文木のように`room service'と組み合わせてNPを形成することもできる．
しかし，日本語の構造を解析すると，`{朝食}'は`{ルームサービス}'とともにNPを形成しているため，英語についても同様に，``room service for breakfast''で名詞句を構成していると考えるのが妥当である．
この現象は，言語によって曖昧性が発生しやすい条件が異なっているため，それら条件のANDを求めることにより，曖昧性を解消できる場合があることを示している．
このように，2言語の構造が類似した時に高いスコアを出す評価関数を設定することにより，曖昧性を評価・解消することができる．
今回は，英語，日本語の全ノード(非終端記号)について，対応づけを行い，その対応づけられたノード数と単語リンク数の和を評価値として，最大スコアを持つ構造を採用することとした．
これを本稿では，句対応スコアと呼ぶ．
図[REF_fig-pp]では，実線の構造では(1)NMP, (2)NP, (3)VP同士が同等句と判定されるが，点線の構造では，同じ範囲の同等句はVP(1)のみである．
したがって，実線の構造の句対応スコアは2だけ大きくなり，こちらの構造が採用される．
なお，今回は単語アライメントの結果は一意に決定しているが，もし，たとえば同じ単語が複数回出現するなど，単語アライメント結果自体に曖昧性がある場合も，句対応スコアが最大となる単語リンクの組み合わせを探索することにより，上記評価尺度である程度解消することができる．
本稿で述べる句アライメントは，構文解析器としてチャートパーザを用いている．
このパーザは，文法(書き換え規則)が不足して，解析木の作成に失敗する場合，通常何も出力することはないが，パーサ内のアジェンダに部分解析結果を残している．
つまり，部分的ではあるが，正しい句の候補がアジェンダ内にあるということである．
これらを適切に組み合わせて用いることができれば，文法不足による解析失敗に対応できる．
この方法は，特に文法的な崩れが多い話し言葉で有効である[CITE]．
組み合わせを行う際は，その部分木が適切かどうか検査する必要があるが，その評価基準に[REF_sec-disambiguation]節で述べた句対応スコアが利用できる．
もちろん，解析が成功した場合(すなわち，文全体が1つの木で表現できた場合)は，その解析結果を優先しなければならないため，トータルの部分木数が少ない組み合わせを優先するよう，[REF_sec-disambiguation]節の評価尺度を修正した．
最終的な評価尺度は以下のとおりとなる．
\labelwidth=25pt
2つの入力文の句を比較し，句対応スコアが最大の句を対応する候補として取り出す．
文全体について，句の対応ノード数の総和をとり，最大となる句の列を解析結果として採用する
同点の句列が複数存在する場合は，句の数が最小のものを解析結果とする．
しかし，すべての部分解析結果の組み合わせを試した場合，組み合わせ数は指数的に増大する．
この問題を回避するため，今回，形態素解析で使われている2パスの探索手法である前向きDP後ろ向き[MATH]アルゴリズム[CITE]を使用した．
本探索手法を用いた部分解析結果組み合わせ法について説明する．
(図[REF_fig-search]．
説明上，片言語の句のみを示す)．
なお，ここで各部分木の句対応スコアは予め算出されているものとする．
まず，片言語(ここでは英語とする)のすべての部分木をラティス構造に配置する．
前向き探索時には，動的計画法を用いて始点からエッジ[MATH]までの句対応スコアの最大値を算出する．
これを便宜上見積スコアと呼ぶ．
この時，どの経路を通過したかは記録しない．
見積スコアは，始点からエッジ[MATH]まで，このスコアで至る組み合わせが存在することを示している．
次に後ろ向き探索では，[MATH]探索を用いて最適な組み合わせを探索する．
このとき，[MATH]アルゴリズムのヒューリスティック関数値として，見積スコアを用いる．
見積スコアは最も精度のよいヒューリスティック関数値であるので，無駄な経路をほとんど展開することなく，最適経路を探索する．
このように，本探索手法を用いると，ビーム探索のように枝刈りをする必要がなく，形態素数にほぼ比例した時間で最適な英語句の列を得ることができ，それに対応する日本語句の列も得られる．
しかし，１つの英語句に対応する日本語句は複数の候補があるため，一部，日本語句同士が重なる場合がある．
そのため，後ろ向き探索の経路展開時に日本語句列の範囲をチェックし，重なりがある経路を展開しないという処理が必要となる．
その場合，展開中の経路が無効になる可能性があるが，[MATH]探索は，展開中経路が無効となっても，次点の経路を展開するため，探索結果は，句対応スコアの総和が最大で，かつ日本語句の列に重なりがない最適解となる．
機能語は様相，法などを表しているため，文の表現のバラエティを表すことが多い．
これを無視してむやみに句の対応をとると，意味的には問題がないが，表現上，対訳として不適切なものが同等句として抽出されることがある．
特に，日本語では，時制などまでが機能語で表されるため，これを扱うことは重要である．
たとえば，図[REF_fig-func-word]の例では，[MATH]の対応がない場合，[MATH]のみを使って，``three''と``{三時以降}''というNP(1)を対応づけてしまう．
しかし，[MATH]がある場合，NP(1)ノードは単語リンクに過不足があるため，対応づけられない．
このように，機能語間，または機能語--内容語間対応を追加して，[REF_sec-phrase-alignment]章で述べた条件[REF_cond-same-information]の制約を強くすることにより，誤った同等句を抽出しにくくなり，精度を向上させることができる．
現在のところ，単語アライメントの適合率，再現率共に100%の方式は提案されていない．
すると，本方式を実際に用いる場合は，単語アライメント誤り，または不足が含まれていると考えるのが妥当である．
では，本方式にとっては，適合率と再現率のどちらが重要であるのか？
単語アライメントの適合率が低下すると言うことは（再現率を100%に保っていると仮定すると），不要な単語リンクが含まれているということである．
[REF_sec-func-word]節でも述べたが，本方式は単語リンクが増加すると，条件[REF_cond-same-information]の制約が強くなり，抽出されるべき同等句が抽出されなくなる．
しかし，これはあくまで制約が強くなっているため，誤った同等句の抽出は起こりにくい．
一方，単語アライメントの再現率が低下した場合（言い換えると，本来あるべき単語リンクが不足した場合）は，条件[REF_cond-same-information]の制約が緩くなる．
そのため，[REF_sec-disambiguation]節で述べたPPアタッチメントの曖昧性解消や，動詞の有効範囲に曖昧性が生じるため，誤った同等句を抽出しやすくなる．
このように，本方式に適合する単語アライメントは，再現率を重視したもの，言い換えると，少々不要な単語リンクが含まれていても，必要な単語リンクがほとんど含まれているものであることが望ましい．
対訳文，特に原言語を翻訳して対訳を作成した場合，別語族の言語であっても同じ種類の句に翻訳されることが多いと考えられる．
たとえば，動詞句``arrive in New York''は，日本語も「ニューヨークに着く」という動詞句に翻訳される場合が多い．
このような性質を踏まえ，我々は「対訳文の連続領域が同じ情報を持ち，かつ句の種類が同じであれば，それは同等な句と見なせる」と仮定する．
これを処理可能な表現で置き換える必要があるため，ここでは，
「同じ情報を持つ」→「2文間で，対応づけられている単語に過不足がない」
「句の種類が同じ」→「構文カテゴリが同じ」
と解釈することとする．
上記2条件を満たす句を抽出するには，以下の処理手順となる(図[REF_fig-proc])．
\labelwidth=25pt
まず，日本語文，英語文ともに形態素解析，構文解析を行う．
次に，単語アライメントを行い，文間の単語レベルの対応をとる．
ここでは，[MATH]個の単語対(これを単語リンクと呼び，[MATH]と表現する)が抽出されたとする．
単語アライメント方法は，特に統計ベースの方法が多数提案されているため，その方式については本稿では特に議論しない．
次に，単語リンクのうち，[MATH]個のリンク([MATH])を選択し，それらをすべて含み，それ以外をまったく含まない構文解析木のノードをすべて取得する．
入力文1のノードと入力文2のノードを比較し，構文カテゴリが同じである場合，それを同等な句と見なす．
ただし，文または助動詞を含んだ動詞句が複数取得された場合は最大範囲を示すものを，それ以外の場合で同じ種類の句が複数取得された場合は最小範囲を示すものを取得する．
処理[REF_num-get-node], [REF_num-combination]を，すべての単語リンクの組み合わせについて試験する．
たとえば，英語``I have just arrived in New York.''と，その日本語訳「{ニューヨークに着いたばかりです．
}」があったとする．
単語リンクが[MATH], [MATH]の2つあり，構文木が図[REF_fig-example1]のようであったとすると，以下のとおり句の対応が取られる．
\labelwidth=25pt
葉に[MATH]のみを含む(つまり，[MATH]を含まない)英語構文木上のノードと，日本語構文木のノードを比較し，同じ種類のノードがある場合，それを同等句とする．
この例では，NP(1)同士，VMP(2)同士のノードがそれに該当する．
同様に，葉に[MATH]のみを含む英語ノードと日本語ノードを比較し，同じ種類のノードを同等句とする．
この例では，VP(3)同士のノードがそれに該当する．
次に，[MATH]と[MATH]の両方を含むノードを比較し，同じ種類のノードを同等句とする．
この例では，VP(4)同士，AUXVP(5)同士，S(6)同士が該当する．
従って，最終的に表[REF_tbl-alignment-result]に示す6つの同等句が得られる．
本例は，2つの単語リンクが存在する場合であるが，3単語の場合はリンク1を含みリンク2，3を含まない句，リンク1，2を含みリンク3を含まない句，リンク1，2，3をすべて含む句のように，組み合わせ的に句を取得する．
これにより，同等句が階層的に得られる．
なお，英語と日本語では，当然，構文カテゴリは異なるが，今回は両者の構文カテゴリを言語共通と考えられる表[REF_tab-phrase-type]に示すような7種類に分類した．
このような抽象化を行うことにより，異なる言語の構文カテゴリの比較が可能となる．
言語が異なると，単語同士が１対１に対応できたとしても，品詞が異なることも多い．
そのような句を構文カテゴリによる制約なしで対応づけると，不自然に短い単位となり，対訳として不適切になると考えられる．
しかし，本稿で述べる方式では，句の種類が同じもののみを同等句として取得するため，同等句が不自然に短くならない．
たとえば，英語``Business class is fully booked.''と日本語「{ビジネスクラスは予約で一杯です}」から同等句を抽出することを考える(図[REF_fig-example2])．
単語アライメントで[MATH], [MATH]の単語リンクが得られたとしても，どちらか一方の単語リンクのみを含んで構文カテゴリが同じノードはない．
しかし，両者を同時に含み，同じ構文カテゴリを持つノードとしてはVP(2)があるので，``be fully booked''と「{予約で一杯です}」が同等句として最初に抽出される．
意訳の例を図[REF_fig-example3]に示す．
この例では，英語``fly''を日本語「{飛行機で行く}」と訳しているため，両者は単語アライメントで対応づけられていないにも関わらず，最終的な出力では英語``fly to New York tomorrow''と日本語「{ニューヨークに明日飛行機で行く}」が対応づけられている．
つまり，間接的に``fly''と``{飛行機で行く}''が対応づけられる．
このように，本方式では，単語アライメントで対応が取れないような意味的な翻訳がされた句(言い換えると，単語の直訳でない句)もある程度対応づけることができる．
単語リンク不足のときの句アライメントについては，[REF_sec-wa-accuracy]で詳細を述べる．
[REF_sec-phrase-alignment]章で述べた方法は，構文解析結果が一意に決まったと仮定している．
しかし，構文解析結果を一意に決定した後に句アライメント処理を行うと，句アライメント結果が構文解析結果に直接影響される．
たとえば，構文解析器が解析出来ない文は，句アライメント処理を行えない．
また，誤った構文解析結果を元に句アライメント処理を行えば，句アライメント結果も誤る可能性が高い．
構文解析エラーは大きく以下の2種類に分類することができる．
\itemsep=0mm
曖昧性の問題
構文解析結果の候補が複数あり，それを選択ミスする場合．
この場合，構文解析結果が誤ったものになる．
解析木作成失敗
文法(書き換え規則)が不足しており，文全体をカバーする解析木の作成に失敗する場合．
この場合は通常，構文解析器からの出力がない．
このうち，曖昧性は単言語の構文解析では必ず発生する問題である．
一方，解析木作成失敗は，稠密な文法を用意すれば解決可能である．
しかし，対話翻訳をターゲットにする場合，文法的な崩れの多い話し言葉を扱わなければならないという問題がある．
また，機械翻訳のように複数の言語を扱う場合，言語によってツール・コーパス等の整備状況が異なっているため，すべての言語において失敗のない構文解析器を用意できる可能性は低い．
もし，用意できない場合は文法を人手で作成するしかなく，解析木作成失敗は必ず起こりうる問題となる．
本提案方式では，以下の特徴および手法を利用して句アライメント処理と構文解析を融合させることにより，曖昧性の問題，解析木作成失敗の解決を図る．
個々の言語の構文解析で発生した曖昧性は，2言語を対応づけることにより，ある程度解消することができる．
これは2言語間の構造の類似性を利用するものである[CITE]．
たとえば，英語におけるPPアタッチメントの曖昧性は，対応する日本語の構造が一意に決まると解消することができる．
図[REF_fig-pp]での`for breakfast'は，点線の構文木のように`need'と組み合わさってVPを形成することもできるし，実線の構文木のように`room service'と組み合わせてNPを形成することもできる．
しかし，日本語の構造を解析すると，`{朝食}'は`{ルームサービス}'とともにNPを形成しているため，英語についても同様に，``room service for breakfast''で名詞句を構成していると考えるのが妥当である．
この現象は，言語によって曖昧性が発生しやすい条件が異なっているため，それら条件のANDを求めることにより，曖昧性を解消できる場合があることを示している．
このように，2言語の構造が類似した時に高いスコアを出す評価関数を設定することにより，曖昧性を評価・解消することができる．
今回は，英語，日本語の全ノード(非終端記号)について，対応づけを行い，その対応づけられたノード数と単語リンク数の和を評価値として，最大スコアを持つ構造を採用することとした．
これを本稿では，句対応スコアと呼ぶ．
図[REF_fig-pp]では，実線の構造では(1)NMP, (2)NP, (3)VP同士が同等句と判定されるが，点線の構造では，同じ範囲の同等句はVP(1)のみである．
したがって，実線の構造の句対応スコアは2だけ大きくなり，こちらの構造が採用される．
なお，今回は単語アライメントの結果は一意に決定しているが，もし，たとえば同じ単語が複数回出現するなど，単語アライメント結果自体に曖昧性がある場合も，句対応スコアが最大となる単語リンクの組み合わせを探索することにより，上記評価尺度である程度解消することができる．
本稿で述べる句アライメントは，構文解析器としてチャートパーザを用いている．
このパーザは，文法(書き換え規則)が不足して，解析木の作成に失敗する場合，通常何も出力することはないが，パーサ内のアジェンダに部分解析結果を残している．
つまり，部分的ではあるが，正しい句の候補がアジェンダ内にあるということである．
これらを適切に組み合わせて用いることができれば，文法不足による解析失敗に対応できる．
この方法は，特に文法的な崩れが多い話し言葉で有効である[CITE]．
組み合わせを行う際は，その部分木が適切かどうか検査する必要があるが，その評価基準に[REF_sec-disambiguation]節で述べた句対応スコアが利用できる．
もちろん，解析が成功した場合(すなわち，文全体が1つの木で表現できた場合)は，その解析結果を優先しなければならないため，トータルの部分木数が少ない組み合わせを優先するよう，[REF_sec-disambiguation]節の評価尺度を修正した．
最終的な評価尺度は以下のとおりとなる．
\labelwidth=25pt
2つの入力文の句を比較し，句対応スコアが最大の句を対応する候補として取り出す．
文全体について，句の対応ノード数の総和をとり，最大となる句の列を解析結果として採用する
同点の句列が複数存在する場合は，句の数が最小のものを解析結果とする．
しかし，すべての部分解析結果の組み合わせを試した場合，組み合わせ数は指数的に増大する．
この問題を回避するため，今回，形態素解析で使われている2パスの探索手法である前向きDP後ろ向き[MATH]アルゴリズム[CITE]を使用した．
本探索手法を用いた部分解析結果組み合わせ法について説明する．
(図[REF_fig-search]．
説明上，片言語の句のみを示す)．
なお，ここで各部分木の句対応スコアは予め算出されているものとする．
まず，片言語(ここでは英語とする)のすべての部分木をラティス構造に配置する．
前向き探索時には，動的計画法を用いて始点からエッジ[MATH]までの句対応スコアの最大値を算出する．
これを便宜上見積スコアと呼ぶ．
この時，どの経路を通過したかは記録しない．
見積スコアは，始点からエッジ[MATH]まで，このスコアで至る組み合わせが存在することを示している．
次に後ろ向き探索では，[MATH]探索を用いて最適な組み合わせを探索する．
このとき，[MATH]アルゴリズムのヒューリスティック関数値として，見積スコアを用いる．
見積スコアは最も精度のよいヒューリスティック関数値であるので，無駄な経路をほとんど展開することなく，最適経路を探索する．
このように，本探索手法を用いると，ビーム探索のように枝刈りをする必要がなく，形態素数にほぼ比例した時間で最適な英語句の列を得ることができ，それに対応する日本語句の列も得られる．
しかし，１つの英語句に対応する日本語句は複数の候補があるため，一部，日本語句同士が重なる場合がある．
そのため，後ろ向き探索の経路展開時に日本語句列の範囲をチェックし，重なりがある経路を展開しないという処理が必要となる．
その場合，展開中の経路が無効になる可能性があるが，[MATH]探索は，展開中経路が無効となっても，次点の経路を展開するため，探索結果は，句対応スコアの総和が最大で，かつ日本語句の列に重なりがない最適解となる．
機能語は様相，法などを表しているため，文の表現のバラエティを表すことが多い．
これを無視してむやみに句の対応をとると，意味的には問題がないが，表現上，対訳として不適切なものが同等句として抽出されることがある．
特に，日本語では，時制などまでが機能語で表されるため，これを扱うことは重要である．
たとえば，図[REF_fig-func-word]の例では，[MATH]の対応がない場合，[MATH]のみを使って，``three''と``{三時以降}''というNP(1)を対応づけてしまう．
しかし，[MATH]がある場合，NP(1)ノードは単語リンクに過不足があるため，対応づけられない．
このように，機能語間，または機能語--内容語間対応を追加して，[REF_sec-phrase-alignment]章で述べた条件[REF_cond-same-information]の制約を強くすることにより，誤った同等句を抽出しにくくなり，精度を向上させることができる．
現在のところ，単語アライメントの適合率，再現率共に100%の方式は提案されていない．
すると，本方式を実際に用いる場合は，単語アライメント誤り，または不足が含まれていると考えるのが妥当である．
では，本方式にとっては，適合率と再現率のどちらが重要であるのか？
単語アライメントの適合率が低下すると言うことは（再現率を100%に保っていると仮定すると），不要な単語リンクが含まれているということである．
[REF_sec-func-word]節でも述べたが，本方式は単語リンクが増加すると，条件[REF_cond-same-information]の制約が強くなり，抽出されるべき同等句が抽出されなくなる．
しかし，これはあくまで制約が強くなっているため，誤った同等句の抽出は起こりにくい．
一方，単語アライメントの再現率が低下した場合（言い換えると，本来あるべき単語リンクが不足した場合）は，条件[REF_cond-same-information]の制約が緩くなる．
そのため，[REF_sec-disambiguation]節で述べたPPアタッチメントの曖昧性解消や，動詞の有効範囲に曖昧性が生じるため，誤った同等句を抽出しやすくなる．
このように，本方式に適合する単語アライメントは，再現率を重視したもの，言い換えると，少々不要な単語リンクが含まれていても，必要な単語リンクがほとんど含まれているものであることが望ましい．
