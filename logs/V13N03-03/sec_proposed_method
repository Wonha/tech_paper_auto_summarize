PDGは，自然言語の曖昧性・多義性の問題に焦点をあてて設計された形態素・構文・意味レベルの文解析を行うフレームワークである．
ターゲットとしている課題は，
\mygapskip
組み合わせ爆発の回避
生成・制約・選好知識の適切な扱い
多レベル知識のモジュラリティと統合
\mygapskip
である．
この課題に対して，図[REF_fig:MultilevelPSDataConnectionModel]に示す多レベルの圧縮共有データを結合した方式（多レベル圧縮共有データ結合モデル）に基づく解析方式を採用している．
各レベルは，入力文に対するそれぞれの解釈記述空間における言語解釈の全てを圧縮共有データ構造の形式で保持する．
入力文に近い側を下位，出力に近い側を上位レベルと呼ぶ．
各レベルの各解釈は上位・下位のレベルの解釈との対応が取られており(図[REF_fig:MultilevelPSDataConnectionModel]の「対応」でマークした点線)，本稿では，これを解釈リンケージと呼ぶ．
多レベル圧縮共有データ結合モデルでは，下位レベルの解釈はより上位のレベルの解釈を内包しており，入力文は，全ての解釈を内包している．
各レベルにおいて，それぞれ生成・制約・選好知識が存在する．
生成知識は，１つ下位のレベルの解釈から現在のレベルの解釈を生成（外延化）する(図[REF_fig:MultilevelPSDataConnectionModel]の[MATH]矢印)．
制約知識は，現在のレベルの解釈を制限し，選好知識は，現在のレベルの解釈の優先度を設定する．
このモデルにより，PDGは次の実現を狙っている．
句構造，依存構造等の複数のデータ構造(言語知識の記述ベース)を利用して，形態素，構文，意味の多レベルの知識をモジュール独立性良く扱う．
各レベルで圧縮共有型のデータ構造を用意し各レベルでの全曖昧性を効率良く保持することで基本的に枝刈りをしないで組合せ爆発を抑制する．
入力文から最上位レベルまでの解釈リンケージによりマルチレベルの選好知識(選好スコア)を統合し，精度向上を図る．
文解釈となる依存木を圧縮共有した選好スコア付き圧縮共有データ構造から制約と選好を組み合わせた最適解探索手法により最適解を探索する．
一般に各レベルの解釈の内で制約知識を満足する解釈を整合解釈(well-formed interpretation)と呼ぶ．
最適解釈の探索は各レベル毎に定義可能であり，各レベルの選好知識を利用して，そのレベルの最適解釈を取り出すことができる．
先に述べたように文解析の深さ，出力をどうするかはアプリケーションが基本的に規定する事項である．
例えば，同じ機械翻訳でも文の構造表現として同属言語の場合は句構造表現がよいが，語族が違うと依存構造表現が適切であったりする．
また，解釈リンケージを利用することにより，上位レベルで最適な解釈を選択し，その解釈に対応する下位レベルの解釈を下位レベルの最適解釈として取り出す方法も考えられる．
例えば，意味解析結果として最適な解釈に基づいたタガーなどが自然に実現できる．
PDGの全体モデルを図[REF_fig:PDGAnalysisModel]に示す．
語品詞トレリス，ヘッド付き統語森，機能依存森，意味依存森の４つの圧縮共有データ構造により，それぞれ，語品詞系列，構文木(句構造)，機能依存木，意味依存木の解釈の集合を保持する．
それぞれを計算する処理を形態素解析，構文解析，構造生成，意味構造化と呼ぶ．
各レベルのデータ構造の概要を図[REF_fig:PDGPackedSharedDataStructures]に示す．
PDGでは，単語に対する解釈のレベルとして単語，語品詞，語彙概念の３階層を採用し，各語に語彙情報として付与されていると想定している．
語品詞トレリスは語品詞の隣接関係の解釈を表現する語品詞系列を保持する．
ヘッド付き統語森は，後に述べるが，語や句のカテゴリの下位範疇化(あるいは系列関係)を表現する構文解析木を保持する．
句構造頻度の選好知識，数の一致などの構文的制約など記述できる．
機能依存森は語品詞間の機能依存関係を表現する機能依存木を保持し，意味依存森は語彙概念間の意味関係を表現する意味依存木を保持する．
以下では簡略のため単に依存森と表記した場合は，機能依存森を示す．
各レベルのデータ構造に対してそれぞれの選好知識により優先度を与え，これをデータ構造間の対応関係（解釈リンケージ）を通じて統合し，最終的には，最適解釈探索により最も確からしい解釈（意味依存木）が計算される[CITE]．
現在，依存森のレベルまでの処理システムが試作されており，最適解釈探索も依存森に対して行われ依存木を出力するモデルとなっている．
意味依存森レベルは今後の課題とし，以下本稿では依存森までのモデルを対象とする．
多レベル構成により他のレベルの知識を活用することが可能となる．
例えば，依存関係をベースとした単一レベル圧縮共有構造モデルであるCDGは，基本的に全てのノード間に全ての依存関係(仮説)を生成してeliminative parsingを行う．
解釈の枝刈りを行わないという優れた利点があるが生成解釈数が多く効率面で問題があり，改善手法が提案されている[CITE]．
PDGでは依存構造に対して全可能性を有する依存森を生成するが，これは下位レベルの統語森中の解釈のみから派生する依存木であり，句構造レベルの知識の活用による効率化が行える．
また，後述するが，句構造の記述体系を利用することにより，non-projectiveな依存構造を導入可能となり，依存構造としての記述能力の向上にもつながっている．
以上のようにPDGでは，多レベルの圧縮共有データ構造が重要な役割を果たしている．
以下では，PDGの共有データ構造であるヘッド付き統語森，依存森について説明してゆく．
多レベル圧縮共有データ結合モデルにおける圧縮共有データ構造には次の性質が必要である．
各レベルで組合せ爆発が起こらない
各種レベルの曖昧性を過不足なく表現できる
各レベルでの知識記述のベースとして適切である
各種レベル間の解釈リンケージが取れる
(a)は，実システムを構築する際に特に重要な課題である．
一般に解釈の組合せ展開を行うと直ぐに扱いが困難になり，また，計算時間的にも不十分となる．
(b)は，多レベルの知識を扱う場合に，各レベルの曖昧性を全て過不足なく表現できること，すなわち共有構造そのものに由来する解釈の枝刈り(あるべき解釈の欠落)や解釈の過生成(あるべきでない解釈の生成)が起こらないという性質である．
この性質を保持した上でシステム構築上有効な枝刈りを導入できることは重要な好ましい性質である．
(c)は，それぞれのレベルでの知識の記述が行いやすいこと,選好知識と制約知識が適切に扱えることであり[CITE]，(d)は各レベルの解釈の対応関係を取ることができるという性質である．
文解析を精度良く行なうためには様々な知識を利用する必要がある．
従来，文の構造を記述する代表的枠組みとして句構造と依存構造がある．
句構造は，品詞への抽象化により語や句の順序に関する知識の記述に優れており，依存構造は語の間の種々の依存関係に関する知識の記述に優れている．
それぞれの表現レベルでの制約知識・選好知識の記述を自然な形で可能とするため，PDGでは，句構造形式の共有データ構造(ヘッド付き統語森)と依存構造形式の共有データ構造(依存森)をそれぞれ関連付けて組み込んでいる．
これは句構造(C-構造)と機能構造(F-構造)という２つの構文レベルの表現を持つLFG[CITE]において，SUBJECT,OBJECTなど構文的機能に関する制約がF-構造で記述され，文法の記述性を高めているのと類似している．
なお，Early法，Chart法といった文脈自由文法の解析アルゴリズムを用いて依存文法を直接解析して依存構造を求める手法も提案されている[CITE]が，句構造を作らない点で本手法とは異なっている．
語品詞トレリスは，全ての語品詞系列を圧縮共有するデータ構造であり，PDGでもそのまま利用する．
構文レベルの解析手法としては文脈自由文法をベースにした解析が広く用いられておりPDGもこれを利用する．
文脈自由文法で入力文を解析し文の可能な解釈全体を得る手法は広く知られており，例えば，富田により，グラフスタックを用いた構文解析手法と共に文の句構造解釈(構文木)全体を効率的に保持する圧縮共有統語森(Packed Shared Parse Forest)が提案されている[CITE]．
圧縮共有統語森中の構文木は，語品詞トレリス中の語品詞系列と対応関係が取れ多レベル圧縮共有データ結合モデルとして利用可能である．
文献[CITE]は，意味係り受けグラフを提案し，係り受けの多義（構文的多義）と係り受け意味関係の多義を効率良く保持する手法を提案した．
意味係り受けグラフは，ATN文法を用いて句構造解析を行い係り受け関係を表す依存グラフを生成し，そこから意味係り受け関係を表す意味係り受けグラフを生成する．
意味係り受けグラフは，修飾語が被修飾語の左に位置する，英語などに比べ品詞多義は殆どないという日本語の特徴を前提に設計されているため，多品詞を扱えないなど英語などに適用できないという汎用性に関する問題を有しており，PDGの圧縮共有データ構造としては採用しない．
Seoは，文の句構造解釈全体と対応する依存構造全体を効率良く保持する方法として構文グラフ(Syntactic Graph)を提案した[CITE]．
構文グラフは，PDGの共有データ構造として有望であったが，大きな問題もありそのまま採用することはできないことが判明した．
構文グラフは，単語間の依存関係をベースに文の可能な解釈を圧縮共有する枠組みである．
構文グラフは，語品詞に対応するノードとノード間の依存関係を表現する名前付きアークで構成される有向グラフであり，排他マトリックス(EM:Exclusion Matrix)と呼ばれるデータと組になって，入力文に含まれる依存構造の集合（文の解釈の集合）を表現する．
構文グラフは，３次組(Triple)と呼ばれる，アーク名とその両端のノード(語品詞，表層位置などを持つ)の組からなる集合で表現される．
図[REF_fig:KoubunGraph]は，``Time flies like an arrow''に対する構文グラフ/排他マトリックスである．
アークの括弧中の番号はそのIDである．
１つのノードに入る複数のアークは修飾の曖昧性を表現している．
Sは，開始記号に相当する．
排他マトリックスは，構文グラフを構成するアークを行・列とし，アーク間の共起制約を記述するために導入されている．
排他マトリックスの[MATH]行[MATH]列が1である場合には，[MATH]番目と[MATH]番目のアークは，いかなる解釈(依存木)においても共起しない．
構文グラフ/排他マトリックスは，統語森に基づいたデータ構造から生成される．
PDGでも同じデータ構造を用いており，これをヘッド付き統語森と呼ぶ．
ヘッド付き統語森の詳細は，[REF_sec:datastructure]章で述べる．
なお，以下では，単に統語森と言った場合はヘッド付き統語森を意味し，従来の統語森はヘッド無し統語森と記述することとする．
文献[CITE]では，統語森と構文グラフ/排他マトリックス間の完全性(completeness),健全性(soundness)について言及している．
完全性は，「統語森中の１つの構文木が存在した時に，構文グラフ/排他マトリックス中にそれに対応する依存木が存在する」という性質であり，健全性は，「構文グラフ/排他マトリックス中の１つの依存木が存在した時に，統語森中にそれに対応する構文木が存在する」という性質である．
構文グラフ/排他マトリックスの完全性が成立することは示されているが，健全性については保証されていない．
排他マトリックスは，３次組の間の共起関係を規定しているが，ある１つの構文木に対応する依存木が存在した場合，その依存木に含まれる３次組の間の共起排他制約を排他マトリックスから除外するという方法で構成される．
排他マトリックスは，全ての依存構造の解釈を規定するため，この除外された共起排他制約が他の全ての解釈(依存木)において制約として必要でない場合にのみ健全性が保証されることになる．
付録１に構文グラフで健全性が破綻する例を示す．
PDGでは，前節で述べた従来手法の問題を解決するデータ保持方式として，文脈自由文法の構文構造の保存方式としてヘッド付き統語森を採用し，依存構造の保存方式として依存森を提案する．
ヘッド付き統語森は統語森の一種であり，適用された書き換え規則に対応する弧(edge)から構成され，次の条件を満足する構文木を圧縮共有する．
句の非終端記号(カテゴリ)が同じ
句の被覆する単語範囲が同じ
句ヘッドとなる主構成素(語品詞)が同じ
(a),(b)の２つがヘッド無し統語森の共有条件である[CITE]．
ヘッド付き統語森中の構文木は，統語森中の構文木と対応が取れる．
PDGにおける弧とヘッド付き統語森の具体例は構築アルゴリズムと共に[REF_sec:construction]章で述べる．
依存森は，依存グラフ(DG:Dependency Graph)と共起マトリックス(CM:Co-occurrence Matrix）より成る．
以下，依存森の構造と依存木について説明する．
図[REF_fig:IDF]は，``Time flies like an arrow''に対する依存森の例である.
依存グラフは，語品詞に対応するノードと１つのルートノードrootならびに，ノード間の依存関係を表現する名前付きアークより構成される．
依存グラフは，rootをルートノードとする有向グラフであり，実際には，アークとその両端のノードの組からなる依存片(dependency piece)の集合として表現する.
アークは，アーク名とIDを有す．
アークの元側を依存ノード(dependentあるいはmodifier)，先側を支配ノード(governorあるいはmodificand)と呼ぶ．
また，ノードには，表層位置などの情報も含まれている．
アークの数を依存森のサイズと呼ぶ．
また，依存グラフの部分集合で木構造を成すアーク集合が依存木であり，文や句の解釈を表現する．
依存グラフは複数の依存木を含む圧縮共有データ構造となっている．
共起マトリックスは，アークIDで示されたアーク集合を行と列に取り，アーク間の共起関係を規定する．
共起マトリックスCM([MATH],[MATH])が○の場合に限り，アーク[MATH]と[MATH]は１つの依存木（解釈）において共起可能であるという制約を表現する．
共起関係は双方向関係であり，CMは対称行列となる．
依存森中の依存木のうち次の整依存木条件を満たす依存木を整依存木(Well-formed Dependency Tree)と呼ぶ．
整依存木条件とは，次の３つの条件(a)〜(c)全体をいう．
表層位置が同じノードは存在しない(語品詞単一解釈条件）
入力文の単語と，入力文に対応する依存木のノードの間に1対1対応が取れる(被覆条件）
共起マトリックスにおいて共起関係が成立する(整共起条件)
(a)(b)の２つを纏めて整被覆条件と呼び，これを満たす木を整被覆木(Well-covered Dependency Tree)と呼ぶ.
また，(c)を満たす依存木を整共起依存木(Well-cooccurred Dependency Tree)と呼ぶ．
整依存木の集合が入力文に対する解釈の集合となる．
図[REF_fig:IDF]の依存森では，「時は矢のように過ぎる」，「時ハエは矢を好む」，「矢のようにハエを計れ」，「矢のようなハエを計れ」に対応する4つの整依存木が存在する．
なお，ノード１つからなる依存木(アークが存在しない)も，整依存木として扱う．
この場合のみ依存木はノード１つからなる集合となる．
複数の解釈に対するアークの共有の度合いによって，同じ依存木の集合を表すサイズの異なった複数の依存森を構成可能である．
詳細は後述するが，PDGでは，初期依存森(Initial Dependency Forest)と，それから変換して得られる縮退依存森(Reduced Dependency Forest)の2種を扱う．
それぞれ，初期依存グラフと初期共起マトリックス，ならびに，縮退依存グラフと縮退共起マトリックスよりなる．
単に依存森と呼んだ場合は，通常後者を示す．
図[REF_fig:IDF]の初期依存グラフは，図[REF_fig:KoubunGraph]の構文グラフと比較すると，``fly/n''と``time/v''の間のアーク数が異なっている．
対応する縮退依存森については後述する．
PDGでは，形態素解析，構文解析，統語森・初期依存グラフの生成，縮退依存森導出の順で解析が進む．
本稿では，形態素解析処理については省略し，構文解析以降について述べる．
PDGにおいて文法規則は，可能な句構造の定義と，句構造から依存構造へのマッピングとを規定する拡張文脈自由文法(extended CFG)で記述される．
文法規則は，次の形式をしている．
\mygapskipy/[MATH] x[MATH]/[MATH],[MATH],x[MATH]/[MATH] : [arc([MATH],[MATH],[MATH]),[MATH],arc([MATH],[MATH],[MATH])] (0[MATH],[MATH],[MATH],[MATH])
［例］vp/[MATH] v[MATH],np[MATH],pp[MATH] : [arc(obj,[MATH],[MATH]),arc(vpp,[MATH],[MATH])] \mygapskip規則は，``:''で区切られた書き換え規則部と構造構築部よりなる．
書き換え規則の左辺の``y/[MATH]''及び構成素(constituent)``x[MATH]/[MATH]''は，``構文カテゴリ/構造変数''を表す．
[MATH]は句ヘッド(phrase head)と呼ばれ，主構成素(head constituent)に相当し，規則ボディ(rule body)である``[MATH]''のいずれかと同一となる．
構造構築部は，``arc(アーク名,構造変数1,構造変数2)''という形式のアークの集合であり，構造変数には，書き換え規則部の構成要素の句ヘッドとなる語品詞が束縛される．
例は，[MATH]をヘッドとし，objアークで[MATH]が，vppアークで[MATH]が接続する依存構造を示している．
規則中の部分依存構造は，次の部分依存構造条件を満足する整部分依存構造である．
部分依存構造条件とは次の２つの条件(a),(b)全体をいう．
主構成素に対応する句ヘッド[MATH]をルートとする木構造である．
(非主構成素は，他の構成素と依存関係（アーク）を持つ)
規則ボディの構成素の句ヘッドは，部分依存構造をなす木構造の構造変数と１対１対応が取れる
例文``Time flies like an arrow''を解析するための文法規則と辞書を図[REF_fig:ExampleGrammar]に示す．
規則(R0)は，規則ヘッドをroot，規則ボディをスタートシンボル(s)とし，トップノード[root]-xを導入する特殊な規則であり，ルート規則と呼ぶ．
ルート規則は，統語森のルートとなる弧と依存森のトップノードをそれぞれ１つにするために導入している．
PDGの構文解析は，本稿では，Bottom-up Chart Parsingのアルゴリズムをベースに，依存構造の生成が可能となるよう，弧の構成やアルゴリズムを拡張することにより実現している．
Chart Parsingにおいて，弧は，始点(FP)，終点(TP)，規則ヘッド頂点(C)，既存構成素列(FCS)，残り構成素列(RCS)の５次組[MATH]FP,TP,C,FCS,RCS[MATH]から構成される．
文法規則のヘッドは，規則ヘッド頂点に，規則ボディは，既存構成素列と残り構成素列に対応し，ドット（・）で規則ボディ内の区切りを表現し，次の例のような形式で図式的に表現される．
[MATH]0,1, s [MATH] np・vp pp[MATH]
この弧は，文法規則``s [MATH] np vp pp''から生成される例であり，FP=0,TP=1, C=s, FCS=[np], RCS=[vp,pp]である．
また，入力単語に対する辞書の検索結果は，次の例のように，品詞をヘッドとし、単語をボディとする不活性弧として表現される．
[MATH]0,1, n [MATH] [time]・[MATH]
PDGの構文解析では，文法規則の部分依存構造に対する処理と複数の弧の圧縮共有処理の２点で拡張を行っている．
依存構造構築のため，通常のChart Parsingの弧に句ヘッド(PH)と部分依存構造(DS)を追加しており，模式的に示すと次のようになる．
通常の弧：[MATH]0,1, s [MATH] np・vp pp[MATH]
PDGの弧：[MATH]0,1, s/PH [MATH] np/NP・vp/PH pp/PP : DS[MATH]
[REF_sec:bunpoukisoku]節で述べたように，PHが句ヘッド(ノード)，DSが部分依存構造(アーク集合)を示す．
また，詳細は後述するが，不活性弧については圧縮共有を行うため，複数の弧を１つに纏めた圧縮弧というデータ構造を利用する．
圧縮弧は，既存構成素列(FCS)と部分依存構造(DS)の部分を，それぞれのリストに拡張したものである．
圧縮弧に対して，１つの構成素列と部分依存構造を持つ弧を単一弧と呼ぶ．
圧縮弧は，共有可能な単一弧の集合と等価である．
次にこれらの対応関係を模式的表現で例示する．
単一弧：[MATH]0,5, s/PH [MATH] np/NP vp/PH pp/PP・: DS1[MATH]
[MATH]0,5, s/PH [MATH] np/NP vp/PH・: DS2[MATH]
圧縮弧：[MATH]0,5, s/PH [MATH] [[np/NP vp/PH pp/PP], [np/NP vp/PH]]・: [DS1,DS2][MATH]
この例で，PHは句ヘッド，[np/NP vp/PH pp/PP], [np/NP vp/PH]は構成素列，DS1,DS2は部分依存構造を示している．
以下では簡便のため，圧縮弧は``E''，`` [MATH]E [MATH]''，「弧E」などで，単一弧は``e''，``[MATH]e [MATH]''，「弧e」などで示す．
曖昧でない場合や区別が必要でない場合などは単に「弧」とも記述する．
また，不活性弧は，記号の前に*をつけて表現する．
弧*Eは不活性圧縮弧，弧*eは不活性単一弧を示す．
以下で示すPDGの構文解析は，圧縮弧のデータ形式で行われる．
図[REF_fig:ArcStructure]に圧縮弧の構成を示す．
圧縮弧は8次組で構成されている．
FCSLとDSLは同じ長さのリストであり，i番目の要素を取り出した(FCS[MATH],DS[MATH])をCSDSペアと呼ぶ．
CSDSペアは，上記の単一弧に対応している．
図[REF_fig:ArcStructure]の弧E1〜*E3は，名詞句規則に対応する弧が解析が進むにつれて生成されてゆく例である．
弧*E3は，``an arrow''をnpとして解釈し，部分依存構造として{arc(det-14,[an]-det-3,[arrow]-n-4)}を持つ不活性弧(RCSが[])である．
[arrow]-n-4は，単語[arrow],品詞n,位置4のノードである．
弧*E4は，複数の解釈を持つ弧の例である．
FCSLの２要素とDSLの２要素がそれぞれ対応し，([103,169] {obj-25}])と([103,119,165] {obj-4,vpp-20})の２つのCSDSペアが存在している．
弧@E5のような，辞書引きにより生成される不活性弧は語彙弧(lexical edge)と呼ぶ．
語彙弧の部分依存構造は，ノード１つからなる集合である．
語彙弧は@をつけて@E,@eの様に表現する．
図[REF_fig:ChartAlgotithm]にPDGの構文解析アルゴリズムを示す．
基本構成は，Agendaを用いた一般的なChart Parsingアルゴリズム[CITE]であり，先頭から順次入力単語を語彙弧化してAgendaに追加処理する処理((a),(b)）とAgendaが空になるまでAgenda中の不活性弧に対して文法規則ならびにChart中の活性弧から可能な弧を生成・展開する弧の結合の処理((e),(f))より成る．
Agenda中の弧は，Chart中の弧と共有可能かどうかが判定され((c),(j))，共有可能な場合はマージされる((d))ことにより，圧縮共有が行なわれる．
基本的に一般的なアルゴリズムであり，詳細な説明は省略するが，次にPDG特有の依存構造の構築の部分について説明する．
本アルゴリズムは，弧を生成しながら弧の部分依存構造を構築する．
これは句ヘッド(ノード)と依存構造中の構造変数を束縛することで実現される．
この変数束縛は，不活性弧と文法規則から新しい弧が生成される時点((g))，ならびに，不活性弧とChart中の活性弧により新しい弧が生成される時点((h))，すなわち弧の結合が生じる時点で，bind_varにより不活性弧の句ヘッドが他方の弧の残り構成素列の先頭の構造変数に束縛されることで行なわれる．
さらに，この変数束縛により依存ノードと支配ノードの両方が束縛されたアーク(確定アークと呼ぶ)に対して，add_arcidによりユニークなアークIDが付与される((i))．
図[REF_fig:ArcStructure]の弧E2の変数$2にノード[arrow]-n-4が束縛されると弧*E3になる．
それぞれの弧は弧IDで関連付けられており，弧からその下位の弧(構成要素に対応）を順次辿れる．
図[REF_fig:ArcStructure]の弧*E3では，弧#160(弧IDが160の弧)は，``np [MATH] det,n''の規則から生成された弧であり，既存構成素列[153,156]は，弧#153が文法規則中の構成素detに，弧#156が構成素nに対応することを示している．
また，弧*E4のように複数の既存構成素列を持つ弧は，merge_csds((d))により生成される．
構文解析に成功した場合には，Chartには句ヘッドが[root]-xで文全体を被覆する不活性弧が１つ存在する．
これをルート弧(root edge)と呼ぶ．
構文解析後のChartは，活性弧，不活性弧より成る．
この集合に対して，不活性弧*Eから辿れる弧の集合をhpf(*E)と記述する．
ルート弧を*E[MATH]とした時，統語森はhpf(*E[MATH])となる．
ルート弧から到達できない不活性弧も存在するため，hpf(*E[MATH])はChart中の不活性弧全体の部分集合となる．
初期依存グラフは，統語森中のアークの集合であり，hpf(*E[MATH])と同時に求められる．
また，初期共起マトリックスも同時に求められる．
図[REF_fig:HPF_IDF_Algorithm]に統語森・初期依存森を求めるアルゴリズム,また，図[REF_fig:PDGParseForest]に，図[REF_fig:ExampleGrammar]の文法を用いて例文を構文解析した結果得られる統語森を示す．
統語森を構成する全ての弧は不活性弧であるため，残り構成素列([])は省略している．
なお，統語森の圧縮弧の数を統語森のサイズと呼ぶ．
弧の同一性において句ヘッドを考慮しているため(図[REF_fig:ChartAlgotithm](j))ヘッド付き統語森のサイズは，ヘッド無し統語森のサイズ以上となる．
図[REF_fig:HPF_IDF_Algorithm]のアルゴリズムは，try_edge,try_FCSL,try_CSの３つの関数を再帰的に呼びながら，それぞれの引数(圧縮弧，構成素列リスト，構成素列)の下位の要素(構成素列リスト，構成素列，圧縮弧）を深さ優先で重複を避けてトラバースする構成となっている((d),(h),(j))．
それぞれの関数の実行後は,その引数に対する統語森HPF，依存グラフDG，共起マトリックスCMの要素や値が追加設定されている．
try_edge(E),try_FCSL(FCSL),try_CS(CS)が返すアーク集合中のアークをそれぞれ弧E,構成素列リストFCSL,構成素列CSが支配するアークと呼ぶ．
全体に対する処理は,図[REF_fig:HPF_IDF_Algorithm]の(a)の``try_edge(ルート弧)''である.
try_edgeでは，(b)で既に実行済みか否かを判定し，実行済みの場合は，TERに記録済みのアーク集合を取り出して返す．
TERへの登録を行なうのは(g)である．
HPFに弧が追加されるのは，(c)と(e)においてである．
(f)にあるように，弧Eが支配するアークは，弧EのDSL中のアークとFCSLの支配するアークの和集合である．
try_FCSLは，複数のCSDSペアを処理し，try_CSは，その中の１つのCSを処理する．
(i)にあるように，FCSLの支配するアーク集合は，その要素であるCSが支配するアークの和集合である．
また，(k)にあるように，CSの支配するアーク集合は，その要素である圧縮弧が支配するアークの和集合である．
図[REF_fig:PDGParseForest]の弧#170を例に処理の具体例を図[REF_fig:TryEdgeFunctionExecution]に示す．
(c#)は関数の呼び出し，(r#)はその結果(支配するアーク集合)を示す．
(c1)〜(c4)は，図[REF_fig:HPF_IDF_Algorithm] (j),(d),(h)の再帰呼び出しである．
弧#103は語彙弧であるため，(c4)は(r4)の{}を返す．
(c3)の処理が終了し(r3)を得ると，(c2)の２番目のCSDSペア([103,119,165],{obj-4,vpp-20})に対する処理(c5)が行なわれる．
(c6)で再度`` try_edge (弧#103)''が実行されるが，この時は，図[REF_fig:HPF_IDF_Algorithm](b)でTERに保存された計算結果を検索して返す．
最終的に(r1)が得られる．
ここで，共起マトリックスの生成処理について説明する．
共起マトリックスは，１つの構文木に同時に含まれるアークの間に共起可能性を設定するよう，次の共起設定条件により設定される．
共起設定条件とは次の3つの条件(CM1),(CM2),(CM3)のいずれかをいう．
１つの部分依存構造DS中のアークは共起する
CSDSペア(CS,DS)において，CSが支配するアークは，DS中のアークと共起する
１つの構成素列CSが支配するアーク間には共起関係がある
これはそれぞれ図[REF_fig:HPF_IDF_Algorithm]のCM処理(1)〜(3)に対応している．
弧#170の例では，try_FCSLの処理で2番目のCSDSペア([103,119,165],{obj-4,vpp-20})に対してCM処理(1)で(CM1)すなわちset_CM({obj-4,vpp-20},{obj-4,vpp-20})が実施される．
また，CM処理(2)では，A_CSは図[REF_fig:TryEdgeFunctionExecution](r5)となり，(CM2)すなわちset_CM({obj-4,vpp-20},{pre-15,det-14})が実施される．
また，try_CS([103,119,165])の処理において，CM処理(3)により(CM3)すなわち弧#103,#119,#165が支配するアーク間の共起関係のCMへのセットが行われる．
例題に対するアルゴリズムの出力は，図[REF_fig:PDGParseForest]の統語森ならびに図[REF_fig:IDF]の初期依存森となる．
弧#181,#176,#174は，同じ非終端記号sと句の範囲(0から5)を持つが，句ヘッドとなるノードが異なるため共有されておらず，ヘッド無し統語森とは異なっている．
初期依存森には，図[REF_fig:IDF]におけるobj4とobj25のようにアークID以外は同一のアークが存在することがあり，これを同値アークと呼ぶ．
同値アークは，１つの文法規則から生成されたり，複数の文法規則から生成されたりする．
例えば，obj4とobj25は，図[REF_fig:ExampleGrammar]の(R9),(R10)の構成素列``vp np''の部分から生成されている．
(R9),(R10)は，前置詞句の有無という差はあるが，``vp np''の関係は２つの規則で同一であり，依存構造の解釈という観点から同値アークは等価であると言える．
同値性を扱うために，いくつかの定義を行う．
ID付きアークのアークIDを``?''と置換したアークを汎化アークと呼ぶ．
アークを全て汎化した依存木を汎化依存木と呼ぶ．
通常のID付きのアークからなる依存木を明示する時はID付き依存木と記述する．
また，アークXの汎化アークを?X，依存木DTの汎化依存木を?DTのように記述する．
汎化依存木が等しい２つのID付き依存木は同値であると言う．
縮退依存森は，初期依存森を縮退することで得られる．
依存森の縮退とは，依存森の健全性を保持しながら複数の同値アークを１つにマージする操作であり，結果として依存森のサイズは小さくなる．
依存グラフDG中の同値アーク[MATH],[MATH](equiv([MATH],[MATH])と記述する)に対するマージ操作を次のように定義する．
マージ操作
依存グラフDGより，[MATH]を削除して新たな依存グラフDG'を得る．
(DG'=DG[MATH])
アーク[MATH]([MATH]DG,[MATH],[MATH],CM([MATH],[MATH])=○)に対して，set_CM([MATH],[MATH])を行なうことにより共起マトリックスCMより新たな共起マトリックスCM'を得る．
マージ操作によりDG',CM'からなる新たな縮退依存森が得られる．
図[REF_fig:ArcMerge]にマージの例を共起マトリックスの形式で模式的に示す．
以下の議論で依存木の集合やアークの集合などを定義するが，マージ操作の前後の区別を示す場合には，``wrt DG,CM''あるいは``wrt DF''(wrt:with respect to)の表現を付けて示す．
例えば，以下で定義するアーク[MATH]を含む整依存木の集合dts([MATH])に対して，``dts([MATH]) wrt DG,CM''，``dts([MATH]) wrt DG',CM' ''はそれぞれマージ前と後の依存森に対する集合を示し，``dts([MATH]) wrt DG,CM=dts([MATH]) wrt DG',CM' ''は，マージの前後でdts([MATH])の値が同じことを示す．
簡便のため，以下では``wrt DG,CM''の部分は基本的に省略している．
初期依存グラフの全同値アークをマージすると構文グラフと同じ構造になり，健全性を保てなくなる．
[b]
\myfiglabelskip
依存森の縮退の定義より，依存森の健全性を保持すること，すなわち，同値アークのマージの前後で新規の汎化依存木(新規の解釈)が生成されないことが縮退の条件である．
\mygapskip\mynoindent[同値アークのマージ条件]
「同値アークX,Yのマージ前後の依存森をそれぞれDF,DF'とした時，縮退条件は，``DF中の汎化整依存木集合[MATH]DF'中の汎化整依存木集合''である．
」
この条件は，依存森DF'に新規の汎化依存木が存在しないことを検証することで検証できる．
今，DFに対してDF'に新規の汎化依存木が存在するための条件を汎化依存木の増加条件とすると，同値アークのマージ条件は，「汎化依存木の増加条件が満足されないこと」と等しい．
依存森はID付きアークより構成されているため，ID付き依存木の集合と(それから得られる)汎化依存木の集合の２つを規定している．
今，DFに対してDF'に新規のID付き依存木が存在する条件をID付き依存木の増加条件( ``DF中のID付き整依存木集合[MATH]DF'中のID付き整依存木集合'')とする．
ID付き依存木が増加しなければ汎化依存木の増加はなく，また，ID付き依存木が増加してもそれがDF中のID付き依存木と同値であれば汎化依存木の増加は起こらない．
すなわち，ID付き依存木の増加条件は汎化依存木の増加条件の必要条件である．
以下では，まず，ID付き依存木の増加条件を検証し，次に汎化依存木の増加条件を検証するという考え方で同値アークのX,Yのマージ条件を詳細化する．
新たな(ID付き)整依存木の増加は，同値アークのマージにより新たにアーク間に共起関係が許されることに起因する．
アークU,Vに対してCM(U,V)[MATH]○がCM(U,V)[MATH]○に変化することをアークペア(U,V)の許諾と呼び，次が成立する．
[アークペアの許諾と整依存木の増加] アークペア(U,V)の許諾により新たな整依存木が増加する場合，その依存木はU,Vを要素として含んでいる．
補題[REF_lem:ArcPairAndNewTree]は，もしU,Vの許諾によりUとVの両方を同時に含まない新しい依存木が生成されると仮定するとその依存木は許諾の前でも存在してしまうことになることから明らかである．
\mygapskipここで，同値アークX,Yに対してuniq,diffを次のように定義する．
uniq(X,Y)={[MATH] [MATH] CM(X,[MATH])=○,CM(Y,[MATH])[MATH]○,[MATH]DG}
diff(X,Y)={([MATH],[MATH])[MATH]uniq(X,Y),[MATH]uniq(Y,X)}
図[REF_fig:ArcMerge]の例では，uniq(X,Y)={j,n},uniq(Y,X)={k},diff(X,Y)={(j,k),(n,k)}となる．
一般に次が成立する．
[新規の整依存木の含むアーク]
同値アークX,Yのマージにより新たに整依存木が生成される場合には，その依存木は少なくとも１つの(A,B) [MATH] diff(X,Y)であるA,Bを含む．
\proof{
X,Yのマージ前後の依存森をそれぞれDF,DF'とする．
X,Yのマージで生じるアークペア(X,B[MATH])の許諾により新たな依存木DT[MATH]が得られたとすると，補題[REF_lem:ArcPairAndNewTree]より，X,B[MATH]は，DT[MATH]の要素である．
ここで，R[MATH]DT[MATH]{X,B[MATH]}とする．
U[MATH]Rを考えると，DT[MATH]は整依存木であるからCM(X,U)[MATH]○wrt DF',CM(B[MATH],U)=○wrt DF'である．
今，CM(Y,U)[MATH]○wrt DFであるアークUが存在しない,すなわちCM(Y,U)[MATH]○wrt DF,U[MATH]Rを仮定すると，DT[MATH]={Y,B[MATH]}+Rは，共起条件を満足する整依存木となる．
DT[MATH]とDT[MATH]は，同値アークX,Yが異なるだけなので，DT[MATH]は新たな依存木ではない．
よって，新たな依存木DT[MATH]には少なくとも１つCM(Y,U[MATH])[MATH]○wrt DFなるU[MATH]が存在する必要がある．
(B[MATH],U[MATH])[MATH]diff(X,Y)であるので補題が成立する．
}
補題[REF_lem:ArcsInNewTree]より，次のID付き依存木の増加条件が成立する．
[ID付き依存木の増加条件]  DG,CMにおいて同値アークX,Yに対するアークペア(A,B)[MATH]diff(X,Y)とした時，YをXにマージして得られるDG',CM'において,{X,A,B}を含むID付き整依存木NDTが存在する時，またこの時に限り，ID付き依存木は増加する．
\proof{
新規に生成される整依存木は必ず{X,A,B}を含むこと，{X,A,B}を含む整依存木は必ず新規解であることを示せばよい．
今，DG',CM'中の新たなID付き依存木をNDTとすると，補題[REF_lem:ArcsInNewTree]より，少なくとも１つのアークペア(A[MATH],B[MATH])[MATH]diff(X,Y),A[MATH]NDT,B[MATH]NDTが存在する．
また，補題[REF_lem:ArcPairAndNewTree]より，X[MATH]NDTである．
よって，新規に生成される整依存木は必ず{X,A,B}を含む．
また，(A,B)[MATH]diff(X,Y)より{X,A,B}を含むID付き整依存木はDG,CMに存在しない．
よって，{X,A,B}を含むID付き整依存木は必ず新規に生成される整依存木である．
}
以下で解の増加条件を詳細化するため，ここでいくつかの関数や記法を導入する．
\myhalfskip \fbox{
{13.7cm}
：アーク[MATH],[MATH]の依存ノードの位置が等しい
：[MATH]の共起制約を満たしながら，アーク集合[MATH]から得られるID付き整依存木の集合
：アーク[MATH]あるいは[MATH]と共起するアーク集合，{[MATH] [MATH] [MATH]=[MATH]またはCM([MATH],[MATH])=○, [MATH]}である．
: [MATH],[MATH]中の整依存木でアーク[MATH],[MATH],[MATH],[MATH]を含む整依存木の集合，すなわち，dts(co([MATH])[MATH]co([MATH])) wrt [MATH],[MATH]である．
\myhalfskip
} \myhalfskip
同値アークX,Yに対するdiff(X,Y)中のアークペア(A,B)に関するID付き依存木の増加条件の判定は，定理[REF_the:IDedDepTreeIncreaseCond]よりX,A,Bを含む整依存木がDG',CM'に存在するか探索することにより基本的に実現できる．
これをできるだけ効率的に行うため，X,A,Bに関して次の３つの場合に分けて考える．
same_position(A,B)またはsame_position(X,A)またはsame_position(X,B)が成立．
CM(A,B)[MATH]○である．
(RC1)(RC2)以外の場合．
(RC1)が成立する場合は，整依存木の整被覆条件によりアークが排他関係となりX,A,B全てを含む整依存木は存在しないと判定できる．
(RC2)の場合は，マージ後でもCM'(A,B)[MATH]○であるためDG',CM'において{X,A,B}を含む整依存木は存在しないと判定できる．
(RC3)の場合は{X,A,B}を含む整依存木が存在しない，すなわち，dts_with_arcs(X,A,B) wrt DG',CM'[MATH]{}の判定を行えば良い．
既に述べたようにID付き依存木の増加条件は汎化依存木の増加条件の必要条件である．
このため，ID付き依存木の増加条件を満たす場合，すなわち，dts_with_arcs(X,A,B) wrt DF'([MATH]New_DTsとする) [MATH]{}の場合に，NDT[MATH]New_DTsに対して，NDTが汎化依存木の増加となっている場合にのみ汎化依存木の増加が生じる．
逆に言えば，NDTがDF'に存在した場合でも，汎化依存木?NDTがDFに存在していれば，汎化依存木の増加は起こらない．
これより，ID付き依存木が増加する場合における同値アークのマージ条件は次のようになる．
\mygapskip「同値アークX,Yのマージ前後の依存森DF,DF'に対して，新規に増加するDF'中のID付き依存木DT[MATH]に対して，?DT[MATH]=?DTなるID付き整依存木DTがDFに存在する」\mygapskip
前節の依存森の縮退条件,すなわち同値アークのマージ条件に基づき依存森の縮退を行うアルゴリズムを図[REF_fig:DFReductionAlgorithm]に示す．
アルゴリズムでは，共起マトリックスを集合として表現している．
アークX,Yに対して，[MATH]X,Y[MATH]CMであれば共起関係が成立している．
以下，アルゴリズムの動作を縮退条件に照らし合わせて図[REF_fig:DFReductionAlgorithm]を参照しながら説明する．
図[REF_fig:DFReductionAlgorithm](a)で依存グラフ中にある同値アークペアX,Yを順次取り出し，diff(X,Y)中のアークペア(A,B)について，許諾を行った場合に解(汎化依存木)の増加が起こるかを(b)-(h)でチェックする．
全アークペアに対して汎化依存木の増加が起こらない場合に(i)で依存森の縮退が行なわれる．
(A,B)の許諾の可否は，ID付き依存木の増加条件の確認の後に汎化依存木の増加条件の確認を行うことで判定される．
(b)では，[REF_subsec:IDDTZoukaJuoken]節の(RC1),(RC2)の条件がチェックされ，いずれかを満たす場合は解の増加がないため，次のアークペアの確認に進む．
そうでない場合は，ID付き依存木の増加条件の確認に進む．
(c)では，YをXにマージしたDG',CM'を生成する．
新規依存木の存在チェックは，基本的に依存森に対する解の探索により行うため，できるだけ探索空間を少なくすることで効率化が図れる．
定理[REF_the:IDedDepTreeIncreaseCond]より新規のID付き依存木はX,A,Bを含むので，(d)ではco(X)[MATH]co(A)[MATH]co(B)によりX,A,B全てと共起するアーク以外を除いたアーク集合DG_XABを計算し，(e)でsearch_dtによりDG_XABに対して依存木を探索する．
依存木が得られなければ，このアークペアは同値アークのマージ条件を満たすので，次のアークペアの処理に進む．
依存木DTが得られた場合，DTはX,A,Bを含む新規のID付き依存木である．
(f)のnew_generalized_dt(DT,CM,DG)は，CM,DG中にDTの同値依存木が存在するかを探索することで，DTが汎化依存木として新規かをチェックする．
詳細な説明は省略するが，(q)においてDTの同値アークのみにアーク集合を限定することで汎化依存木の探索を実現している．
DTが汎化依存木として新規の場合は，X,Yのマージはできないため(g),(h)で同値アークX,Yに対する処理を終了し次の同値アークペアのマージにトライする．
汎化依存木として解が存在しない場合には，(i)においてX,Yのマージ，すなわち，依存森の縮退が行われる．
なお，(f)においてDTが汎化依存木として新規でない場合は，(e)においてDG_XABに対して別の解の探索が行われる．
search_dtは，入力位置Pに関して深さ優先に共起条件を満足する解を探索するアルゴリズムである．
(k)においてDG中の位置Pのノードを依存ノードとして持つアーク集合arcs_at(DG,P)から１つアークを選択するが，(m)において，P+1以降で解が見つからなければ(k)で別のアークを選択することで，全解を探索する．
最終的に縮退依存森に同値アークが残る例として付録１の``Tokyo taxi driver call center''に対するアルゴリズムの動作を示す．
例文に対する初期依存森を図[REF_fig:IDFandRDFexample](a)に示す．
初期依存森には(1,2),(5,7),(13,15),(25,26,27)の４種の同値アークが存在し，図のマトリックスでは2重線で括られたまとまりとして示されている．
図[REF_fig:DFReductionAlgorithm]のアルゴリズムに従って縮退処理が行なわれる．
最初の同値アークequiv(1,2)に対し[MATH]=1,[MATH]=2となり，diff([MATH],[MATH])は，uniq([MATH],[MATH])={5,24,25},uniq([MATH],[MATH])={14,15,27}の組合せ{(5,14),(5,15),(5,27),[MATH]}となる．
最初のアークペア(5,14)は，same_position(5,14)であるため図[REF_fig:DFReductionAlgorithm](b)において(RC1)の条件判定でスキップされ，次のアークペア(5,15)が選択される．
(5,15)の場合は，(b)の条件に確定しないため，(c)においてCM',DG'が生成される．
CM'= CM + {[MATH]1,14[MATH],[MATH]1,15[MATH],[MATH]1,27[MATH]}であり，図[REF_fig:IDFandRDFexample](b)に示す．
次に図[REF_fig:DFReductionAlgorithm](d)において[MATH]が計算される．
[MATH]1,[MATH]5,[MATH]15であり，[MATH]co(1)[MATH]co(5)[MATH]co(15) wrt DG',CM'={1,28}となる．
(e)のsearch_dtによる[MATH]に対する解探索は失敗するため，(5,15)の許諾は新規の依存木を生成しない．
さらにアークペア(5,27)のチェックへと処理が進む．
以上のようにしてdiff(1,2)の全てのアークペアに関してチェックが行われるが，いずれもが新規解を生成することなく終了し，(i)において依存森の縮退が行われ，CM'DG'が新規のCM,DGに設定される．
図[REF_fig:IDFandRDFexample](c)は，最終的に得られる縮退依存森であり，同値アーク25,26,27を持つ．
この依存森に対する縮退アルゴリズムの動作を示す．
今,[MATH]25,[MATH]26の時，uniq([MATH],[MATH])[MATH]{1,24}, uniq([MATH],[MATH])[MATH]{6,13}, diff([MATH],[MATH])[MATH]{(1,6),(1,13),(24,6),(24,23)}である．
アークペア(1,6)は(RC1)の条件を満たす．
アークペア(1,13)は，(RC1),(RC2)を満足せず，図[REF_fig:DFReductionAlgorithm](d)において[MATH]が計算される．
[MATH],[MATH],[MATH]であり，[MATH]co(25)[MATH]co(1)[MATH]co(13) wrt DG',CM'={25,1,13,5,28}となる．
[MATH]に対して(e)のsearch_dtを実行すると{25,1,13,5,28}が新規のID付き依存木として検索される．
次に(f)においてnew_generalized_dtが実行され，(q)でadd_equiv_arcsによりDT中の各アークに対する同値アークが追加されたアーク集合[MATH]が計算される．
図[REF_fig:IDFandRDFexample](c)では，25が同値アーク26,27を持つので，これらが追加され，[MATH]{25,26,27,1,13,5,28}となる．
図[REF_fig:DFReductionAlgorithm](r)のsearch_dtでは，解が計算されるが，同値アーク25,26,27のそれぞれに対して[MATH]25,13[MATH],[MATH]26,1[MATH],[MATH]27,5[MATH]がCMにおいて共起条件を満足しないためsearch_dtはfalseとなる．
この結果，(f)のnew_generalized_dtがtrue,すなわち汎化依存木として解の増加となるため，[MATH]=25,[MATH]=26のマージは行われない．
図[REF_fig:IDFandRDFexample](c)の依存森は，付録１の図[REF_fig:SynGraphBadExample]の(a)〜(c)の３つの依存構造のみを保持しており，健全性が保たれている．
縮退処理により生成される依存森は一意に決まるという訳ではなく，マージを試みる同値アークの順番により異なった結果が得られたりする．
例えば，上記の例でも，同じ３つの汎化依存木を含む複数の縮退依存森が存在する．
図[REF_fig:DFReductionAlgorithm]のアルゴリズムは最小の縮退依存森を得るという保証はなく，実際図[REF_fig:IDFandRDFexample](c)よりサイズの小さい依存森も存在する．
また，縮退アルゴリズムの計算量に関しても改善の余地がある．
最小の依存森の構成法やアルゴリズム効率化などについては今後の課題とする．
依存森は，統語森との間で完全性と健全性が成立する．
付録２に初期依存森の完全性と健全性の証明を示す．
縮退依存森は初期依存森と同じ(汎化)依存木の集合を保持しているため，統語森と(縮退)依存森に完全性と健全性が成立すると言える．
統語森中の構文木（句構造）と依存森中の依存木（依存構造）の対応関係は単純な1対1対応ではなく，1つの構文木が複数の依存木に対応したり，複数の構文木が１つの依存木に対応したりする．
言語表現の多様性（１つの意味を複数の表現で表現可能）と曖昧性（１つの表現で複数の意味を表現可能）を考えれば，こうした対応関係は自然な関係であると考えられる．
構文木と依存木の対応関係については，次章の評価実験において例文の解析結果とともに述べる．
PDGは，自然言語の曖昧性・多義性の問題に焦点をあてて設計された形態素・構文・意味レベルの文解析を行うフレームワークである．
ターゲットとしている課題は，
\mygapskip
組み合わせ爆発の回避
生成・制約・選好知識の適切な扱い
多レベル知識のモジュラリティと統合
\mygapskip
である．
この課題に対して，図[REF_fig:MultilevelPSDataConnectionModel]に示す多レベルの圧縮共有データを結合した方式（多レベル圧縮共有データ結合モデル）に基づく解析方式を採用している．
各レベルは，入力文に対するそれぞれの解釈記述空間における言語解釈の全てを圧縮共有データ構造の形式で保持する．
入力文に近い側を下位，出力に近い側を上位レベルと呼ぶ．
各レベルの各解釈は上位・下位のレベルの解釈との対応が取られており(図[REF_fig:MultilevelPSDataConnectionModel]の「対応」でマークした点線)，本稿では，これを解釈リンケージと呼ぶ．
多レベル圧縮共有データ結合モデルでは，下位レベルの解釈はより上位のレベルの解釈を内包しており，入力文は，全ての解釈を内包している．
各レベルにおいて，それぞれ生成・制約・選好知識が存在する．
生成知識は，１つ下位のレベルの解釈から現在のレベルの解釈を生成（外延化）する(図[REF_fig:MultilevelPSDataConnectionModel]の[MATH]矢印)．
制約知識は，現在のレベルの解釈を制限し，選好知識は，現在のレベルの解釈の優先度を設定する．
このモデルにより，PDGは次の実現を狙っている．
句構造，依存構造等の複数のデータ構造(言語知識の記述ベース)を利用して，形態素，構文，意味の多レベルの知識をモジュール独立性良く扱う．
各レベルで圧縮共有型のデータ構造を用意し各レベルでの全曖昧性を効率良く保持することで基本的に枝刈りをしないで組合せ爆発を抑制する．
入力文から最上位レベルまでの解釈リンケージによりマルチレベルの選好知識(選好スコア)を統合し，精度向上を図る．
文解釈となる依存木を圧縮共有した選好スコア付き圧縮共有データ構造から制約と選好を組み合わせた最適解探索手法により最適解を探索する．
一般に各レベルの解釈の内で制約知識を満足する解釈を整合解釈(well-formed interpretation)と呼ぶ．
最適解釈の探索は各レベル毎に定義可能であり，各レベルの選好知識を利用して，そのレベルの最適解釈を取り出すことができる．
先に述べたように文解析の深さ，出力をどうするかはアプリケーションが基本的に規定する事項である．
例えば，同じ機械翻訳でも文の構造表現として同属言語の場合は句構造表現がよいが，語族が違うと依存構造表現が適切であったりする．
また，解釈リンケージを利用することにより，上位レベルで最適な解釈を選択し，その解釈に対応する下位レベルの解釈を下位レベルの最適解釈として取り出す方法も考えられる．
例えば，意味解析結果として最適な解釈に基づいたタガーなどが自然に実現できる．
PDGの全体モデルを図[REF_fig:PDGAnalysisModel]に示す．
語品詞トレリス，ヘッド付き統語森，機能依存森，意味依存森の４つの圧縮共有データ構造により，それぞれ，語品詞系列，構文木(句構造)，機能依存木，意味依存木の解釈の集合を保持する．
それぞれを計算する処理を形態素解析，構文解析，構造生成，意味構造化と呼ぶ．
各レベルのデータ構造の概要を図[REF_fig:PDGPackedSharedDataStructures]に示す．
PDGでは，単語に対する解釈のレベルとして単語，語品詞，語彙概念の３階層を採用し，各語に語彙情報として付与されていると想定している．
語品詞トレリスは語品詞の隣接関係の解釈を表現する語品詞系列を保持する．
ヘッド付き統語森は，後に述べるが，語や句のカテゴリの下位範疇化(あるいは系列関係)を表現する構文解析木を保持する．
句構造頻度の選好知識，数の一致などの構文的制約など記述できる．
機能依存森は語品詞間の機能依存関係を表現する機能依存木を保持し，意味依存森は語彙概念間の意味関係を表現する意味依存木を保持する．
以下では簡略のため単に依存森と表記した場合は，機能依存森を示す．
各レベルのデータ構造に対してそれぞれの選好知識により優先度を与え，これをデータ構造間の対応関係（解釈リンケージ）を通じて統合し，最終的には，最適解釈探索により最も確からしい解釈（意味依存木）が計算される[CITE]．
現在，依存森のレベルまでの処理システムが試作されており，最適解釈探索も依存森に対して行われ依存木を出力するモデルとなっている．
意味依存森レベルは今後の課題とし，以下本稿では依存森までのモデルを対象とする．
多レベル構成により他のレベルの知識を活用することが可能となる．
例えば，依存関係をベースとした単一レベル圧縮共有構造モデルであるCDGは，基本的に全てのノード間に全ての依存関係(仮説)を生成してeliminative parsingを行う．
解釈の枝刈りを行わないという優れた利点があるが生成解釈数が多く効率面で問題があり，改善手法が提案されている[CITE]．
PDGでは依存構造に対して全可能性を有する依存森を生成するが，これは下位レベルの統語森中の解釈のみから派生する依存木であり，句構造レベルの知識の活用による効率化が行える．
また，後述するが，句構造の記述体系を利用することにより，non-projectiveな依存構造を導入可能となり，依存構造としての記述能力の向上にもつながっている．
以上のようにPDGでは，多レベルの圧縮共有データ構造が重要な役割を果たしている．
以下では，PDGの共有データ構造であるヘッド付き統語森，依存森について説明してゆく．
多レベル圧縮共有データ結合モデルにおける圧縮共有データ構造には次の性質が必要である．
各レベルで組合せ爆発が起こらない
各種レベルの曖昧性を過不足なく表現できる
各レベルでの知識記述のベースとして適切である
各種レベル間の解釈リンケージが取れる
(a)は，実システムを構築する際に特に重要な課題である．
一般に解釈の組合せ展開を行うと直ぐに扱いが困難になり，また，計算時間的にも不十分となる．
(b)は，多レベルの知識を扱う場合に，各レベルの曖昧性を全て過不足なく表現できること，すなわち共有構造そのものに由来する解釈の枝刈り(あるべき解釈の欠落)や解釈の過生成(あるべきでない解釈の生成)が起こらないという性質である．
この性質を保持した上でシステム構築上有効な枝刈りを導入できることは重要な好ましい性質である．
(c)は，それぞれのレベルでの知識の記述が行いやすいこと,選好知識と制約知識が適切に扱えることであり[CITE]，(d)は各レベルの解釈の対応関係を取ることができるという性質である．
文解析を精度良く行なうためには様々な知識を利用する必要がある．
従来，文の構造を記述する代表的枠組みとして句構造と依存構造がある．
句構造は，品詞への抽象化により語や句の順序に関する知識の記述に優れており，依存構造は語の間の種々の依存関係に関する知識の記述に優れている．
それぞれの表現レベルでの制約知識・選好知識の記述を自然な形で可能とするため，PDGでは，句構造形式の共有データ構造(ヘッド付き統語森)と依存構造形式の共有データ構造(依存森)をそれぞれ関連付けて組み込んでいる．
これは句構造(C-構造)と機能構造(F-構造)という２つの構文レベルの表現を持つLFG[CITE]において，SUBJECT,OBJECTなど構文的機能に関する制約がF-構造で記述され，文法の記述性を高めているのと類似している．
なお，Early法，Chart法といった文脈自由文法の解析アルゴリズムを用いて依存文法を直接解析して依存構造を求める手法も提案されている[CITE]が，句構造を作らない点で本手法とは異なっている．
語品詞トレリスは，全ての語品詞系列を圧縮共有するデータ構造であり，PDGでもそのまま利用する．
構文レベルの解析手法としては文脈自由文法をベースにした解析が広く用いられておりPDGもこれを利用する．
文脈自由文法で入力文を解析し文の可能な解釈全体を得る手法は広く知られており，例えば，富田により，グラフスタックを用いた構文解析手法と共に文の句構造解釈(構文木)全体を効率的に保持する圧縮共有統語森(Packed Shared Parse Forest)が提案されている[CITE]．
圧縮共有統語森中の構文木は，語品詞トレリス中の語品詞系列と対応関係が取れ多レベル圧縮共有データ結合モデルとして利用可能である．
文献[CITE]は，意味係り受けグラフを提案し，係り受けの多義（構文的多義）と係り受け意味関係の多義を効率良く保持する手法を提案した．
意味係り受けグラフは，ATN文法を用いて句構造解析を行い係り受け関係を表す依存グラフを生成し，そこから意味係り受け関係を表す意味係り受けグラフを生成する．
意味係り受けグラフは，修飾語が被修飾語の左に位置する，英語などに比べ品詞多義は殆どないという日本語の特徴を前提に設計されているため，多品詞を扱えないなど英語などに適用できないという汎用性に関する問題を有しており，PDGの圧縮共有データ構造としては採用しない．
Seoは，文の句構造解釈全体と対応する依存構造全体を効率良く保持する方法として構文グラフ(Syntactic Graph)を提案した[CITE]．
構文グラフは，PDGの共有データ構造として有望であったが，大きな問題もありそのまま採用することはできないことが判明した．
構文グラフは，単語間の依存関係をベースに文の可能な解釈を圧縮共有する枠組みである．
構文グラフは，語品詞に対応するノードとノード間の依存関係を表現する名前付きアークで構成される有向グラフであり，排他マトリックス(EM:Exclusion Matrix)と呼ばれるデータと組になって，入力文に含まれる依存構造の集合（文の解釈の集合）を表現する．
構文グラフは，３次組(Triple)と呼ばれる，アーク名とその両端のノード(語品詞，表層位置などを持つ)の組からなる集合で表現される．
図[REF_fig:KoubunGraph]は，``Time flies like an arrow''に対する構文グラフ/排他マトリックスである．
アークの括弧中の番号はそのIDである．
１つのノードに入る複数のアークは修飾の曖昧性を表現している．
Sは，開始記号に相当する．
排他マトリックスは，構文グラフを構成するアークを行・列とし，アーク間の共起制約を記述するために導入されている．
排他マトリックスの[MATH]行[MATH]列が1である場合には，[MATH]番目と[MATH]番目のアークは，いかなる解釈(依存木)においても共起しない．
構文グラフ/排他マトリックスは，統語森に基づいたデータ構造から生成される．
PDGでも同じデータ構造を用いており，これをヘッド付き統語森と呼ぶ．
ヘッド付き統語森の詳細は，[REF_sec:datastructure]章で述べる．
なお，以下では，単に統語森と言った場合はヘッド付き統語森を意味し，従来の統語森はヘッド無し統語森と記述することとする．
文献[CITE]では，統語森と構文グラフ/排他マトリックス間の完全性(completeness),健全性(soundness)について言及している．
完全性は，「統語森中の１つの構文木が存在した時に，構文グラフ/排他マトリックス中にそれに対応する依存木が存在する」という性質であり，健全性は，「構文グラフ/排他マトリックス中の１つの依存木が存在した時に，統語森中にそれに対応する構文木が存在する」という性質である．
構文グラフ/排他マトリックスの完全性が成立することは示されているが，健全性については保証されていない．
排他マトリックスは，３次組の間の共起関係を規定しているが，ある１つの構文木に対応する依存木が存在した場合，その依存木に含まれる３次組の間の共起排他制約を排他マトリックスから除外するという方法で構成される．
排他マトリックスは，全ての依存構造の解釈を規定するため，この除外された共起排他制約が他の全ての解釈(依存木)において制約として必要でない場合にのみ健全性が保証されることになる．
付録１に構文グラフで健全性が破綻する例を示す．
PDGでは，前節で述べた従来手法の問題を解決するデータ保持方式として，文脈自由文法の構文構造の保存方式としてヘッド付き統語森を採用し，依存構造の保存方式として依存森を提案する．
ヘッド付き統語森は統語森の一種であり，適用された書き換え規則に対応する弧(edge)から構成され，次の条件を満足する構文木を圧縮共有する．
句の非終端記号(カテゴリ)が同じ
句の被覆する単語範囲が同じ
句ヘッドとなる主構成素(語品詞)が同じ
(a),(b)の２つがヘッド無し統語森の共有条件である[CITE]．
ヘッド付き統語森中の構文木は，統語森中の構文木と対応が取れる．
PDGにおける弧とヘッド付き統語森の具体例は構築アルゴリズムと共に[REF_sec:construction]章で述べる．
依存森は，依存グラフ(DG:Dependency Graph)と共起マトリックス(CM:Co-occurrence Matrix）より成る．
以下，依存森の構造と依存木について説明する．
図[REF_fig:IDF]は，``Time flies like an arrow''に対する依存森の例である.
依存グラフは，語品詞に対応するノードと１つのルートノードrootならびに，ノード間の依存関係を表現する名前付きアークより構成される．
依存グラフは，rootをルートノードとする有向グラフであり，実際には，アークとその両端のノードの組からなる依存片(dependency piece)の集合として表現する.
アークは，アーク名とIDを有す．
アークの元側を依存ノード(dependentあるいはmodifier)，先側を支配ノード(governorあるいはmodificand)と呼ぶ．
また，ノードには，表層位置などの情報も含まれている．
アークの数を依存森のサイズと呼ぶ．
また，依存グラフの部分集合で木構造を成すアーク集合が依存木であり，文や句の解釈を表現する．
依存グラフは複数の依存木を含む圧縮共有データ構造となっている．
共起マトリックスは，アークIDで示されたアーク集合を行と列に取り，アーク間の共起関係を規定する．
共起マトリックスCM([MATH],[MATH])が○の場合に限り，アーク[MATH]と[MATH]は１つの依存木（解釈）において共起可能であるという制約を表現する．
共起関係は双方向関係であり，CMは対称行列となる．
依存森中の依存木のうち次の整依存木条件を満たす依存木を整依存木(Well-formed Dependency Tree)と呼ぶ．
整依存木条件とは，次の３つの条件(a)〜(c)全体をいう．
表層位置が同じノードは存在しない(語品詞単一解釈条件）
入力文の単語と，入力文に対応する依存木のノードの間に1対1対応が取れる(被覆条件）
共起マトリックスにおいて共起関係が成立する(整共起条件)
(a)(b)の２つを纏めて整被覆条件と呼び，これを満たす木を整被覆木(Well-covered Dependency Tree)と呼ぶ.
また，(c)を満たす依存木を整共起依存木(Well-cooccurred Dependency Tree)と呼ぶ．
整依存木の集合が入力文に対する解釈の集合となる．
図[REF_fig:IDF]の依存森では，「時は矢のように過ぎる」，「時ハエは矢を好む」，「矢のようにハエを計れ」，「矢のようなハエを計れ」に対応する4つの整依存木が存在する．
なお，ノード１つからなる依存木(アークが存在しない)も，整依存木として扱う．
この場合のみ依存木はノード１つからなる集合となる．
複数の解釈に対するアークの共有の度合いによって，同じ依存木の集合を表すサイズの異なった複数の依存森を構成可能である．
詳細は後述するが，PDGでは，初期依存森(Initial Dependency Forest)と，それから変換して得られる縮退依存森(Reduced Dependency Forest)の2種を扱う．
それぞれ，初期依存グラフと初期共起マトリックス，ならびに，縮退依存グラフと縮退共起マトリックスよりなる．
単に依存森と呼んだ場合は，通常後者を示す．
図[REF_fig:IDF]の初期依存グラフは，図[REF_fig:KoubunGraph]の構文グラフと比較すると，``fly/n''と``time/v''の間のアーク数が異なっている．
対応する縮退依存森については後述する．
PDGでは，形態素解析，構文解析，統語森・初期依存グラフの生成，縮退依存森導出の順で解析が進む．
本稿では，形態素解析処理については省略し，構文解析以降について述べる．
PDGにおいて文法規則は，可能な句構造の定義と，句構造から依存構造へのマッピングとを規定する拡張文脈自由文法(extended CFG)で記述される．
文法規則は，次の形式をしている．
\mygapskipy/[MATH] x[MATH]/[MATH],[MATH],x[MATH]/[MATH] : [arc([MATH],[MATH],[MATH]),[MATH],arc([MATH],[MATH],[MATH])] (0[MATH],[MATH],[MATH],[MATH])
［例］vp/[MATH] v[MATH],np[MATH],pp[MATH] : [arc(obj,[MATH],[MATH]),arc(vpp,[MATH],[MATH])] \mygapskip規則は，``:''で区切られた書き換え規則部と構造構築部よりなる．
書き換え規則の左辺の``y/[MATH]''及び構成素(constituent)``x[MATH]/[MATH]''は，``構文カテゴリ/構造変数''を表す．
[MATH]は句ヘッド(phrase head)と呼ばれ，主構成素(head constituent)に相当し，規則ボディ(rule body)である``[MATH]''のいずれかと同一となる．
構造構築部は，``arc(アーク名,構造変数1,構造変数2)''という形式のアークの集合であり，構造変数には，書き換え規則部の構成要素の句ヘッドとなる語品詞が束縛される．
例は，[MATH]をヘッドとし，objアークで[MATH]が，vppアークで[MATH]が接続する依存構造を示している．
規則中の部分依存構造は，次の部分依存構造条件を満足する整部分依存構造である．
部分依存構造条件とは次の２つの条件(a),(b)全体をいう．
主構成素に対応する句ヘッド[MATH]をルートとする木構造である．
(非主構成素は，他の構成素と依存関係（アーク）を持つ)
規則ボディの構成素の句ヘッドは，部分依存構造をなす木構造の構造変数と１対１対応が取れる
例文``Time flies like an arrow''を解析するための文法規則と辞書を図[REF_fig:ExampleGrammar]に示す．
規則(R0)は，規則ヘッドをroot，規則ボディをスタートシンボル(s)とし，トップノード[root]-xを導入する特殊な規則であり，ルート規則と呼ぶ．
ルート規則は，統語森のルートとなる弧と依存森のトップノードをそれぞれ１つにするために導入している．
PDGの構文解析は，本稿では，Bottom-up Chart Parsingのアルゴリズムをベースに，依存構造の生成が可能となるよう，弧の構成やアルゴリズムを拡張することにより実現している．
Chart Parsingにおいて，弧は，始点(FP)，終点(TP)，規則ヘッド頂点(C)，既存構成素列(FCS)，残り構成素列(RCS)の５次組[MATH]FP,TP,C,FCS,RCS[MATH]から構成される．
文法規則のヘッドは，規則ヘッド頂点に，規則ボディは，既存構成素列と残り構成素列に対応し，ドット（・）で規則ボディ内の区切りを表現し，次の例のような形式で図式的に表現される．
[MATH]0,1, s [MATH] np・vp pp[MATH]
この弧は，文法規則``s [MATH] np vp pp''から生成される例であり，FP=0,TP=1, C=s, FCS=[np], RCS=[vp,pp]である．
また，入力単語に対する辞書の検索結果は，次の例のように，品詞をヘッドとし、単語をボディとする不活性弧として表現される．
[MATH]0,1, n [MATH] [time]・[MATH]
PDGの構文解析では，文法規則の部分依存構造に対する処理と複数の弧の圧縮共有処理の２点で拡張を行っている．
依存構造構築のため，通常のChart Parsingの弧に句ヘッド(PH)と部分依存構造(DS)を追加しており，模式的に示すと次のようになる．
通常の弧：[MATH]0,1, s [MATH] np・vp pp[MATH]
PDGの弧：[MATH]0,1, s/PH [MATH] np/NP・vp/PH pp/PP : DS[MATH]
[REF_sec:bunpoukisoku]節で述べたように，PHが句ヘッド(ノード)，DSが部分依存構造(アーク集合)を示す．
また，詳細は後述するが，不活性弧については圧縮共有を行うため，複数の弧を１つに纏めた圧縮弧というデータ構造を利用する．
圧縮弧は，既存構成素列(FCS)と部分依存構造(DS)の部分を，それぞれのリストに拡張したものである．
圧縮弧に対して，１つの構成素列と部分依存構造を持つ弧を単一弧と呼ぶ．
圧縮弧は，共有可能な単一弧の集合と等価である．
次にこれらの対応関係を模式的表現で例示する．
単一弧：[MATH]0,5, s/PH [MATH] np/NP vp/PH pp/PP・: DS1[MATH]
[MATH]0,5, s/PH [MATH] np/NP vp/PH・: DS2[MATH]
圧縮弧：[MATH]0,5, s/PH [MATH] [[np/NP vp/PH pp/PP], [np/NP vp/PH]]・: [DS1,DS2][MATH]
この例で，PHは句ヘッド，[np/NP vp/PH pp/PP], [np/NP vp/PH]は構成素列，DS1,DS2は部分依存構造を示している．
以下では簡便のため，圧縮弧は``E''，`` [MATH]E [MATH]''，「弧E」などで，単一弧は``e''，``[MATH]e [MATH]''，「弧e」などで示す．
曖昧でない場合や区別が必要でない場合などは単に「弧」とも記述する．
また，不活性弧は，記号の前に*をつけて表現する．
弧*Eは不活性圧縮弧，弧*eは不活性単一弧を示す．
以下で示すPDGの構文解析は，圧縮弧のデータ形式で行われる．
図[REF_fig:ArcStructure]に圧縮弧の構成を示す．
圧縮弧は8次組で構成されている．
FCSLとDSLは同じ長さのリストであり，i番目の要素を取り出した(FCS[MATH],DS[MATH])をCSDSペアと呼ぶ．
CSDSペアは，上記の単一弧に対応している．
図[REF_fig:ArcStructure]の弧E1〜*E3は，名詞句規則に対応する弧が解析が進むにつれて生成されてゆく例である．
弧*E3は，``an arrow''をnpとして解釈し，部分依存構造として{arc(det-14,[an]-det-3,[arrow]-n-4)}を持つ不活性弧(RCSが[])である．
[arrow]-n-4は，単語[arrow],品詞n,位置4のノードである．
弧*E4は，複数の解釈を持つ弧の例である．
FCSLの２要素とDSLの２要素がそれぞれ対応し，([103,169] {obj-25}])と([103,119,165] {obj-4,vpp-20})の２つのCSDSペアが存在している．
弧@E5のような，辞書引きにより生成される不活性弧は語彙弧(lexical edge)と呼ぶ．
語彙弧の部分依存構造は，ノード１つからなる集合である．
語彙弧は@をつけて@E,@eの様に表現する．
図[REF_fig:ChartAlgotithm]にPDGの構文解析アルゴリズムを示す．
基本構成は，Agendaを用いた一般的なChart Parsingアルゴリズム[CITE]であり，先頭から順次入力単語を語彙弧化してAgendaに追加処理する処理((a),(b)）とAgendaが空になるまでAgenda中の不活性弧に対して文法規則ならびにChart中の活性弧から可能な弧を生成・展開する弧の結合の処理((e),(f))より成る．
Agenda中の弧は，Chart中の弧と共有可能かどうかが判定され((c),(j))，共有可能な場合はマージされる((d))ことにより，圧縮共有が行なわれる．
基本的に一般的なアルゴリズムであり，詳細な説明は省略するが，次にPDG特有の依存構造の構築の部分について説明する．
本アルゴリズムは，弧を生成しながら弧の部分依存構造を構築する．
これは句ヘッド(ノード)と依存構造中の構造変数を束縛することで実現される．
この変数束縛は，不活性弧と文法規則から新しい弧が生成される時点((g))，ならびに，不活性弧とChart中の活性弧により新しい弧が生成される時点((h))，すなわち弧の結合が生じる時点で，bind_varにより不活性弧の句ヘッドが他方の弧の残り構成素列の先頭の構造変数に束縛されることで行なわれる．
さらに，この変数束縛により依存ノードと支配ノードの両方が束縛されたアーク(確定アークと呼ぶ)に対して，add_arcidによりユニークなアークIDが付与される((i))．
図[REF_fig:ArcStructure]の弧E2の変数$2にノード[arrow]-n-4が束縛されると弧*E3になる．
それぞれの弧は弧IDで関連付けられており，弧からその下位の弧(構成要素に対応）を順次辿れる．
図[REF_fig:ArcStructure]の弧*E3では，弧#160(弧IDが160の弧)は，``np [MATH] det,n''の規則から生成された弧であり，既存構成素列[153,156]は，弧#153が文法規則中の構成素detに，弧#156が構成素nに対応することを示している．
また，弧*E4のように複数の既存構成素列を持つ弧は，merge_csds((d))により生成される．
構文解析に成功した場合には，Chartには句ヘッドが[root]-xで文全体を被覆する不活性弧が１つ存在する．
これをルート弧(root edge)と呼ぶ．
構文解析後のChartは，活性弧，不活性弧より成る．
この集合に対して，不活性弧*Eから辿れる弧の集合をhpf(*E)と記述する．
ルート弧を*E[MATH]とした時，統語森はhpf(*E[MATH])となる．
ルート弧から到達できない不活性弧も存在するため，hpf(*E[MATH])はChart中の不活性弧全体の部分集合となる．
初期依存グラフは，統語森中のアークの集合であり，hpf(*E[MATH])と同時に求められる．
また，初期共起マトリックスも同時に求められる．
図[REF_fig:HPF_IDF_Algorithm]に統語森・初期依存森を求めるアルゴリズム,また，図[REF_fig:PDGParseForest]に，図[REF_fig:ExampleGrammar]の文法を用いて例文を構文解析した結果得られる統語森を示す．
統語森を構成する全ての弧は不活性弧であるため，残り構成素列([])は省略している．
なお，統語森の圧縮弧の数を統語森のサイズと呼ぶ．
弧の同一性において句ヘッドを考慮しているため(図[REF_fig:ChartAlgotithm](j))ヘッド付き統語森のサイズは，ヘッド無し統語森のサイズ以上となる．
図[REF_fig:HPF_IDF_Algorithm]のアルゴリズムは，try_edge,try_FCSL,try_CSの３つの関数を再帰的に呼びながら，それぞれの引数(圧縮弧，構成素列リスト，構成素列)の下位の要素(構成素列リスト，構成素列，圧縮弧）を深さ優先で重複を避けてトラバースする構成となっている((d),(h),(j))．
それぞれの関数の実行後は,その引数に対する統語森HPF，依存グラフDG，共起マトリックスCMの要素や値が追加設定されている．
try_edge(E),try_FCSL(FCSL),try_CS(CS)が返すアーク集合中のアークをそれぞれ弧E,構成素列リストFCSL,構成素列CSが支配するアークと呼ぶ．
全体に対する処理は,図[REF_fig:HPF_IDF_Algorithm]の(a)の``try_edge(ルート弧)''である.
try_edgeでは，(b)で既に実行済みか否かを判定し，実行済みの場合は，TERに記録済みのアーク集合を取り出して返す．
TERへの登録を行なうのは(g)である．
HPFに弧が追加されるのは，(c)と(e)においてである．
(f)にあるように，弧Eが支配するアークは，弧EのDSL中のアークとFCSLの支配するアークの和集合である．
try_FCSLは，複数のCSDSペアを処理し，try_CSは，その中の１つのCSを処理する．
(i)にあるように，FCSLの支配するアーク集合は，その要素であるCSが支配するアークの和集合である．
また，(k)にあるように，CSの支配するアーク集合は，その要素である圧縮弧が支配するアークの和集合である．
図[REF_fig:PDGParseForest]の弧#170を例に処理の具体例を図[REF_fig:TryEdgeFunctionExecution]に示す．
(c#)は関数の呼び出し，(r#)はその結果(支配するアーク集合)を示す．
(c1)〜(c4)は，図[REF_fig:HPF_IDF_Algorithm] (j),(d),(h)の再帰呼び出しである．
弧#103は語彙弧であるため，(c4)は(r4)の{}を返す．
(c3)の処理が終了し(r3)を得ると，(c2)の２番目のCSDSペア([103,119,165],{obj-4,vpp-20})に対する処理(c5)が行なわれる．
(c6)で再度`` try_edge (弧#103)''が実行されるが，この時は，図[REF_fig:HPF_IDF_Algorithm](b)でTERに保存された計算結果を検索して返す．
最終的に(r1)が得られる．
ここで，共起マトリックスの生成処理について説明する．
共起マトリックスは，１つの構文木に同時に含まれるアークの間に共起可能性を設定するよう，次の共起設定条件により設定される．
共起設定条件とは次の3つの条件(CM1),(CM2),(CM3)のいずれかをいう．
１つの部分依存構造DS中のアークは共起する
CSDSペア(CS,DS)において，CSが支配するアークは，DS中のアークと共起する
１つの構成素列CSが支配するアーク間には共起関係がある
これはそれぞれ図[REF_fig:HPF_IDF_Algorithm]のCM処理(1)〜(3)に対応している．
弧#170の例では，try_FCSLの処理で2番目のCSDSペア([103,119,165],{obj-4,vpp-20})に対してCM処理(1)で(CM1)すなわちset_CM({obj-4,vpp-20},{obj-4,vpp-20})が実施される．
また，CM処理(2)では，A_CSは図[REF_fig:TryEdgeFunctionExecution](r5)となり，(CM2)すなわちset_CM({obj-4,vpp-20},{pre-15,det-14})が実施される．
また，try_CS([103,119,165])の処理において，CM処理(3)により(CM3)すなわち弧#103,#119,#165が支配するアーク間の共起関係のCMへのセットが行われる．
例題に対するアルゴリズムの出力は，図[REF_fig:PDGParseForest]の統語森ならびに図[REF_fig:IDF]の初期依存森となる．
弧#181,#176,#174は，同じ非終端記号sと句の範囲(0から5)を持つが，句ヘッドとなるノードが異なるため共有されておらず，ヘッド無し統語森とは異なっている．
初期依存森には，図[REF_fig:IDF]におけるobj4とobj25のようにアークID以外は同一のアークが存在することがあり，これを同値アークと呼ぶ．
同値アークは，１つの文法規則から生成されたり，複数の文法規則から生成されたりする．
例えば，obj4とobj25は，図[REF_fig:ExampleGrammar]の(R9),(R10)の構成素列``vp np''の部分から生成されている．
(R9),(R10)は，前置詞句の有無という差はあるが，``vp np''の関係は２つの規則で同一であり，依存構造の解釈という観点から同値アークは等価であると言える．
同値性を扱うために，いくつかの定義を行う．
ID付きアークのアークIDを``?''と置換したアークを汎化アークと呼ぶ．
アークを全て汎化した依存木を汎化依存木と呼ぶ．
通常のID付きのアークからなる依存木を明示する時はID付き依存木と記述する．
また，アークXの汎化アークを?X，依存木DTの汎化依存木を?DTのように記述する．
汎化依存木が等しい２つのID付き依存木は同値であると言う．
縮退依存森は，初期依存森を縮退することで得られる．
依存森の縮退とは，依存森の健全性を保持しながら複数の同値アークを１つにマージする操作であり，結果として依存森のサイズは小さくなる．
依存グラフDG中の同値アーク[MATH],[MATH](equiv([MATH],[MATH])と記述する)に対するマージ操作を次のように定義する．
マージ操作
依存グラフDGより，[MATH]を削除して新たな依存グラフDG'を得る．
(DG'=DG[MATH])
アーク[MATH]([MATH]DG,[MATH],[MATH],CM([MATH],[MATH])=○)に対して，set_CM([MATH],[MATH])を行なうことにより共起マトリックスCMより新たな共起マトリックスCM'を得る．
マージ操作によりDG',CM'からなる新たな縮退依存森が得られる．
図[REF_fig:ArcMerge]にマージの例を共起マトリックスの形式で模式的に示す．
以下の議論で依存木の集合やアークの集合などを定義するが，マージ操作の前後の区別を示す場合には，``wrt DG,CM''あるいは``wrt DF''(wrt:with respect to)の表現を付けて示す．
例えば，以下で定義するアーク[MATH]を含む整依存木の集合dts([MATH])に対して，``dts([MATH]) wrt DG,CM''，``dts([MATH]) wrt DG',CM' ''はそれぞれマージ前と後の依存森に対する集合を示し，``dts([MATH]) wrt DG,CM=dts([MATH]) wrt DG',CM' ''は，マージの前後でdts([MATH])の値が同じことを示す．
簡便のため，以下では``wrt DG,CM''の部分は基本的に省略している．
初期依存グラフの全同値アークをマージすると構文グラフと同じ構造になり，健全性を保てなくなる．
[b]
\myfiglabelskip
依存森の縮退の定義より，依存森の健全性を保持すること，すなわち，同値アークのマージの前後で新規の汎化依存木(新規の解釈)が生成されないことが縮退の条件である．
\mygapskip\mynoindent[同値アークのマージ条件]
「同値アークX,Yのマージ前後の依存森をそれぞれDF,DF'とした時，縮退条件は，``DF中の汎化整依存木集合[MATH]DF'中の汎化整依存木集合''である．
」
この条件は，依存森DF'に新規の汎化依存木が存在しないことを検証することで検証できる．
今，DFに対してDF'に新規の汎化依存木が存在するための条件を汎化依存木の増加条件とすると，同値アークのマージ条件は，「汎化依存木の増加条件が満足されないこと」と等しい．
依存森はID付きアークより構成されているため，ID付き依存木の集合と(それから得られる)汎化依存木の集合の２つを規定している．
今，DFに対してDF'に新規のID付き依存木が存在する条件をID付き依存木の増加条件( ``DF中のID付き整依存木集合[MATH]DF'中のID付き整依存木集合'')とする．
ID付き依存木が増加しなければ汎化依存木の増加はなく，また，ID付き依存木が増加してもそれがDF中のID付き依存木と同値であれば汎化依存木の増加は起こらない．
すなわち，ID付き依存木の増加条件は汎化依存木の増加条件の必要条件である．
以下では，まず，ID付き依存木の増加条件を検証し，次に汎化依存木の増加条件を検証するという考え方で同値アークのX,Yのマージ条件を詳細化する．
新たな(ID付き)整依存木の増加は，同値アークのマージにより新たにアーク間に共起関係が許されることに起因する．
アークU,Vに対してCM(U,V)[MATH]○がCM(U,V)[MATH]○に変化することをアークペア(U,V)の許諾と呼び，次が成立する．
[アークペアの許諾と整依存木の増加] アークペア(U,V)の許諾により新たな整依存木が増加する場合，その依存木はU,Vを要素として含んでいる．
補題[REF_lem:ArcPairAndNewTree]は，もしU,Vの許諾によりUとVの両方を同時に含まない新しい依存木が生成されると仮定するとその依存木は許諾の前でも存在してしまうことになることから明らかである．
\mygapskipここで，同値アークX,Yに対してuniq,diffを次のように定義する．
uniq(X,Y)={[MATH] [MATH] CM(X,[MATH])=○,CM(Y,[MATH])[MATH]○,[MATH]DG}
diff(X,Y)={([MATH],[MATH])[MATH]uniq(X,Y),[MATH]uniq(Y,X)}
図[REF_fig:ArcMerge]の例では，uniq(X,Y)={j,n},uniq(Y,X)={k},diff(X,Y)={(j,k),(n,k)}となる．
一般に次が成立する．
[新規の整依存木の含むアーク]
同値アークX,Yのマージにより新たに整依存木が生成される場合には，その依存木は少なくとも１つの(A,B) [MATH] diff(X,Y)であるA,Bを含む．
\proof{
X,Yのマージ前後の依存森をそれぞれDF,DF'とする．
X,Yのマージで生じるアークペア(X,B[MATH])の許諾により新たな依存木DT[MATH]が得られたとすると，補題[REF_lem:ArcPairAndNewTree]より，X,B[MATH]は，DT[MATH]の要素である．
ここで，R[MATH]DT[MATH]{X,B[MATH]}とする．
U[MATH]Rを考えると，DT[MATH]は整依存木であるからCM(X,U)[MATH]○wrt DF',CM(B[MATH],U)=○wrt DF'である．
今，CM(Y,U)[MATH]○wrt DFであるアークUが存在しない,すなわちCM(Y,U)[MATH]○wrt DF,U[MATH]Rを仮定すると，DT[MATH]={Y,B[MATH]}+Rは，共起条件を満足する整依存木となる．
DT[MATH]とDT[MATH]は，同値アークX,Yが異なるだけなので，DT[MATH]は新たな依存木ではない．
よって，新たな依存木DT[MATH]には少なくとも１つCM(Y,U[MATH])[MATH]○wrt DFなるU[MATH]が存在する必要がある．
(B[MATH],U[MATH])[MATH]diff(X,Y)であるので補題が成立する．
}
補題[REF_lem:ArcsInNewTree]より，次のID付き依存木の増加条件が成立する．
[ID付き依存木の増加条件]  DG,CMにおいて同値アークX,Yに対するアークペア(A,B)[MATH]diff(X,Y)とした時，YをXにマージして得られるDG',CM'において,{X,A,B}を含むID付き整依存木NDTが存在する時，またこの時に限り，ID付き依存木は増加する．
\proof{
新規に生成される整依存木は必ず{X,A,B}を含むこと，{X,A,B}を含む整依存木は必ず新規解であることを示せばよい．
今，DG',CM'中の新たなID付き依存木をNDTとすると，補題[REF_lem:ArcsInNewTree]より，少なくとも１つのアークペア(A[MATH],B[MATH])[MATH]diff(X,Y),A[MATH]NDT,B[MATH]NDTが存在する．
また，補題[REF_lem:ArcPairAndNewTree]より，X[MATH]NDTである．
よって，新規に生成される整依存木は必ず{X,A,B}を含む．
また，(A,B)[MATH]diff(X,Y)より{X,A,B}を含むID付き整依存木はDG,CMに存在しない．
よって，{X,A,B}を含むID付き整依存木は必ず新規に生成される整依存木である．
}
以下で解の増加条件を詳細化するため，ここでいくつかの関数や記法を導入する．
\myhalfskip \fbox{
{13.7cm}
：アーク[MATH],[MATH]の依存ノードの位置が等しい
：[MATH]の共起制約を満たしながら，アーク集合[MATH]から得られるID付き整依存木の集合
：アーク[MATH]あるいは[MATH]と共起するアーク集合，{[MATH] [MATH] [MATH]=[MATH]またはCM([MATH],[MATH])=○, [MATH]}である．
: [MATH],[MATH]中の整依存木でアーク[MATH],[MATH],[MATH],[MATH]を含む整依存木の集合，すなわち，dts(co([MATH])[MATH]co([MATH])) wrt [MATH],[MATH]である．
\myhalfskip
} \myhalfskip
同値アークX,Yに対するdiff(X,Y)中のアークペア(A,B)に関するID付き依存木の増加条件の判定は，定理[REF_the:IDedDepTreeIncreaseCond]よりX,A,Bを含む整依存木がDG',CM'に存在するか探索することにより基本的に実現できる．
これをできるだけ効率的に行うため，X,A,Bに関して次の３つの場合に分けて考える．
same_position(A,B)またはsame_position(X,A)またはsame_position(X,B)が成立．
CM(A,B)[MATH]○である．
(RC1)(RC2)以外の場合．
(RC1)が成立する場合は，整依存木の整被覆条件によりアークが排他関係となりX,A,B全てを含む整依存木は存在しないと判定できる．
(RC2)の場合は，マージ後でもCM'(A,B)[MATH]○であるためDG',CM'において{X,A,B}を含む整依存木は存在しないと判定できる．
(RC3)の場合は{X,A,B}を含む整依存木が存在しない，すなわち，dts_with_arcs(X,A,B) wrt DG',CM'[MATH]{}の判定を行えば良い．
既に述べたようにID付き依存木の増加条件は汎化依存木の増加条件の必要条件である．
このため，ID付き依存木の増加条件を満たす場合，すなわち，dts_with_arcs(X,A,B) wrt DF'([MATH]New_DTsとする) [MATH]{}の場合に，NDT[MATH]New_DTsに対して，NDTが汎化依存木の増加となっている場合にのみ汎化依存木の増加が生じる．
逆に言えば，NDTがDF'に存在した場合でも，汎化依存木?NDTがDFに存在していれば，汎化依存木の増加は起こらない．
これより，ID付き依存木が増加する場合における同値アークのマージ条件は次のようになる．
\mygapskip「同値アークX,Yのマージ前後の依存森DF,DF'に対して，新規に増加するDF'中のID付き依存木DT[MATH]に対して，?DT[MATH]=?DTなるID付き整依存木DTがDFに存在する」\mygapskip
前節の依存森の縮退条件,すなわち同値アークのマージ条件に基づき依存森の縮退を行うアルゴリズムを図[REF_fig:DFReductionAlgorithm]に示す．
アルゴリズムでは，共起マトリックスを集合として表現している．
アークX,Yに対して，[MATH]X,Y[MATH]CMであれば共起関係が成立している．
以下，アルゴリズムの動作を縮退条件に照らし合わせて図[REF_fig:DFReductionAlgorithm]を参照しながら説明する．
図[REF_fig:DFReductionAlgorithm](a)で依存グラフ中にある同値アークペアX,Yを順次取り出し，diff(X,Y)中のアークペア(A,B)について，許諾を行った場合に解(汎化依存木)の増加が起こるかを(b)-(h)でチェックする．
全アークペアに対して汎化依存木の増加が起こらない場合に(i)で依存森の縮退が行なわれる．
(A,B)の許諾の可否は，ID付き依存木の増加条件の確認の後に汎化依存木の増加条件の確認を行うことで判定される．
(b)では，[REF_subsec:IDDTZoukaJuoken]節の(RC1),(RC2)の条件がチェックされ，いずれかを満たす場合は解の増加がないため，次のアークペアの確認に進む．
そうでない場合は，ID付き依存木の増加条件の確認に進む．
(c)では，YをXにマージしたDG',CM'を生成する．
新規依存木の存在チェックは，基本的に依存森に対する解の探索により行うため，できるだけ探索空間を少なくすることで効率化が図れる．
定理[REF_the:IDedDepTreeIncreaseCond]より新規のID付き依存木はX,A,Bを含むので，(d)ではco(X)[MATH]co(A)[MATH]co(B)によりX,A,B全てと共起するアーク以外を除いたアーク集合DG_XABを計算し，(e)でsearch_dtによりDG_XABに対して依存木を探索する．
依存木が得られなければ，このアークペアは同値アークのマージ条件を満たすので，次のアークペアの処理に進む．
依存木DTが得られた場合，DTはX,A,Bを含む新規のID付き依存木である．
(f)のnew_generalized_dt(DT,CM,DG)は，CM,DG中にDTの同値依存木が存在するかを探索することで，DTが汎化依存木として新規かをチェックする．
詳細な説明は省略するが，(q)においてDTの同値アークのみにアーク集合を限定することで汎化依存木の探索を実現している．
DTが汎化依存木として新規の場合は，X,Yのマージはできないため(g),(h)で同値アークX,Yに対する処理を終了し次の同値アークペアのマージにトライする．
汎化依存木として解が存在しない場合には，(i)においてX,Yのマージ，すなわち，依存森の縮退が行われる．
なお，(f)においてDTが汎化依存木として新規でない場合は，(e)においてDG_XABに対して別の解の探索が行われる．
search_dtは，入力位置Pに関して深さ優先に共起条件を満足する解を探索するアルゴリズムである．
(k)においてDG中の位置Pのノードを依存ノードとして持つアーク集合arcs_at(DG,P)から１つアークを選択するが，(m)において，P+1以降で解が見つからなければ(k)で別のアークを選択することで，全解を探索する．
最終的に縮退依存森に同値アークが残る例として付録１の``Tokyo taxi driver call center''に対するアルゴリズムの動作を示す．
例文に対する初期依存森を図[REF_fig:IDFandRDFexample](a)に示す．
初期依存森には(1,2),(5,7),(13,15),(25,26,27)の４種の同値アークが存在し，図のマトリックスでは2重線で括られたまとまりとして示されている．
図[REF_fig:DFReductionAlgorithm]のアルゴリズムに従って縮退処理が行なわれる．
最初の同値アークequiv(1,2)に対し[MATH]=1,[MATH]=2となり，diff([MATH],[MATH])は，uniq([MATH],[MATH])={5,24,25},uniq([MATH],[MATH])={14,15,27}の組合せ{(5,14),(5,15),(5,27),[MATH]}となる．
最初のアークペア(5,14)は，same_position(5,14)であるため図[REF_fig:DFReductionAlgorithm](b)において(RC1)の条件判定でスキップされ，次のアークペア(5,15)が選択される．
(5,15)の場合は，(b)の条件に確定しないため，(c)においてCM',DG'が生成される．
CM'= CM + {[MATH]1,14[MATH],[MATH]1,15[MATH],[MATH]1,27[MATH]}であり，図[REF_fig:IDFandRDFexample](b)に示す．
次に図[REF_fig:DFReductionAlgorithm](d)において[MATH]が計算される．
[MATH]1,[MATH]5,[MATH]15であり，[MATH]co(1)[MATH]co(5)[MATH]co(15) wrt DG',CM'={1,28}となる．
(e)のsearch_dtによる[MATH]に対する解探索は失敗するため，(5,15)の許諾は新規の依存木を生成しない．
さらにアークペア(5,27)のチェックへと処理が進む．
以上のようにしてdiff(1,2)の全てのアークペアに関してチェックが行われるが，いずれもが新規解を生成することなく終了し，(i)において依存森の縮退が行われ，CM'DG'が新規のCM,DGに設定される．
図[REF_fig:IDFandRDFexample](c)は，最終的に得られる縮退依存森であり，同値アーク25,26,27を持つ．
この依存森に対する縮退アルゴリズムの動作を示す．
今,[MATH]25,[MATH]26の時，uniq([MATH],[MATH])[MATH]{1,24}, uniq([MATH],[MATH])[MATH]{6,13}, diff([MATH],[MATH])[MATH]{(1,6),(1,13),(24,6),(24,23)}である．
アークペア(1,6)は(RC1)の条件を満たす．
アークペア(1,13)は，(RC1),(RC2)を満足せず，図[REF_fig:DFReductionAlgorithm](d)において[MATH]が計算される．
[MATH],[MATH],[MATH]であり，[MATH]co(25)[MATH]co(1)[MATH]co(13) wrt DG',CM'={25,1,13,5,28}となる．
[MATH]に対して(e)のsearch_dtを実行すると{25,1,13,5,28}が新規のID付き依存木として検索される．
次に(f)においてnew_generalized_dtが実行され，(q)でadd_equiv_arcsによりDT中の各アークに対する同値アークが追加されたアーク集合[MATH]が計算される．
図[REF_fig:IDFandRDFexample](c)では，25が同値アーク26,27を持つので，これらが追加され，[MATH]{25,26,27,1,13,5,28}となる．
図[REF_fig:DFReductionAlgorithm](r)のsearch_dtでは，解が計算されるが，同値アーク25,26,27のそれぞれに対して[MATH]25,13[MATH],[MATH]26,1[MATH],[MATH]27,5[MATH]がCMにおいて共起条件を満足しないためsearch_dtはfalseとなる．
この結果，(f)のnew_generalized_dtがtrue,すなわち汎化依存木として解の増加となるため，[MATH]=25,[MATH]=26のマージは行われない．
図[REF_fig:IDFandRDFexample](c)の依存森は，付録１の図[REF_fig:SynGraphBadExample]の(a)〜(c)の３つの依存構造のみを保持しており，健全性が保たれている．
縮退処理により生成される依存森は一意に決まるという訳ではなく，マージを試みる同値アークの順番により異なった結果が得られたりする．
例えば，上記の例でも，同じ３つの汎化依存木を含む複数の縮退依存森が存在する．
図[REF_fig:DFReductionAlgorithm]のアルゴリズムは最小の縮退依存森を得るという保証はなく，実際図[REF_fig:IDFandRDFexample](c)よりサイズの小さい依存森も存在する．
また，縮退アルゴリズムの計算量に関しても改善の余地がある．
最小の依存森の構成法やアルゴリズム効率化などについては今後の課題とする．
依存森は，統語森との間で完全性と健全性が成立する．
付録２に初期依存森の完全性と健全性の証明を示す．
縮退依存森は初期依存森と同じ(汎化)依存木の集合を保持しているため，統語森と(縮退)依存森に完全性と健全性が成立すると言える．
統語森中の構文木（句構造）と依存森中の依存木（依存構造）の対応関係は単純な1対1対応ではなく，1つの構文木が複数の依存木に対応したり，複数の構文木が１つの依存木に対応したりする．
言語表現の多様性（１つの意味を複数の表現で表現可能）と曖昧性（１つの表現で複数の意味を表現可能）を考えれば，こうした対応関係は自然な関係であると考えられる．
構文木と依存木の対応関係については，次章の評価実験において例文の解析結果とともに述べる．
