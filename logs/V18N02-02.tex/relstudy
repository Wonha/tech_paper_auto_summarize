\section{関連研究}
\label{sec:related-work}

類似文字列検索は，データベースやデータマイニングの分野で，盛んに研究が行われている．
その中で最も多い研究は，文字列の編集距離を距離尺度として用いるものである．
Gravanoら~\cite{Gravano:01}は，$n$-gram\footnote{データベースの分野では$q$-gramと呼ばれることが多い．}で文字列のインデックスを作り，オーバーラップの個数，位置，文字列のサイズなどで編集距離の制約を満たす解を絞り込む方法を提案した．
Kimら~\cite{Kim:05}は，$n$-gramが出現した場所をインデックスに効率よく格納するため，2 階層の$n$-gramインデックスを提案した．
Liら~\cite{Li:07}は，クエリの処理速度を向上させるため，可変長の$n$を用いた$n$-gramインデックスを用いた．
Leeら~\cite{Lee:07}は，ワイルドカードを含む$n$-gramでインデックスを作り，編集距離制約の類似文字列を効率よく検索する手法を考案した．
Xiaoら~\cite{Xiao:08}は，検索クエリとマッチングできなかった$n$-gramを活用する，Ed-Joinアルゴリズムを提案した．

文字列を$n$-gramなどで表現することなく，編集距離に基づく類似文字列検索を実現する方式も，いくつか提案されている．
Bocekら~\cite{Bocek:07}は，データベースに文字列を格納するときに，元の文字列に近い複数の隣接文字列を格納するアプローチ（隣接文字列生成）として，Fast Similarity Search (FastSS) を提案した．
Wangら~\cite{Wang:09}は，隣接文字列生成手法を改善するため，文字列を分割したり，接頭辞で枝刈りを行う方法を紹介した．
Huynhら~\cite{Huynh:06}は，圧縮された接尾辞配列上で類似文字列検索を行うアルゴリズムを提案した．
Liuら~\cite{Liu:08}は，文字列をトライに格納し，類似文字列検索を行う枠組みを提案した．
これまでに紹介した研究は，編集距離を類似度関数として採用した場合に特化している．

Chaudhuriら~\cite{Chaudhuri:06}は，編集距離とジャッカード係数に対する類似文字列検索に向けて，SSJoin演算を提案した．
このアルゴリズムは，検索クエリ文字列からシグニチャを作成し，シグニチャの特徴を含む全ての文字列を解候補として検索し，編集距離やジャッカード係数の制約を満たす文字列を選び出すものである．
Chaudhuriらは，関係データベースの等結合 (equi-join) を用いてSSJoin演算を実装する方法を示した．
本論文では，SSJoin演算を関係データベース上で実装していないが，これは第\ref{sec:evaluation}節のSignatureシステムと同等である．

Sarawagiら~\cite{Sarawagi:04}は，$\tau$オーバーラップ問題を解くアルゴリズムとして，MergeOptを提案した．
このアルゴリズムは，転置リストを$S$と$L$という 2 つのグループに分け，$S$で解の候補生成を行い，$L$で解の検証を行う．
提案手法と異なる点は，$S$で解の候補生成を行うときにヒープを用いる点，$L$で解の検証を行うときに，枝刈りを行わない点である．
Liら~\cite{Li:08}は，Sarawagiらの手法を改良し，SkipMergeとDivideSkipというアルゴリズムを提案した．
SkipMergeアルゴリズムは，全ての転置リストの先頭から順にSIDをヒープに挿入し，ヒープの先頭から同じSIDの要素を取り出したとき，取り出された個数が$\tau$を超えたら，そのSIDを解とするものである．
ただし，ヒープに転置リストからSIDを挿入するときに，$\tau$オーバーラップ問題の解となり得ない要素をスキップするメカニズムが組み込まれており，転置リスト中の全てのSIDをヒープに挿入しなくても，$\tau$オーバーラップ問題が解けるように工夫されている．
DivideSkipアルゴリズムは，MergeOptアルゴリズムと同様，転置リストを$S$と$L$という 2 つのグループに分け，SkipMergeアルゴリズムを$S$に適用して解の候補生成を行い，$L$で解の検証を行うものである．
しかしながら，DivideSkipアルゴリズムでは解の枝刈り方法については，述べられていない．
これらの手法と提案手法を解析的に比較するのは難しいが，第\ref{sec:evaluation}節では，SkipMergeとDivideSkipアルゴリズムによる類似文字列検索の性能を測定し，提案手法の方が高速に検索できることを実験的に示した．

続いて，提案手法とMergeOpt，SkipMerge，DivideSkipを空間計算量に関して比較する．
ここに挙げた全てのアルゴリズムは，転置リスト上で二分探索を行うため，特殊な工夫をしない限り，転置リストの内容を主記憶に読み込む必要がある．
最悪の場合を考えると，どのアルゴリズムも与えられたクエリ文字列に対して，最もサイズの大きい転置リストを主記憶に読み込む必要が生じる\footnote{細かい議論になるが，SkipMergeとDivideSkipでは複数の転置リスト上で並行して二分探索を行うため，特殊な工夫を施さない限り，複数の転置リストを同時に主記憶に読み込む必要が生じる．}．
これに加え，各アルゴリズムとも解文字列の候補を主記憶上に保持しておく必要がある．
MergeOpt，SkipMerge，DivideSkipアルゴリズムは，解候補をヒープに格納するアルゴリズムであり，ヒープに格納される解候補の数は，クエリに対する転置リストの数（すなわち，クエリの特徴集合$X$の要素数$|X|$）を超えない．
これに対し，提案手法は，いったん解候補の列挙を行うため，おおよそ$\mbox{（転置リストの平均要素数）} \times (|X| - \tau + 1)$程度の解候補を主記憶に保持することになる．
したがって，提案手法はMergeOpt，SkipMerge，DivideSkipアルゴリズムよりも空間計算量が大きくなる．
表\ref{tbl:stats}には，提案手法の各データセットにおける解候補数（\# 候補）が示されている．
これによると，途中で保持した解候補数は数百〜数千程度のオーダーであり，提案手法の空間計算量は実用上は問題にならないと考えられる．

最後に，類似文字列検索に近いタスクとして，類似文字列照合との関係を説明する．
このタスクでは，与えられた 2 つの文字列の表記が近いかどうかを精密に検出するため，文字列の類似度関数を改良したり~\cite{Winkler:99,Cohen:03}，機械学習で獲得するアプローチ~\cite{Bergsma:07,Davis:07,Tsuruoka:07,Aramaki:08}が取られる．
これらの研究成果を用いると，2 つの文字列の類似性を高精度に判別できるが，判別する 2 つの文字列があらかじめ与えられることを前提としている．
このような精細な類似度で類似文字列検索を行いたい場合は，適当な類似度関数に対して緩い閾値$\alpha$を用い，提案手法で類似文字列の候補を獲得してから，類似文字列照合を適用すればよい．



