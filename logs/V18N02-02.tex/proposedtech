    \documentclass[japanese]{jnlp_JS2.0}
\usepackage{jnlpbbl_1.3}
\usepackage[dvips]{graphicx}
\usepackage{amsmath,amssymb}
\usepackage{hangcaption_jnlp}
\usepackage{udline}
\setulminsep{1.2ex}{0.2ex}
\let\underline

\usepackage{url}
\usepackage{theorem}

\newif\ifFINAL
\FINALtrue

\setlength{\theorempreskipamount}{1zw}

\newtheorem{definition}{}
\newtheorem{property}{}


\Volume{18}
\Number{2}
\Month{June}
\Year{2011}

\received{2010}{5}{31}
\revised{2010}{9}{25}
\accepted{2010}{11}{17}

\setcounter{page}{89}

\jtitle{集合間類似度に対する簡潔かつ高速な\\
	類似文字列検索アルゴリズム}
\jauthor{岡崎　直観\affiref{Author_1} \and 辻井　潤一\affiref{Author_2}}
\jabstract{
本論文では，コサイン係数，ダイス係数，ジャッカード係数，オーバーラップ係数に対し，簡潔かつ高速な類似文字列検索アルゴリズムを提案する．本論文では，文字列を任意の特徴（tri-gram など）の集合で表現し，類似文字列検索における必要十分条件及び必要条件を導出する．そして，類似文字列検索が転置リストにおける $\tau$ オーバーラップ問題として正確に解けることを示す．次に，$\tau$ オーバーラップ問題の効率的な解法として，CPMerge アルゴリズムを提案する．CPMerge は，検索クエリ文字列中のシグニチャと呼ばれる特徴と，解候補が枝刈りできる条件に着目し，$\tau$ オーバーラップ問題の解候補を絞り込む．さらに，CPMerge アルゴリズムの実装上の工夫について言及する．英語の人名，日本語の単語，生命医学分野の固有表現の 3 つの大規模文字列データセットを用い，類似文字列検索の性能を評価する．実験では，類似文字列検索の最近の手法である Locality Sensitive Hashing や DivideSkip 等と提案手法を比較し，提案手法が全てのデータセットにおいて，最も高速かつ正確に文字列を検索できることを実証する．また，提案手法による類似文字列検索が高速になる要因について，分析を行う．なお，提案手法をライブラリとして実装したものは，SimString としてオープンソースライセンスで公開している．
}
\jkeywords{類似文字列検索，集合間類似度，転置リスト，$\tau$オーバーラップ問題}

\etitle{A Simple and Fast Algorithm for Approximate \\ String Matching with Set Similarity}
\eauthor{Naoaki Okazaki\affiref{Author_1} \and Jun'ichi Tsujii\affiref{Author_2}} 
\eabstract{
This paper presents a simple and fast algorithm for approximate string matching in which string similarity is computed by set similarity measures including cosine, Dice, Jaccard, or overlap coefficient. In this study, strings are represented by unordered sets of arbitrary features (e.g., tri-grams). Deriving necessary and sufficient conditions for approximate string, we show that approximate string matching is exactly solvable by $\tau$-overlap join. We propose CPMerge algorithm that solves $\tau$-overlap join efficiently by making use of signatures in query features and a pruning condition. In addition, we describe implementation considerations of the algorithm. We measure the query performance of approximate string matching by using three large-scaled datasets with English person names, Japanese unigrams, and biomedical entity/concept names. The experimental results demonstrate that the proposed method outperforms state-of-the-art methods including Locality Sensitive Hashing and DivideSkip on all the datasets. We also analyze the behavior of the proposed method on the datasets. We distribute SimString, a library implementation of the proposed method, in an open-source license.
}
\ekeywords{approximate string matching, set similarity, inverted list, $t$-overlap join}

\headauthor{岡崎，辻井}
\headtitle{集合間類似度に対する簡潔かつ高速な類似文字列検索アルゴリズム}

\affilabel{Author_1}{東北大学大学院情報科学研究科}{Graduate School of Information Sciences, Tohoku University}
\affilabel{Author_2}{マイクロソフトリサーチアジア}{Microsoft Research Asia}


\begin{document}
\maketitle

\section{類似文字列検索の定式化}
\label{sec:formalization}

本研究では，文字列は{\bf 特徴}の集合で表現されると仮定する．
文字列の特徴の捉え方は，提案手法に依らず任意であるが，本論文では一貫して文字tri-gramを具体例として用いる．
例えば，文字列$x = \mbox{「スパゲッティー」}$は，9要素の文字tri-gramから構成される集合$X$で表現される．
\begin{equation}
X = \{\mbox{\texttt{`＄＄ス'}}, \mbox{\texttt{`＄スパ'}}, \mbox{\texttt{`スパゲ'}}, \mbox{\texttt{`ゲッテ'}}, \mbox{\texttt{`ッティ'}}, \mbox{\texttt{`ティー'}}, \mbox{\texttt{`ィー＄'}}, \mbox{\texttt{`ー＄＄'}} \}
\end{equation}
ここで，文字列の先頭と末尾に\texttt{`＄'}を挿入し，文字列の開始と終了を表現している\footnote{この例では，先頭と末尾を表す記号\texttt{`＄'}を付加したが，これも提案手法に依らず任意である．}．
一般に，文字数が$|x|$の文字列$x$を文字$n$-gramの集合$X$で表現したとき，$|X| = |x| + n - 1$という関係が成り立つ．
本論文では，文字列を小文字の変数（$x$など）で表し，文字列を特徴の集合に変換したものを{\bf 特徴集合}と呼び，対応する大文字の変数（$X$など）で表す．
$|x|$を文字列$x$の{\bf 長さ}，$|X|$を文字列$x$の{\bf サイズ}と呼び，これらを区別する．

なお，特徴に頻度などの重みが付くときは，特徴の識別子を分割することで，重み付きの集合を模擬する．
例えば，文字列「トラトラトラ」を文字tri-gramで表現するとき，\texttt{`トラト'}と\texttt{`ラトラ'}が 2 回ずつ出現する．
これを集合で表現するには，tri-gramの末尾に出現回数を表す番号を付加すれば良い．
これにより「トラトラトラ」は，\{\mbox{\texttt{`＄＄ト'\#1}}, \mbox{\texttt{`＄トラ'\#1}}, \mbox{\texttt{`トラト'\#1}}, \mbox{\texttt{`ラトラ'\#1}}, \mbox{\texttt{`トラト'\#2}}, \mbox{\texttt{`ラトラ'\#2}}, \mbox{\texttt{`トラ＄'\#1}}, \mbox{\texttt{`ラ＄＄'\#1}} \}という集合で表現できる．
特徴に出現回数を付与することは実用上重要であるが，説明が冗長になるため，以降では省略する．

本論文では，ダイス係数，ジャッカード係数，コサイン係数，オーバーラップ係数など，集合間のオーバーラップに基づく類似度（集合間類似度）に対して，類似文字列検索アルゴリズムを導出する．
文字列の特徴と類似度関数は，類似文字列検索の精度を左右するので，アプリケーションに応じて慎重に選択する必要がある．
しかし，どのくらいの精度の類似度関数が必要になるかはアプリケーション依存であるため，文字列の特徴や類似度関数の選び方は本論文の対象外とし，与えられた特徴空間と類似度関数に対して，出来るだけ効率よく$\mathcal{Y}_{x, \alpha}$を求めるアルゴリズムを提案することに注力する．
精細な類似度が必要な場合は，適当な類似度関数に対して緩い閾値$\alpha$を用い，提案手法で再現率が高くなるように類似文字列を検索し，関連研究（第\ref{sec:related-work}節）で紹介する手法などで精査することで，適合率を改善すればよい．

さて，文字列$x$と$y$を，それぞれ特徴集合$X$と$Y$で表すとき，$x$と$y$のコサイン係数は，
\begin{equation}
 {\rm cosine}(X, Y) = \frac{|X \cap Y|}{\sqrt{|X||Y|}} ．
 \label{equ:cosine}
\end{equation}
この定義式を式\ref{equ:approximate-string-retrieval}に代入すると，類似文字列のための必要十分条件が得られる．
\begin{equation}
 \left\lceil \alpha \sqrt{|X||Y|} \right\rceil \leq |X \cap Y| \leq \min\{|X|, |Y|\} 
 \label{equ:match-condition}
\end{equation}
ここで，$\lceil v \rceil$は$v$の整数値への切り上げを表す．
また，式\ref{equ:match-condition}には，$|X \cap Y|$の上限値$\min\{|X|, |Y|\}$を不等式として組み込んだ．
式\ref{equ:match-condition}は，特徴集合$X$と$Y$のコサイン係数が$\alpha$以上になるためには，少なくても$\left\lceil \alpha \sqrt{|X||Y|} \right\rceil$個の要素を共通に持つ必要があることを示している．
必要十分条件において，$|X \cap Y|$が取るべき最小の値を，$X$と$Y$の{\bf 最小オーバーラップ数}と呼び，以降{\bf この数を$\tau$で表す}．
$\tau$は，$|X|$，$|Y|$，$\alpha$に依存して計算される値である．

ところで，式\ref{equ:match-condition}において$|X \cap Y|$を無視すると，$|X|$と$|Y|$に関する不等式を得る．
\begin{equation}
 \alpha \sqrt{|X||Y|} \leq \min\{|X|, |Y|\} .
\end{equation}
この不等式を$|Y|$について解くと，類似文字列の必要条件が得られる．
\begin{equation}
 \left\lceil \alpha^2 |X| \right\rceil \leq |Y| \leq \left\lfloor \frac{|X|}{\alpha^2} \right\rfloor
 \label{equ:necessary-condition}
\end{equation}
ここで，$\lfloor v \rfloor$は$v$の整数値への切り捨てを表す．
この不等式は，$X$に対して類似文字列検索を行う際の，$Y$に関する探索範囲を表現している．
言い換えれば，特徴集合の要素数がこの範囲外の文字列は，無視できる．

なお，同様の導出は，ダイス係数，ジャッカード係数，オーバーラップ係数などの類似度関数に対しても可能である．
表\ref{tbl:conditions}に，それぞれの類似度関数の条件式をまとめた．
これらの条件式の大元の出典は不明であるが，本論文で導出した条件式は，いくつかの先行研究でも用いられている~\cite{Sarawagi:04,Li:08,Xiao:08b}．

\begin{table}[t]
\caption{集合間類似度を用いた類似文字列検索における$|Y|$の必要条件，及び$|X \cap Y|$の必要十分条件}
\label{tbl:conditions}
\input{02table01.txt}
\end{table}

ここで，導出した不等式の利用例を説明する．
検索クエリ文字列$x = \mbox{「スパゲティー」}$とし，コサイン類似度の閾値$\alpha = 0.7$で類似文字列検索を行う．
また，文字列の特徴を文字tri-gramで表現することとする（したがって，$|X| = 6 + 3 - 1 = 8$である）．
式\ref{equ:necessary-condition}から，$Y$の要素数に関する探索範囲は$4 \leq |Y| \leq 16$である．
この範囲内で，例えば$|Y| = 9$となる文字列を考慮しているとき，式\ref{equ:match-condition}から，類似文字列の必要十分条件，$6 \leq |X \cap Y|$が得られる．
この必要十分条件は，$X$のtri-gramのうち，少なくても6個は$Y$にも出現しなければならないことを表す．
例えば，$y = \mbox{「スパゲッティー」}$を考えると，$|X \cap Y| = 6$である．
したがって，$y$は類似文字列検索の解の 1 つである．
実際，$x$と$y$のコサイン類似度は，$6 / \sqrt{8 \times 9} = 0.707$ ($\geq \alpha$) である．

以上のことをまとめると，種々の類似度関数を用いた類似文字列検索は，次のような一般的な手順で実装することができる．
\begin{enumerate}
    \item 与えられた検索文字列$X$と類似度閾値$\alpha$から，$|Y|$の範囲を求める
    \item その範囲内で，$|X \cap Y|$の条件を満たす$Y$を見つける
\end{enumerate}
次節では，これらの手順を効率良く実装するデータ構造とアルゴリズムを議論する．



\section{データ構造とアルゴリズム}
\label{sec:method}

\subsection{データ構造}
\label{sec:data-structure}

前節までの議論により，類似文字列検索は次の部分問題を解くことに帰着される．

\begin{definition}[$\tau$オーバーラップ問題]
検索クエリ文字列の特徴集合$X$が与えられたとき，その特徴を$\tau$個以上共有する文字列$Y$を全て見つける．
\end{definition}

ここで，$\tau$は$X$と$Y$の最小オーバーラップ数で，コサイン係数を類似度関数として用いる場合は，$\tau = \left\lceil \alpha \sqrt{|X||Y|} \right\rceil$である．
この部分問題を効率的に解くため，特徴をキーとして，その特徴を含む文字列のリストを値とする連想配列（転置インデックス）を構築する．
式\ref{equ:match-condition}から，探索すべき文字列のサイズ$|Y|$の範囲が絞り込まれること，式\ref{equ:necessary-condition}から，$|Y|$に依存して最小オーバーラップ数$\tau$が決まることを考慮し，文字列のサイズ$l$毎に転置インデックス$D_l$を構築する．
また，アルゴリズムを効率よく実行するため，文字列をユニークな文字列識別番号 (SID) で表現し，転置リストは特徴を含む文字列のSIDを昇順に並べたものを格納することとする．
図\ref{fig:data-structure}に，データ構造の実現例を示した．
例えば，\texttt{`＄＄ス'}を特徴に持つ文字列のSIDは，\#267, \#452, \#743, \#2389, ... であり，「スパゲッティー」のSIDは\#452である．
図\ref{fig:data-structure}では，文字列のサイズ毎にハッシュ表を構築しているが，SQLなどの関係データベースを用いても，同様のデータ構造が実現できる．

\begin{figure}[b]
    \begin{center}
\includegraphics{18-2ia2f1.eps}
    \end{center}
    \caption{複数の転置インデックスで構築された類似文字列検索のためのデータ構造}
\label{fig:data-structure}
\end{figure}

図\ref{alg:approximate-string-matching}に，類似文字列検索の擬似コードを示す．
文字列のサイズ$l$毎に構成された転置インデックスの配列$D = \{D_l\}$に対して，検索文字列$x$，類似度閾値$\alpha$が与えられると，この擬似コードは$x$との類似度が$\alpha$以上の文字列のSIDのリスト$R$を返す．
1〜3 行目で，クエリ文字列$x$を特徴集合$X$に変換し，考慮すべき文字列のサイズの範囲を表\ref{tbl:conditions}から求める．
探索範囲内のそれぞれの長さ$l \in [n, N]$に対し（5 行目），最小オーバーラップ数$\tau$を求め（6 行目），{\tt overlap\_join}関数で$\tau$オーバーラップ問題を解き，解集合$R$を更新する（7 行目）．


\subsection{$\tau$オーバーラップ問題のアルゴリズム}

\ref{sec:data-structure}節では，特徴をキーとして，その特徴を含む文字列 (SID) のリストを返す転置インデックスを構築した．
特徴$q$の転置リストに含まれている文字列は，特徴$q$を含むことが保証されている．
したがって，特徴$q \in X$に対応する$|X|$個の転置リストの中で，ある文字列$y$が$c$個の転置リスト 2 回出現するならば，$|X \cap Y| = c$である．
ゆえに，転置リスト上において$\tau$回以上出現するSIDを見つけることで，$\tau$オーバーラップ問題を解くことができる．
図\ref{alg:t-overlap-naive}に，このアイディアに基づく$\tau$オーバーラップ問題の解法（{\bf AllScanアルゴリズム}）を示した．
4 行目の関数$\mbox{\tt get}(d, q)$は，転置インデックス$d$の中で特徴$q$に対応する転置リスト（SIDのリスト）を返す関数である．
この擬似コードは，転置インデックス$d$，特徴集合$X$，最小オーバーラップ数$\tau$を受け取り，SIDの出現頻度，すなわち$|X \cap Y|$を連想配列$M$に格納し，その値が$\tau$に到達したSIDをリスト$R$に入れて返すものである．
表\ref{tbl:spaghetti-solutions}は，検索クエリ文字列$x = \mbox{「スパゲティー」}$に対して，Web日本語Nグラムコーパスのユニグラムの中で，文字数が 7（つまり$|Y| = 9$）の文字列を実際に検索するとき，$|X \cap Y|$の高い文字列10件を示したものである（文字列の特徴はtri-gramで表現）．
コサイン係数が0.7以上の文字列を探すには，$\tau = \left\lceil \alpha \sqrt{|X||Y|} \right\rceil = 6$であるから，類似文字列検索の解は「スパッゲティー」「スパゲティーニ」「スパゲティー・」「スパゲッティー」の 4 つである．

\begin{figure}[t]
\begin{minipage}{0.45\textwidth}
\begin{center}
\includegraphics{18-2ia2f2.eps}
\end{center}
\caption{類似文字列検索のアルゴリズム．}
\label{alg:approximate-string-matching}
\vspace{22pt}
\end{minipage}
\hfill
\begin{minipage}{0.45\textwidth}
\begin{center}
\includegraphics{18-2ia2f3.eps}
\end{center}
\caption{AllScanアルゴリズム．}
\label{alg:t-overlap-naive}
\end{minipage}
\end{figure}


AllScanアルゴリズムの実装は簡単であるが，検索に用いる特徴が数多くの文字列に出現するとき，走査するSIDの数が非常に大きくなるという欠点がある．
例えば，\texttt{`ティー'}（「ティー」を含む）や\texttt{`ー＄＄'}（「ー」で終わる）などの文字tri-gramは，日本語の多くの語で出現するため，転置リストが大きくなる傾向にある．
表\ref{tbl:spaghetti-stat}に，Web日本語Nグラムコーパスにおいて，「スパゲティー」の各tri-gramの転置リストのサイズ（すなわち，各tri-gramを含む文字列の数）を示した．
この表によると，AllScanアルゴリズムは30,584種類，35,964個のSIDを走査することになるが，その中でたった4個 (0.013\%) しか解にならない．

走査すべきSIDの数を減らすため，$\tau$オーバーラップ問題に関する次の性質に着目する~\cite{Arasu:06,Chaudhuri:06}．
\newpage
\begin{property}
    要素数が$k$の集合$X$と，要素数が任意の集合$Y$がある．
    要素数が$(k - \tau + 1)$となる任意の部分集合$Z \subseteq X$を考える．
    もし，$|X \cap Y| \geq \tau$ならば，$Z \cap Y \neq \phi$である．
\label{prop:signature}
\end{property}
この性質は，その対偶を考えれば明白である．
すなわち，$Z \cap Y = \phi$ならば，$Z$の定義から$|X \setminus Z| = k - (k - \tau + 1) = \tau - 1$であるので，$|X \cap Y| = |\{(X \setminus Z) \cup Z\} \cap Y| = |(X \setminus Z) \cap Y| + |Z \cap Y| \leq \tau - 1$．ゆえに，$|X \cap Y| < \tau$が示される\footnote{二項演算子$\setminus$は差集合を表す．つまり$A \setminus B$は集合$A$から集合$B$に属する要素を間引いて得られる集合である．}．

\begin{table}[t]
\begin{minipage}[t]{0.45\textwidth}
\setlength{\captionwidth}{\textwidth}
\hangcaption{検索文字列$x=\text{「スパゲティー」}$に対し，Web日本語Nグラムコーパス中で$|X \cap Y|$の大きい文字列（$|Y|=9$のとき）}
\label{tbl:spaghetti-solutions}
\input{02table02.txt}
\end{minipage}
\hfill
\begin{minipage}[t]{0.45\textwidth}
\setlength{\captionwidth}{\textwidth}
\hangcaption{Web日本語Nグラムコーパス中で，検索文字列$x=\text{「スパゲティー」}$の各tri-gramを含む文字列の数（$|Y|=9$のとき）}
\label{tbl:spaghetti-stat}
\input{02table03.txt}
\end{minipage}
\end{table}

性質\ref{prop:signature}の利用例を，先の類似文字列検索を用いて説明する．
検索クエリ文字列$x = 「スパゲ\linebreak ティー」$に対し，$|Y| = 9$かつ，$\tau = 6 \leq |X \cap Y|$という条件を満たす文字列$y$を検索している．
検索される文字列$y$が$|X \cap Y| \geq 6$を満たすならば，特徴集合$X$中の任意の$(8 - 6 + 1) = 3$要素で構成された任意の部分集合$Z \subset X$に対し，$Z \cap Y \neq \phi$である．
言い換えれば，特徴集合$X$中の任意の3要素を選ぶと，対応する転置リストに，類似文字列検索の解が（あるとすれば）必ず含まれている．
この性質を用いると，類似文字列検索の解の候補を絞り込むことができる．
解候補を生成するために用いる要素は，シグニチャ~\cite{Arasu:06}と呼ばれる．

では，検索文字列の特徴集合の中で，どの要素をシグニチャとして採用すれば良いのだろうか？　
シグニチャの特徴数は性質\ref{prop:signature}から決定されるが，その選び方は任意である．
したがって，転置リストのサイズが小さい特徴をシグニチャとして採用すれば，解候補生成時に走査するSIDの数を減らすことができる．
すなわち，文字列データベース中で稀に出現するtri-gramを優先的にシグニチャとして採用し，解の候補を絞り込めばよい．
表\ref{tbl:spaghetti-stat}の例では，「パゲテ」「ゲティ」「スパゲ」をシグニチャとして選択することになる．

シグニチャによる解候補生成を採用したアルゴリズムを，図\ref{alg:t-overlap-cpmerge}に示す．
性質\ref{prop:signature}より，特徴集合$X$を，要素数$(|X| - \tau + 1)$のシグニチャ$S$と，残り$L$ $(= X \setminus S)$に分解する．
このアルゴリズムは，2 から 7 行目で類似文字列検索の解候補をシグニチャ$S$から獲得し，8 行目から21行目で解候補の検証と枝刈りを$L$で行う．
このアルゴリズムは，解候補の生成と枝刈りをしながら転置リストをマージしていくので，{\bf CPMergeアルゴリズム}と命名した．

\begin{figure}[b]
\begin{minipage}{187pt}
\includegraphics{18-2ia2f4.eps}
\caption{CPMergeアルゴリズム}
\label{alg:t-overlap-cpmerge}
\vspace{74pt}
\end{minipage}
\hfill
\begin{minipage}{231pt}
\includegraphics{18-2ia2f5.eps}
\caption{CPMerge-optの擬似コード}
\label{alg:t-overlap-cpmerge-post}
\end{minipage}
\end{figure}

1 行目で，検索文字列の特徴集合の要素を，転置リストのサイズ（要素数）の昇順に並び替える．
このとき，$X[k]$の転置リストの内容をすべてメモリに読み込まなくても，$|\mbox{\tt get}(d, X[k])|$の値を取得し，$X$の要素を並び替えられるようにしておくことは，実用上重要である（この理由は\ref{sect:cpmerge-stat}節で明らかになる）．
特徴集合$X$の要素を並び替えたとき，稀な特徴の順番に$X[0], \ldots , X[|X|-1]$とアクセスできるものとする．
シグニチャ$S$として採用されるのは，$X[0], \ldots , X[|X| - \tau + 1]$である．
アルゴリズムの 2 から 7 行目では，シグニチャの特徴を持つ文字列をデータベース$d$から検索し，その転置リストにおける出現回数を連想配列$M$に記録する．

先の例と同じ類似文字列検索（$x = \mbox{「スパゲティー」}$，$|Y| = 9$，$\tau = 6 \leq |X \cap Y|$）に対して，CPMergeアルゴリズムの動作例を表\ref{tbl:spaghetti-process}に示した．
候補生成フェーズでは，「パゲテ」「ゲティ」「スパゲ」のtri-gramを含む文字列を検索し，検索された文字列を解候補とするとともに，該当する箇所に「○」を記している．
シグニチャから獲得される解候補の数は32で，AllScanアルゴリズムと比べると，解候補数を0.105\%まで絞り込んだことになる．
アルゴリズムの 9 行目から21行目では，それぞれの候補文字列が，残りの特徴$L$を持っているかどうかを調べる．
それぞれの解候補$i \in M$が（10行目），特徴$X[k]$を持っているかどうかを，転置リスト$\mbox{\tt get}(d, X[k])$上における二分探索で調べ（11行目），転置リストが$i$を含んでいれば，頻度カウンタをインクリメントする（12行目）．
もし，頻度カウントが$\tau$に到達したら（14行目），$i$を結果リスト$R$に追加し（15行目），候補$M$から削除する（16行目）．
もし，頻度カウントが$\tau$に到達していない場合は，以下の性質を利用して枝刈りの可能性を調べる．
\begin{property}
要素数が$g$の集合$X$と，要素数が任意の集合$Y$がある．
要素数が$h$のある部分集合$Z \subseteq X$を考える．
もし，$|Z \cap Y| = \theta$ならば，$|X \cap Y| \leq \theta + g - h$である．
\end{property}
$Z$の定義により$|X \setminus Z| = g - h$であるから，$|(X \setminus Z) \cap Y| \leq g - h$．したがって，この性質は$|X \cap Y|$の上限値が$(\theta + g - h)$になることを表現している．
図\ref{alg:t-overlap-cpmerge}のアルゴリズムでは，$\theta = M[i]$，$g = |X|$，$h = (k + 1)$とおき，$|X \cap Y|$の上限値を$(M[i] - |X| - k - 1)$と計算し，この値が$\tau$を下回っているならば（17行目），候補$i$を枝刈りする（18行目）．

\begin{table}[p]
\hangcaption{Web日本語Nグラムコーパスにおいて，検索文字列$x=\text{「スパゲティー」}$に対し，$6 \leq |X \cap Y|$となる文字列$y$を見つける際の，候補生成と検証プロセスの実行例（$|Y|=9$の場合）}
\label{tbl:spaghetti-process}
\input{02table04.txt}
\end{table}

表\ref{tbl:spaghetti-process}は，検証フェーズ ($3 \leq k \leq 7$) の動作例も示している．
$k = 3$では，32個の候補文字列のそれぞれに対して，414個のSIDを含む転置リスト上で二分探索を行い，「＄スパ」というtri-gramを含むかどうか調べている．
候補文字列が特徴を含む場合は「○」，含まない場合は「×」が記される．
もし，候補文字列が「＄スパ」というtri-gramを含んでおらず，これまでの出現頻度が1回だった場合は，今後$4 \leq k \ \leq 7$の全ての転置リストに出現しても，出現頻度の最大値は5に留まる．
つまり，$|X \cap Y| < 6$となることが確定しているので，「アニスパゲス」「イカスバゲティ」などの文字列は，$k = 3$において枝刈りする．
表\ref{tbl:spaghetti-process}では，枝刈りされる候補に「{\bf ×.}」を記している．
枝刈りにより，$k = 3$において15個の解候補が枝刈りされ，候補は17文字列に減る．
$k = 4, 5$でも同様の処理を行い，解の候補はそれぞれ 8 個，5 個まで絞り込まれる．
$k = 6$では，「スパゲティー・」と「スパゲティーニ」の出現回数が6に到達するので，
    候補集合から解集合に移動させる（\scalebox{1.7}{$\boldsymbol{\circ}$}\textbf{.}で表示）．
$k = 7$では，「スパゲッティー」と「スパッゲティー」の出現回数が6に到達し，全ての候補の検証が終了したことになる．

CPMergeアルゴリズムにおいて，$X[k]$の転置リストを処理した後に残る解候補の数を$C_k$，$X[k]$の転置リストの要素数を$P_k = |\mbox{\tt get}(d, X[k])|$とする．
CPMergeの検証フェーズでは，それぞれの候補に対して二分探索を行うため，9 行目の各$k$に対して，10〜20行目の計算量は$O(C_{k-1} \log P_k)$である．
$X[k]$の並び順の定義から，$k$が大きくなると$P_k$も増加するが，枝刈りが有効に働けば，$C_k$が小さくなる．
表\ref{tbl:spaghetti-process}の例では，各$k$に対して$C_{k-1} \log P_k$の値は，193 ($k = 3$)，115 ($k = 4$)，57.5 ($k = 5$)，45.1 ($k = 6$)，20.2 ($k = 7$) であり，9〜21行目のループが進むにつれて，計算量の見積りが減少する．
検索クエリ文字列やデータベースの文字列集合のtri-gramの分布により，$C_k$や$P_k$の傾向が異なるので，計算量の見積りを一般的に行うことは難しい．
そこで，第\ref{sec:evaluation}節では，CPMergeアルゴリズムが実際のデータセットに対して動作する際の，解の候補数，転置リストに含まれるSIDの数などの統計情報を報告する．



\subsection{実装上の工夫}

図\ref{alg:t-overlap-cpmerge}のアルゴリズムでは，SIDをキーとして頻度を格納する連想配列$M$を用いていた．
実は，転置リストが整列済みのSIDで構成されるという性質を利用すれば，情報検索における転置リストのマージ~\cite{IR}と同様に，連想配列をリスト構造（可変長配列）で代用できる．
主要なプログラミング言語では連想配列を容易に扱えるが，アクセスのコストがリスト構造よりも大きいので，連想配列をリスト構造で置き換えることで，検索処理の高速化が期待できる．

図\ref{alg:t-overlap-cpmerge-post}は，図\ref{alg:t-overlap-cpmerge}から連想配列を排除し，リスト構造のみでCPMergeアルゴリズムを実装するもの (CPMerge-opt) である．
図\ref{alg:t-overlap-cpmerge-post}の 2〜21行目は，図\ref{alg:t-overlap-cpmerge}の 2〜7 行目に対応し，解の候補生成を行う．
2 行目では，解候補の頻度を計測する変数$M$を初期化しているが，その型は連想配列 ($\{\ \}$) から，可変長配列 ($[\ ]$) に変更されている．
CPMerge-optでは，$M$の要素は$(\mbox{\rm SID}, \mbox{頻度})$のタプルであり，要素はSIDの昇順に並べる．
3〜21行目の基本的な流れは，$(k-1)$における解候補リスト$M$と，$P = \mbox{\tt get}(d, X[k])$の転置リストを，先頭から順に比較していき，一時変数$W$に$k$における解候補リストを作成する．
最後に，$M$を$W$で上書きし（20行目），$k+1$のステップへと進む．
各$k$において，$W$を空のリストで初期化し（4 行目），$M$と$P$でこれから処理する要素の位置（インデックス）を管理する変数$m$と$p$を，それぞれ$0$で初期化する（6 行目）．
7 行目から19行目までは，$M$と$P$の全ての要素を処理し終わるまで，以下の処理を繰り返す．
\begin{enumerate}
 \item もし転置リスト$P$のSID ($P[p]$) が，$(k-1)$における解候補リスト$M$に含まれていない場合（8 行目），$P[p]$を新しい候補として$W$に登録し（9 行目），$p$をインクリメントする（10行目）．
 \item もし，$(k-1)$における解候補リスト$M$中のSID ($M[m].{\rm id}$) が，転置リスト$P$に含まれていない場合（11行目），$M[m]$を$W$にそのまま追加し（12行目），$m$をインクリメントする（13行目）．
 \item それ以外の場合，すなわち転置リスト$P$の要素$P[p]$と解候補リスト$M$中の$M[m].{\rm id}$が等しい場合（14行目），$M[m]$の頻度をインクリメントしたものを$W$に追加し（15行目），$p$と$m$の両方をインクリメントする（16行目）．
\end{enumerate}

図\ref{alg:t-overlap-cpmerge-post}の22〜36行目は，図\ref{alg:t-overlap-cpmerge}の 8〜21行目に対応し，解の候補の検証と枝刈りを行っている．
CPMerge-optでは，$(k-1)$における解候補リスト$M$に対して，転置リスト$\mbox{\tt get}(d, X[k])$で検証を行い，枝刈りされなかった候補を一時変数$W$に待避し，$k$における処理が終わったら$M$を$W$で上書きしている．
図\ref{alg:t-overlap-cpmerge}と図\ref{alg:t-overlap-cpmerge-post}のその他の箇所は，ほとんど同じである．



\end{document}
