本節では，意味カテゴリ間の兄弟関係を事前知識として活用する手法を提案する．
以降では，兄弟関係にあるカテゴリの集合を兄弟グループと呼ぶこととする．
例えば，自動車と自動二輪のカテゴリは兄弟関係にあるため，同一の兄弟グループに属する．
本研究では，同一の兄弟グループに含まれるインスタンスは共通の特徴を保有していると仮定する．
例えば，自動車と自動二輪の兄弟グループに含まれるインスタンスは「乗り物」や「ガソリン式」という特徴を持ち，「乗る」や「燃費」などの語と係り受け関係を持ちやすい．
この兄弟グループに共通の特徴を持っていないインスタンスは，正しいインスタンスである可能性が低いと考えられる．
そのため，提案手法は兄弟グループのシードインスタンス集合を利用して兄弟グループに共通の特徴を取得し，グループ内の候補インスタンスがこの共通の特徴を保有しているか否かを検証することで，誤ったインスタンスの獲得を防ぐ．
同一の兄弟グループに属する自動車と自動二輪カテゴリについて，提案手法を用いて集合拡張の際の誤りインスタンスを除去する例を図[REF_fig:overview]に示す．
提案手法はまず，この兄弟グループのインスタンスに共通の特徴として，「乗る」や「燃費」という表現と係り受け関係を持ちやすいという知識を得る．
既存のブートストラッピング手法では，自動車カテゴリにおいて「新型のX」というパターンを獲得してしまった場合，シードや兄弟グループとは無関係のインスタンスである「iPad」を除去することができない．
これに対して，提案手法では候補インスタンスが「乗る」や「燃費」と係り受け関係にある文節に出現しているかを，インスタンスの獲得（厳密には候補のランキング）の前に検証することによって，「iPad」のような誤りインスタンスを取り除くことができる．
この結果，提案手法は「カムリ」のような兄弟グループに共通する特徴を持つインスタンスのみを獲得する．
ここで，兄弟グループに共通の特徴が，対象とする意味カテゴリ以外も包含してしまうと，意味ドリフトが発生してしまう．
これを防ぐために，兄弟グループ間は排他関係にあるとし，兄弟グループに共通の特徴は対象としている兄弟グループに固有の特徴とする．
本研究では兄弟グループに共通の特徴は「乗る」や「燃費」などの表現によって表されると仮定する．
このような表現をフィルタパターンと呼ぶ．
提案手法では，候補インスタンスがフィルタパターンと共起しているか，すなわち，候補インスタンスがフィルタパターンと係り受け関係にある文節に出現しているかの検証を行うことで，インスタンスが兄弟グループに共通の特徴を保有しているかを確認する．
この確認はインスタンスの獲得の直前に行い，候補インスタンスの抽出法については，既存の手法を用いる．
すなわち，提案手法はEspressoアルゴリズムやg-Espressoなどの既存手法と組み合わせて利用することができる．
[t]
Espressoアルゴリズムを利用し，図[REF_fig:overview]のアイディアをアルゴリズムとして記述したものがAlgorithm [REF_alg1]である．
このアルゴリズムは入力として対象とするカテゴリの集合[MATH]，[MATH]から[MATH]までの兄弟グループ，それぞれのカテゴリ[MATH]に対応するシードインスタンス集合[MATH]，反復の回数[MATH]，コーパス[MATH]を受け取る．
兄弟グループはそれぞれ[MATH]の部分集合であり，また，互いに素である．
まず，[REF_st_sibp_extract]行目から[REF_end_sibp_extract]行目において各兄弟集合[MATH]に対するフィルタパターン[MATH]を選択する．
次に[REF_espresso]行目において兄弟グループ[MATH]内の各カテゴリ[MATH]のインスタンスを関数\Call{Espresso_Exclusion}{}を用いて取得する．
\Call{Espresso_Exclusion}{}は要素のそれぞれがインスタンス[MATH]，カテゴリ[MATH]，スコア[MATH]のタプル，すなわち[MATH]からなるリスト[MATH]を返す．
この関数において，インスタンスの抽出とスコアの計算は，[REF_Espresso]節で説明したEspressoアルゴリズムに，兄弟グループのカテゴリ間でパターンに対する排他制約を導入した手法を用いて行う．
本研究ではパターンはインスタンスと係り受け関係にある文節と定義する．
例えば，「プリウス」というインスタンスと図[REF_eg:sentence]に示す文が与えられたとする（図[REF_eg:sentence]では文を文節で区切り，係り受け関係を文節間の矢印で表現している）．
このとき，プリウスと同じ意味クラスに属するインスタンスを取得するためのパターンとして，
X[MATH]販売を
X[MATH]新型
を得る．
ここで，係り受け関係の向きについて，インスタンスを含む文節が別の文節に係るときを「[MATH]」で，別の文節がインスタンスを含む文節に係るときを「[MATH]」で表している．
関数\Call{Espresso_Exclusion}{}では，「X[MATH]販売を」や「X[MATH]新型」のように，係り受け関係の向きも含めた表現形式をパターンとする．
次に[MATH]に含まれる候補インスタンス[MATH]が兄弟グループに共通の特徴を持つか否かの検証を，関数\Call{Filter}{}によって行う（[REF_filter]行目）．
関数\Call{Filter}{}は[REF_st_func_fil]行目から[REF_end_func_fil]行目に書かれている通りであり，[MATH]に含まれる[MATH]がそれぞれフィルタパターン[MATH]と共起しているかどうかを検証する．
この関数はフィルタパターンと共起しているインスタンスをそのスコアとともにリストとして返す．
言い換えれば，この関数はフィルタパターンの集合[MATH]によって表される兄弟グループに共通の特徴を保有していないインスタンスを除去している．
兄弟グループ内でのドリフトを防ぐため，提案手法は兄弟グループのカテゴリ間に排他制約を導入している．
パターンやインスタンスが兄弟グループ内の複数のカテゴリで出現している場合，提案手法はそれらが属するべき最適なカテゴリをただ1つ決定する．
提案手法ではこの決定をランキングの結果をもとに行う．
例えば自動車と自動二輪カテゴリにおいて「X→マフラー」というパターンが出現していたとする．
ランキングの結果，もしこのパターンが自動車カテゴリでは13位であり自動二輪カテゴリでは4位だったとすると，このパターンは自動二輪カテゴリにのみ属するものとする．
すでに説明したように，Algorithm [REF_alg1]において関数\Call{Espresso_Exclusion}{}はパターンに対する排他制約が導入されているものであるとしており，インスタンスに対する排他制約は[REF_exclusive]行目から[REF_end_exclusive]行目に実装されている．
提案手法ではスコア[MATH]を元に，[REF_exclusive]行目から[REF_end_exclusive]行目での排他制約を適用しながら，反復数（[MATH]回目）に応じて上位[MATH]個のインスタンスを獲得する．
すべてのカテゴリについて新たなインスタンスの取得が終わった後，次の反復へと進む．
入力として与えた回数だけ反復した後，アルゴリズムはそれぞれのカテゴリ[MATH]に対応するインスタンス集合[MATH]を出力する．
正則化ラプラシアンカーネルを利用したg-Espressoによるインスタンスの抽出と，フィルタパターンによる候補インスタンスの特徴の検証を組み合わせた手法を，アルゴリズムとして記述したものがAlgorithm [REF_proposed_g_espresso]である．
このアルゴリズムはAlgorithm [REF_alg1]の入力から反復回数[MATH]を除いたものを入力として受け取る．
[b]
[1]
Algorithm [REF_proposed_g_espresso]はAlgorithm [REF_alg1]と同様，まず各兄弟集合[MATH]に対するフィルタパターン[MATH]を選択する．
次に兄弟グループ[MATH]内の各カテゴリ[MATH]について，候補インスタンス集合[MATH]とパターンの集合[MATH]を関数\Call{Espresso}{}によって，抽出する（[REF_espresso4g]行目）．
関数\Call{Espresso}{}は[REF_Espresso]節において説明したEspressoアルゴリズムによって，パターンとインスタンスのスコアを計算し，上位[MATH]個のパターンと上位[MATH]個のインスタンスを返す関数である．
なお，ここでのパターンも[REF_proposed_espresso]節での関数\Call{Espresso_Exclusion}{}で用いたものと同様，「X[MATH]発表した」のような係り受け関係の向きも含めたものとする．
g-Espressoは対象とするカテゴリ毎に，コーパス中の全パターンと全インスタンスを対象とした計算を行うため，ウェブページなどの大規模コーパスや，複数の意味カテゴリを対象とした場合には計算量が膨大になってしまう．
計算量を抑えるため，萩原ら[CITE]はブートストラッピング手法によって計算対象を制限し，その後グラフカーネルを適用する手法を用いた．
本手法でも同様に，Espressoアルゴリズムによってシードインスタンス集合と相関の高いパターン／インスタンスを[MATH]，[MATH]として抽出し，g-Espressoへの入力とする．
なお，今回は萩原ら[CITE]を参考に[MATH]とし，[MATH]とした．
次に候補インスタンス集合[MATH]に含まれるインスタンスが兄弟グループに共通の特徴を持つか否かの検証を，Algorithm [REF_alg1]における関数\Call{Filter}{}を用いて行う（[REF_filter_g]行目）．
次に[MATH]と関数\Call{Filter}{}の返した[MATH]を対象とし，g-Espressoによってインスタンスのスコアを計算する．
これは関数\Call{g-Espresso}{}を用いて行う（[REF_g_espresso]行目）．
関数\Call{g-Espresso}{}は要素のそれぞれがインスタンス[MATH]，カテゴリ[MATH]，スコア[MATH]のタプルからなるリスト[MATH]を返す．
最後にAlgorithm [REF_alg1]と同様に，兄弟グループのカテゴリ間での排他制約を考慮しつつ，各カテゴリについて，スコアの上位[MATH]個のインスタンスを獲得し（[REF_exclusive_g]行目から[REF_end_exclusive_g]行目），[MATH]として出力する．
既に説明したように，提案手法はインスタンスが兄弟グループに共通の特徴を持っているか否かをフィルタパターンを用いて判定する．
この節ではフィルタパターンの獲得方法について述べる．
フィルタパターンの獲得は候補の抽出とランキングの2つのステップからなる．
候補の抽出では，兄弟グループのシードインスタンスと共起しているパターンを集める．
例えば，自動車と自動二輪カテゴリからなる兄弟グループに対し，自動車か自動二輪カテゴリに含まれるシードインスタンスと共起しているパターンを抽出する．
フィルタパターンは兄弟グループの特定のカテゴリのインスタンスを取得するためのものではなく，兄弟グループに無関係のインスタンスを除去するためのものであるため，兄弟グループに共通の特徴をとらえていることが望ましい．
しかし，インスタンスとの係り受け関係の向きや，助詞や副詞など構成する語を厳密に指定する形式にしてしまうと，正解インスタンスまで取り除いてしまう可能性もある．
このため，フィルタパターンは係り先，係り元といった係り受け関係の向きを考慮せず，さらに名詞と動詞に限定する．
すなわち，フィルタパターンはEspressoアルゴリズムやg-Espressoで用いたパターンとは異なり，「乗る」や「エンジン」，「愛車」などの，インスタンスと係り受け関係にある文節に出現する名詞や動詞とする．
候補のランキングでは，抽出された候補の中からフィルタパターンとして最適なものを選択する．
兄弟グループに含まれる意味カテゴリのインスタンスが獲得されるには，フィルタパターンと共起する必要がある．
そのため，兄弟グループに属するインスタンスとできるだけ多く共起するようなフィルタパターンが適している．
また，フィルタパターンによって，インスタンスが兄弟グループに共通の特徴を保有しているかどうかを検証するため，兄弟グループ内のカテゴリに均等に出現するようなフィルタパターンが適している．
この2つの要素をそれぞれ網羅性と平等性として定式化し，これにもとづいてフィルタパターンの選択を行う．
フィルタパターンは兄弟グループに属する正しいインスタンスを網羅するようなものであることが望ましい．
そのため，兄弟グループ中の多くのシードインスタンスと共起しているパターンが適している．
例として，自動車と自動二輪カテゴリのフィルタパターンについて考える（図[REF_fig:properties_filter_pattern]）．
図[REF_fig:properties_filter_pattern]において，パターンは斜体で表されている．
また，パターンの下の四角で覆われた枠内の文字はシードインスタンスであり，特にパターンと共起しているものは太字で示してある．
この図の(a)において，パターン「乗る」は「マイナーチェンジ」よりも多くのシードインスタンスと共起しているため，よりフィルタパターンに適していると考える．
この要素を網羅性と呼び，[MATH]という指標で測定する．
ある兄弟グループ[MATH]に属するパターン[MATH]の[MATH]は次の式([REF_recall])を用いて計算する．
\mathit{Coverage}(S_{j}, f) = \frac_{c \in S_{j}} \sum_{i \in I_{c}}\mathit{cooccur}(f, i)_{c \in S_{j}}|I_{c}|
\mathit{cooccur}(f, i) = \left{
{ll} 1 & \text{[MATH]と[MATH]が共起している場合}
0 & \text{それ以外}
\right.
[MATH]はカテゴリ[MATH]のシードインスタンス集合であり，[MATH]はカテゴリ[MATH]のシードインスタンスの数である．
[MATH]はインスタンス[MATH]がパターン[MATH]と共起しているか否かを表しており，共起しているなら1を，していなければ0を返す関数である．
よって，[MATH]はカテゴリ[MATH]に属し，かつパターン[MATH]と共起しているシードインスタンスの数を表す．
さらに，フィルタパターンはインスタンスが兄弟グループに共通の特徴を保有しているかどうかを検証するためのものであるため，特定のカテゴリに偏って出現しているパターンは不適当である．
したがって，パターンは兄弟グループ内のカテゴリのうち，2つ以上で出現していなければならないとする．
図[REF_fig:properties_filter_pattern]の(b)において，「エンジン」というパターンは自動車と自動二輪の両方のカテゴリのインスタンスと共起しているが，「トヨタ」は自動車カテゴリのみでしか出現していない．
このため「トヨタ」はフィルタパターンとしては不適当とし，候補から除去する．
また，図[REF_fig:properties_filter_pattern]の(b)では「乗る」というパターンは両方のカテゴリのインスタンスと均等に共起しているため，「エンジン」よりもフィルタパターンとして適している．
この，パターンが兄弟グループ内のそれぞれのカテゴリのインスタンスと，どれだけ均等に共起するかという要素を平等性と呼ぶ．
兄弟グループ内のあるカテゴリのインスタンスとパターンが共起するとき，パターンがそのカテゴリに出現したと定義すれば，平等性は兄弟グループ内での，パターンがどのカテゴリに出現するかの分散の大きさと言える．
このため，平等性は情報量([MATH])を用いて測定できる．
ある兄弟グループ[MATH]に属するパターン[MATH]の[MATH]は次の式([REF_entropy])を用いて計算する．
\mathit{Entropy}(S_{j}, f) = - \sum_{c \in S_{j}} P_c(f) \log_{|C|} P_c(f)
P_c(f) = \frac_{i \in I_{c}}\mathit{cooccur}(f, i)_{c \in S_{j}}\sum_{i \in I_{c}}\mathit{cooccur}(f, i)
[MATH]はパターン[MATH]の出現しているカテゴリの数である．
もしパターン[MATH]が兄弟グループ内のそれぞれのカテゴリのインスタンスと均等に共起したとすると，[MATH]は最も高い値(1.0)となる．
網羅性と平等性の両方の観点において優れているパターンを獲得するため，パターン[MATH]のスコアを次の式([REF_equ:filtering-score])を用いて計算する．
各兄弟グループ[MATH]の候補パターン[MATH]について[MATH]を計算し，兄弟グループに共通の特徴を特に表していると考えられる，上位15個を兄弟グループのフィルタパターンとして獲得する．
なお，兄弟グループが他の兄弟グループへ意味ドリフトしてしまうことを防ぐため，兄弟グループ間は排他関係にあるとする．
そのため，複数の兄弟グループで候補となっているフィルタパターンについては，属する兄弟グループをただ1つ決めなければならない．
この決定はフィルタパターンの出現頻度にもとづいて行う．
すなわち，兄弟グループ内のシードインスタンスとの共起頻度の和をフィルタパターンの兄弟グループ内での出現頻度とし，これが最大である兄弟グループにのみフィルタパターンは属するとする．
これにより，それぞれの兄弟グループに固有のフィルタパターンが得られる．
このフィルタパターンを用いることで，兄弟グループに共通の特徴を持たない，無関係なインスタンスを除去できる．
