Espresso [CITE]は，パターンの取得とインスタンスの取得の2つのステップを反復する集合拡張アルゴリズムである．
パターンの取得とインスタンスの取得は共に，コーパスからの候補の抽出と，候補のランキングという同じ手順にもとづいている．
候補の抽出では既に獲得したインスタンスと共起するパターン，既に獲得したパターンと共起するインスタンスを抽出する．
候補のランキングでは候補インスタンス／パターンのスコアを計算し，上位[MATH]個の候補を採用する．
Espressoアルゴリズムでは候補パターン[MATH]のスコア[MATH]と候補インスタンス[MATH]のスコア[MATH]を，それぞれ式([REF_eq:score1])と式([REF_eq:score2])で計算する．
r_\pi(p) = \frac{1}{|I|} \sum_{i \in I}\frac(i,p)\pmir_\iota(i)
r_\iota(i) = \frac{1}{|P|} \sum_{p \in P}\frac(i,p) \max\pmi r_\pi(p)
\pmi(i,p) = \log_2 \left(\frac{|i,p|}{|i,*||*,p|} \times\text{discounting factor}\right)
\text{discounting factor} = \frac{|i,p|}{|i,p| + 1} \times\left(\frac\left(|i,*|,|*,p|\right)\left(|i,*|,|*,p|\right) + 1\right)
[MATH]と[MATH]は各カテゴリにおけるパターンとインスタンスの集合である．
[MATH]と[MATH]はそれぞれ集合[MATH]と[MATH]に含まれるパターンとインスタンスの数である．
[MATH]と[MATH]はインスタンス[MATH]とパターン[MATH]のコーパス中での出現頻度であり，[MATH]はインスタンス[MATH]とパターン[MATH]の共起頻度である．
すなわち，式([REF_eq:pmi])における右辺第1項はインスタンス[MATH]とパターン[MATH]の自己相互情報量である．
自己相互情報量は単語間の相関の指標として一般的であるが，めったに出現しない単語に対して値が大きくなってしまうという問題がある．
これに対処するため，PantelとRavichandranは式([REF_eq:discounting])に示されるdiscounting factorを導入した[CITE]．
また，max pmiはカテゴリ内のすべてのインスタンスとパターンのpmiの最大値である．
なお，初期値としてシードインスタンスのスコアは1.0とする．
Espressoアルゴリズムの動作を説明する．
始めに，シードインスタンスと共起するパターンを候補として抽出する．
次に，式([REF_eq:score1])で候補パターンのスコアを計算し，上位[MATH]個のパターンを獲得することで，対象とする意味カテゴリに対応するパターンを獲得する．
インスタンスの獲得については，獲得したパターンと式([REF_eq:score2])を用い，上記の手順をパターンとインスタンスを逆にして行うことで達成する．
すなわち，獲得したパターンと共起するインスタンスを候補として抽出し，式([REF_eq:score2])で高スコアのパターンとよく共起するインスタンスを獲得する．
ブートストラッピング手法においてシードとは無関係なインスタンスを獲得してしまい，対象とするカテゴリから逸脱してしまう現象を意味ドリフトと呼ぶ[CITE]．
例として，「プリウス」や「レクサス」をシードインスタンスとして持つ自動車カテゴリについて考える．
Espressoアルゴリズムは何回か反復を行うと「Xの性能」や「新型のX」など多くのカテゴリのインスタンスと共起するパターン（ジェネリック・パターン）を得る．
これらのパターンを用いてインスタンスの収集を行うと，「iPad」や「ThinkPad」のようなインスタンスが抽出され得る．
これらは対象とする意味カテゴリの特徴を備えておらず，シードが表そうとしている意味カテゴリとは無関係なインスタンスである．
しかしながら，これらの間違ったインスタンスを獲得してしまうことで，アルゴリズムの取得するパターンは元々の想定からかけ離れたものになってしまう．
また意味ドリフトは多義性のある語によっても引き起こされる．
例えば自動車メーカーのシードとして「サターン」や「スバル」を与えた場合，ブートストラッピング手法は「木星」や「天王星」のような星カテゴリに属するインスタンスを獲得してしまう．
これは「サターン」や「スバル」に多義性があり，自動車メーカーだけでなく天体（惑星や恒星）も表す語だからである．
小町ら[CITE]はEspressoアルゴリズムをグラフ解析の観点から分析することで，ブートストラッピング手法において，意味ドリフトが本質的には回避できない問題であることを示した．
小町ら[CITE]はEspressoアルゴリズムをグラフ解析として定式化し，さらに意味ドリフトへの対処として，グラフカーネルの適用を提案した．
彼らはまず，Espressoアルゴリズムを行列計算によって定式化した．
なお，ここではEspressoアルゴリズムにおける，毎回の反復において上位[MATH]個の候補を獲得する，というステップが省略されており，全パターンと全インスタンスにスコアを付与する形になっている．
インスタンスとパターンの共起行列を[MATH]とし，その[MATH]要素[MATH]は式([REF_eq:pmi])のpmiを用いて，
とする．
また，シードインスタンスに対応する位置の要素は1，それ以外の要素は0である，[MATH]次元のベクトルをシードベクトル[MATH]とする．
このとき，[MATH]回目の反復におけるパターンへのスコアの付与は，[MATH]を計算した後に[MATH]として正規化する操作に対応する．
同様に，インスタンスへのスコアの付与は，[MATH]を計算した後に[MATH]として正規化する操作に対応する．
したがって，[MATH]回目の反復後に得られるインスタンスのスコアベクトル[MATH]は，式([REF_eq:graph_instance])と書ける．
\boldsymbol{i_{n}} = A^{n} \boldsymbol{i_{0}}
A = \frac{1}{|I||P|}M^{T}M
[MATH]をノード集合，[MATH]を隣接行列とした重み付き無向グラフ[MATH]を考えると，反復におけるインスタンスのスコアの更新は，シードインスタンスのスコアがグラフ上を伝播していく過程と見なすことができる．
よって，グラフカーネルによりこの過程を形式化することが可能である．
小町ら[CITE]はジェネリック・パターンの影響を減らし，意味ドリフトを抑制するために，正則化ラプラシアンカーネル[CITE]を用いた．
まず，グラフ[MATH]のラプラシアン[MATH]を式([REF_eq:laplacian])によって求める．
L = D - A
[D]_{i,i} = \sum_{j}^{}[A]_{ij}
次に，正則化ラプラシアンカーネルを式([REF_eq:reg_lap])で計算する．
正則化ラプラシアンカーネルはそれぞれのノードに対し，次数に応じて接するエッジの重みを減ずる．
このため，ジェネリック・パターンの影響を低く抑えることができる．
萩原ら[CITE]はこのグラフ理論によって再定式化したEspressoアルゴリズムをg-Espressoと呼び，集合拡張において意味ドリフトを抑制する効果があることを示した．
意味ドリフトの影響を軽減するために，小町ら[CITE]や萩原ら[CITE]の手法に加え，シードインスタンス集合の洗練[CITE]，分類器の使用[CITE]，人間の判断の導入[CITE]，意味カテゴリ間の関係の活用[CITE]など様々な手法が提案されている．
Vyasらはブートストラッピング手法におけるシードインスタンスの影響を調査した[CITE]．
その結果，専門家でない人の選んだシードインスタンス集合はランダムに選択したものよりも結果が悪くなる可能性があることを示した．
また彼らは，人手で作成されたシードインスタンス集合を洗練し，集合拡張の性能を向上させる手法を提案した．
Bellareらはブートストラッピング手法のランキング時にスコア関数の代わりに分類器を使用する手法を提案した[CITE]．
分類器を用いる手法はインスタンスのランキング時にパターン以外の素性を使うためである．
SadamitsuらはBellareらの手法[CITE]を拡張し，Latent Dirichlet Allocation (LDA)から推定されるトピック情報を素性として使用する手法を提案した[CITE]．
彼らはまた，意味的に近いカテゴリの情報を与え，LDAのトピックの粒度を調整する手法も提案している[CITE]．
PennacchiottiとPantelは分類器のためのトレーニングデータを自動で収集する手法を提案した[CITE]．
しかしながら，これらの研究は複数の意味カテゴリに対して同時に集合拡張を行うことを想定しておらず，[REF_introduction]節で説明したような，意味カテゴリ間の関係知識の利用を考慮していない．
VyasとPantelは意味ドリフトの原因となったパターンを検出し，それを削除する手法を提案した[CITE]．
彼らは意味ドリフトを防ぐため，ブートストラッピング手法の反復に人間の正否判定を取り入れた．
彼らの手法では，人手によって誤りインスタンスが発見された場合，その誤りインスタンスとそれを獲得する原因となったパターンを除去する．
また，同様の誤りを防ぐため，誤りインスタンスと類似した文脈ベクトルを持つインスタンスも除去する．
彼らもカテゴリ間の関係のような事前知識は使用していない．
Curranらはブートストラッピング手法にカテゴリ間の排他制約を導入した，Mutual Exclusion Bootstrappingという手法を提案した[CITE]．
Mutual Exclusion Bootstrappingは，インスタンスやパターンの属するカテゴリはただ1つであるという制約を取り入れたものである．
複数のカテゴリに出現するインスタンスやパターンには曖昧性があり，意味ドリフトの原因になると考えられる．
そこで，曖昧性のあるインスタンスやパターンを除去することにより，彼らの手法は高い精度を達成した．
同じく排他関係を使用する手法としてCarlsonらはCoupled Pattern Learner (CPL)アルゴリズムを提案した[CITE]．
CPLアルゴリズムは意味カテゴリのインスタンス（例：自動車カテゴリのインスタンス）と関係インスタンス（例：CEO-of-Companyという関係に対する(Larry Page, Google)やCompany-acquired-Companyに対する(Google, Youtube)）を同時に収集する手法である．
CPLアルゴリズムはこれらのインスタンスを取得するために，カテゴリ間の排他関係とカテゴリ間の意味的関係（例：CEOカテゴリのインスタンスは会社カテゴリに属するインスタンスのうちいずれかのCEOである）を使用する．
しかしながら，カテゴリ間の意味的関係は関係インスタンスの取得にしか用いられておらず，意味カテゴリのインスタンスについては複数カテゴリに対する排他制約という事前知識しか用いていない．
Curranら[CITE]とCarlsonら[CITE]はどちらも事前知識としてシードインスタンスだけではなくカテゴリ間の排他関係も利用している．
しかし，意味カテゴリ間には上位下位や兄弟関係など排他関係以外の関係も存在する．
兄弟関係は共通の特徴を持つべきであるカテゴリについての知識であり，排他関係という，インスタンスが同時に属さないカテゴリに関する知識とは別種のものである．
兄弟関係についての知識はWikipediaのような既存のリソースから容易に取得することができるため，事前知識として利用しやすい．
本研究では，既存のリソースから入手できるカテゴリ間の兄弟関係に関する知識を事前知識として集合拡張に導入し，その有用性を検証する．
Espresso [CITE]は，パターンの取得とインスタンスの取得の2つのステップを反復する集合拡張アルゴリズムである．
パターンの取得とインスタンスの取得は共に，コーパスからの候補の抽出と，候補のランキングという同じ手順にもとづいている．
候補の抽出では既に獲得したインスタンスと共起するパターン，既に獲得したパターンと共起するインスタンスを抽出する．
候補のランキングでは候補インスタンス／パターンのスコアを計算し，上位[MATH]個の候補を採用する．
Espressoアルゴリズムでは候補パターン[MATH]のスコア[MATH]と候補インスタンス[MATH]のスコア[MATH]を，それぞれ式([REF_eq:score1])と式([REF_eq:score2])で計算する．
r_\pi(p) = \frac{1}{|I|} \sum_{i \in I}\frac(i,p)\pmir_\iota(i)
r_\iota(i) = \frac{1}{|P|} \sum_{p \in P}\frac(i,p) \max\pmi r_\pi(p)
\pmi(i,p) = \log_2 \left(\frac{|i,p|}{|i,*||*,p|} \times\text{discounting factor}\right)
\text{discounting factor} = \frac{|i,p|}{|i,p| + 1} \times\left(\frac\left(|i,*|,|*,p|\right)\left(|i,*|,|*,p|\right) + 1\right)
[MATH]と[MATH]は各カテゴリにおけるパターンとインスタンスの集合である．
[MATH]と[MATH]はそれぞれ集合[MATH]と[MATH]に含まれるパターンとインスタンスの数である．
[MATH]と[MATH]はインスタンス[MATH]とパターン[MATH]のコーパス中での出現頻度であり，[MATH]はインスタンス[MATH]とパターン[MATH]の共起頻度である．
すなわち，式([REF_eq:pmi])における右辺第1項はインスタンス[MATH]とパターン[MATH]の自己相互情報量である．
自己相互情報量は単語間の相関の指標として一般的であるが，めったに出現しない単語に対して値が大きくなってしまうという問題がある．
これに対処するため，PantelとRavichandranは式([REF_eq:discounting])に示されるdiscounting factorを導入した[CITE]．
また，max pmiはカテゴリ内のすべてのインスタンスとパターンのpmiの最大値である．
なお，初期値としてシードインスタンスのスコアは1.0とする．
Espressoアルゴリズムの動作を説明する．
始めに，シードインスタンスと共起するパターンを候補として抽出する．
次に，式([REF_eq:score1])で候補パターンのスコアを計算し，上位[MATH]個のパターンを獲得することで，対象とする意味カテゴリに対応するパターンを獲得する．
インスタンスの獲得については，獲得したパターンと式([REF_eq:score2])を用い，上記の手順をパターンとインスタンスを逆にして行うことで達成する．
すなわち，獲得したパターンと共起するインスタンスを候補として抽出し，式([REF_eq:score2])で高スコアのパターンとよく共起するインスタンスを獲得する．
ブートストラッピング手法においてシードとは無関係なインスタンスを獲得してしまい，対象とするカテゴリから逸脱してしまう現象を意味ドリフトと呼ぶ[CITE]．
例として，「プリウス」や「レクサス」をシードインスタンスとして持つ自動車カテゴリについて考える．
Espressoアルゴリズムは何回か反復を行うと「Xの性能」や「新型のX」など多くのカテゴリのインスタンスと共起するパターン（ジェネリック・パターン）を得る．
これらのパターンを用いてインスタンスの収集を行うと，「iPad」や「ThinkPad」のようなインスタンスが抽出され得る．
これらは対象とする意味カテゴリの特徴を備えておらず，シードが表そうとしている意味カテゴリとは無関係なインスタンスである．
しかしながら，これらの間違ったインスタンスを獲得してしまうことで，アルゴリズムの取得するパターンは元々の想定からかけ離れたものになってしまう．
また意味ドリフトは多義性のある語によっても引き起こされる．
例えば自動車メーカーのシードとして「サターン」や「スバル」を与えた場合，ブートストラッピング手法は「木星」や「天王星」のような星カテゴリに属するインスタンスを獲得してしまう．
これは「サターン」や「スバル」に多義性があり，自動車メーカーだけでなく天体（惑星や恒星）も表す語だからである．
小町ら[CITE]はEspressoアルゴリズムをグラフ解析の観点から分析することで，ブートストラッピング手法において，意味ドリフトが本質的には回避できない問題であることを示した．
小町ら[CITE]はEspressoアルゴリズムをグラフ解析として定式化し，さらに意味ドリフトへの対処として，グラフカーネルの適用を提案した．
彼らはまず，Espressoアルゴリズムを行列計算によって定式化した．
なお，ここではEspressoアルゴリズムにおける，毎回の反復において上位[MATH]個の候補を獲得する，というステップが省略されており，全パターンと全インスタンスにスコアを付与する形になっている．
インスタンスとパターンの共起行列を[MATH]とし，その[MATH]要素[MATH]は式([REF_eq:pmi])のpmiを用いて，
とする．
また，シードインスタンスに対応する位置の要素は1，それ以外の要素は0である，[MATH]次元のベクトルをシードベクトル[MATH]とする．
このとき，[MATH]回目の反復におけるパターンへのスコアの付与は，[MATH]を計算した後に[MATH]として正規化する操作に対応する．
同様に，インスタンスへのスコアの付与は，[MATH]を計算した後に[MATH]として正規化する操作に対応する．
したがって，[MATH]回目の反復後に得られるインスタンスのスコアベクトル[MATH]は，式([REF_eq:graph_instance])と書ける．
\boldsymbol{i_{n}} = A^{n} \boldsymbol{i_{0}}
A = \frac{1}{|I||P|}M^{T}M
[MATH]をノード集合，[MATH]を隣接行列とした重み付き無向グラフ[MATH]を考えると，反復におけるインスタンスのスコアの更新は，シードインスタンスのスコアがグラフ上を伝播していく過程と見なすことができる．
よって，グラフカーネルによりこの過程を形式化することが可能である．
小町ら[CITE]はジェネリック・パターンの影響を減らし，意味ドリフトを抑制するために，正則化ラプラシアンカーネル[CITE]を用いた．
まず，グラフ[MATH]のラプラシアン[MATH]を式([REF_eq:laplacian])によって求める．
L = D - A
[D]_{i,i} = \sum_{j}^{}[A]_{ij}
次に，正則化ラプラシアンカーネルを式([REF_eq:reg_lap])で計算する．
正則化ラプラシアンカーネルはそれぞれのノードに対し，次数に応じて接するエッジの重みを減ずる．
このため，ジェネリック・パターンの影響を低く抑えることができる．
萩原ら[CITE]はこのグラフ理論によって再定式化したEspressoアルゴリズムをg-Espressoと呼び，集合拡張において意味ドリフトを抑制する効果があることを示した．
意味ドリフトの影響を軽減するために，小町ら[CITE]や萩原ら[CITE]の手法に加え，シードインスタンス集合の洗練[CITE]，分類器の使用[CITE]，人間の判断の導入[CITE]，意味カテゴリ間の関係の活用[CITE]など様々な手法が提案されている．
Vyasらはブートストラッピング手法におけるシードインスタンスの影響を調査した[CITE]．
その結果，専門家でない人の選んだシードインスタンス集合はランダムに選択したものよりも結果が悪くなる可能性があることを示した．
また彼らは，人手で作成されたシードインスタンス集合を洗練し，集合拡張の性能を向上させる手法を提案した．
Bellareらはブートストラッピング手法のランキング時にスコア関数の代わりに分類器を使用する手法を提案した[CITE]．
分類器を用いる手法はインスタンスのランキング時にパターン以外の素性を使うためである．
SadamitsuらはBellareらの手法[CITE]を拡張し，Latent Dirichlet Allocation (LDA)から推定されるトピック情報を素性として使用する手法を提案した[CITE]．
彼らはまた，意味的に近いカテゴリの情報を与え，LDAのトピックの粒度を調整する手法も提案している[CITE]．
PennacchiottiとPantelは分類器のためのトレーニングデータを自動で収集する手法を提案した[CITE]．
しかしながら，これらの研究は複数の意味カテゴリに対して同時に集合拡張を行うことを想定しておらず，[REF_introduction]節で説明したような，意味カテゴリ間の関係知識の利用を考慮していない．
VyasとPantelは意味ドリフトの原因となったパターンを検出し，それを削除する手法を提案した[CITE]．
彼らは意味ドリフトを防ぐため，ブートストラッピング手法の反復に人間の正否判定を取り入れた．
彼らの手法では，人手によって誤りインスタンスが発見された場合，その誤りインスタンスとそれを獲得する原因となったパターンを除去する．
また，同様の誤りを防ぐため，誤りインスタンスと類似した文脈ベクトルを持つインスタンスも除去する．
彼らもカテゴリ間の関係のような事前知識は使用していない．
Curranらはブートストラッピング手法にカテゴリ間の排他制約を導入した，Mutual Exclusion Bootstrappingという手法を提案した[CITE]．
Mutual Exclusion Bootstrappingは，インスタンスやパターンの属するカテゴリはただ1つであるという制約を取り入れたものである．
複数のカテゴリに出現するインスタンスやパターンには曖昧性があり，意味ドリフトの原因になると考えられる．
そこで，曖昧性のあるインスタンスやパターンを除去することにより，彼らの手法は高い精度を達成した．
同じく排他関係を使用する手法としてCarlsonらはCoupled Pattern Learner (CPL)アルゴリズムを提案した[CITE]．
CPLアルゴリズムは意味カテゴリのインスタンス（例：自動車カテゴリのインスタンス）と関係インスタンス（例：CEO-of-Companyという関係に対する(Larry Page, Google)やCompany-acquired-Companyに対する(Google, Youtube)）を同時に収集する手法である．
CPLアルゴリズムはこれらのインスタンスを取得するために，カテゴリ間の排他関係とカテゴリ間の意味的関係（例：CEOカテゴリのインスタンスは会社カテゴリに属するインスタンスのうちいずれかのCEOである）を使用する．
しかしながら，カテゴリ間の意味的関係は関係インスタンスの取得にしか用いられておらず，意味カテゴリのインスタンスについては複数カテゴリに対する排他制約という事前知識しか用いていない．
Curranら[CITE]とCarlsonら[CITE]はどちらも事前知識としてシードインスタンスだけではなくカテゴリ間の排他関係も利用している．
しかし，意味カテゴリ間には上位下位や兄弟関係など排他関係以外の関係も存在する．
兄弟関係は共通の特徴を持つべきであるカテゴリについての知識であり，排他関係という，インスタンスが同時に属さないカテゴリに関する知識とは別種のものである．
兄弟関係についての知識はWikipediaのような既存のリソースから容易に取得することができるため，事前知識として利用しやすい．
本研究では，既存のリソースから入手できるカテゴリ間の兄弟関係に関する知識を事前知識として集合拡張に導入し，その有用性を検証する．
