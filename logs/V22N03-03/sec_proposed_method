本研究の目的は，要約文書の一貫性と情報の網羅性が高く，かつ要約長に柔軟な要約手法を提案することである．
要約としての一貫性と要約長への柔軟性を獲得するために文書を入れ子依存木として表現し，入れ子依存木から要約文書を生成する問題を整数計画問題として定式化することで高い情報の網羅性を持った要約生成を行う．
本節では，入れ子依存木の構築についての詳細と，ILPでの定式化について説明する．
修辞構造理論(Rhetorical Structure Theory; RST)[CITE]は，文書の談話構造を表現するために提案された理論である．
文書をEDUに分割し，連続したEDU同士（あるいは，複数のEDUをつなぎあわせたテキストスパン）を修辞関係で関連付けることで，談話構造木を構築する．
構築される木は，終端ノードがEDU，非終端ノードが子ノード間の修辞関係をラベルに持つ木構造で表現される．
図[REF_fig:rstdt]に，談話構造木の例を示す．
図において二つの非終端ノードの間に書かれているラベルがそのノード間の修辞関係である．
具体的には例示，補足，背景などの関係により，テキストスパン同士がどのような関係にあるかを表現する．
今回用いたコーパスでは合計で89種類の修辞関係が存在した．
また，修辞関係と共に各テキストスパンには核(Nuclear)か衛星(Satellite)のいずれかのラベルが付与される．
核はその修辞関係において中心的な役割を担い，衛星は補助的な役割を持つ．
例えば補足という修辞関係では，補足される方のテキストスパンが核であり，その内容を具体的に補足したテキストスパンが衛星となる．
図においては，各非終端ノードのNとSがそれぞれ核と衛星を表している．
なお，図[REF_fig:rstdt]の[MATH]のように，複数の核からなる多核(multinucleus)という性質を持った修辞関係も存在する．
Hiraoら[CITE]はRSTの木構造を変換することで依存構造に基づくDEP-DTを構築した．
DEP-DTは，EDU間の依存関係を直接表現しており，この依存木を刈り込むことで一貫性を保った要約が生成できる．
図[REF_fig:deptrees]に，図[REF_fig:rstdt]の木構造から変換されたDEP-DTと本研究で用いる文間依存木を示す．
Hiraoらの用いたDEP-DTは，EDUをノードとするものであったが，本研究では文間の関係をとらえた同時モデルのため，これを文をノードとした依存木へと変換する．
具体的には，同じ文に属するEDU集合をまとめ，文内の親となっているEDUの依存先を，その文の依存先として採用する．
依存先のEDUは他の文に属しているため，この変換規則により，文間の依存関係を持った木構造（文間依存木）を取得することができる．
次に文間依存木の各ノードとなる文に対し依存構造解析を行い，単語間の依存構造（単語間依存木）を獲得する．
以上の処理により，文書が文の係り受け木，各文内では単語の係り受け木により構成された入れ子依存木を構築する．
本研究では，この入れ子依存木から不要な単語を刈り込むことで要約文書を生成する．
入れ子依存木からの単語の削除による要約文書の生成は，整数計画問題として定式化できる．
具体的には，ある目的関数のもと，文間依存木の根付き部分木，根付き部分木中の各文は単語間依存木の（任意の）部分木となるように単語を選択することで要約を生成する．
提案手法は次の整数計画問題で定式化できる．
\text{max.} & \displaystyle\sum_{i}^n \sum_{j}^{m_i} w_{ij} z_{ij} \nonumber
\text{s.t.} & \sum_{i}^n \sum_{j}^{m_i} z_{ij} \leq L ;&
& x_{i} \geq z_{ij} ;& \forall i,j
& x_{parent}(i) \geq x_i ;& \forall i
& z_{parent}(i,j) + r_{ij} \geq z_{ij} ;& \forall i,j
& r_{ij} + z_{parent}(i,j) \leq 1 ;& \forall i,j
& \sum_{j=0}^{m_i} r_{ij} = x_i ;& \forall i
& r_{ij} \leq z_{ij} ;& \forall i,j
& \sum_{j \notin R_c(i)} r_{ij} = 0 ;& \forall i
& r_{i \text{root}(i)} = z_{i \text{root}(i)} ;& \forall i
& \sum_{j=0}^{m_i} z_{ij} \geq\text{min}(\theta, m_i) x_i ;& \forall i
& \sum_{j \in\text{sub}(i)} z_{ij} \geq x_i ;& \forall i
& \sum_{j \in\text{obj}(i)} z_{ij} \geq x_i ;& \forall i
& x_i \in{0,1} ;& \forall i
& z_{ij} \in{0,1} ;& \forall i,j
& r_i \in{0,1} ;& \forall i
[MATH]は対象とする原文書に含まれる文数であり，[MATH]は文[MATH]の単語数である．
[MATH]は単語[MATH]（[MATH]番目の文における[MATH]番目の単語）の重みである．
[MATH]は，文[MATH]を要約に含めるときに1となる決定変数であり，[MATH]は，単語[MATH]を要約に含めるときに1となる決定変数である．
目的関数は，要約に含まれた単語の重みの総和であり，この関数を最大にするように単語を選択する．
式([REF_st_length])は，要約として選択される単語数が[MATH]以下であることを保証するための制約式である．
式([REF_st_word_in])は要約に含まれていない文中の単語を要約に含めてしまうことを防ぐための制約式である．
式([REF_st_sent_dep])は文間依存木から文を選択する時に，その木構造を保つことを保証する．
これは文間依存木からは必ず根を含む根付き部分木が選択されることを意味する．
[MATH]は，文間依存木において文[MATH]の親となる文のインデックスを返す関数である．
式([REF_st_word_dep])から式([REF_st_prs_root])には決定変数[MATH]が含まれている．
[MATH]は，単語[MATH]を根とした部分木を要約文書に含める場合に1となる．
式([REF_st_word_dep])は，単語間依存木から単語を選ぶ場合，その木構造を保つことを保証する．
ただし，単語間依存木の根以外の単語[MATH]を根として部分木を抽出する場合は，その単語[MATH]には必ず親となる単語[MATH]が存在する．
その状況では[MATH]が1のまま[MATH]を0にすることが許容されなければならず，それを可能とするのが左辺第二項の[MATH]である．
なお，[MATH]は，文[MATH]に対応する単語間依存木において，単語[MATH]の親となる単語のインデックスを返す関数である．
ただし，このままでは，[MATH]と[MATH]のどちらも1である場合も許容されてしまうため，2つの変数が同時に1となることを制限するための制約式([REF_st_r_is_top])を追加する．
同様に，このままでは[MATH]のみが1となっている場合も許容されてしまう．
[MATH]が1である場合はその単語[MATH]は必ず要約に含まれなければならないため，制約式([REF_st_r_with_z])を追加することで対処する．
本研究では文[MATH]が要約に含まれる場合([MATH] = 1)は，そこから抽出される部分木は高々一つであるとしている．
そこで，式([REF_st_one_root])により，一つの文から複数の部分木（の根）が生じることを制限している．
また，文[MATH]における単語間依存木の根に相当する単語([MATH])に関しては，根付き部分木を抽出する場合，すなわち[MATH]が1であるときのみ要約に含めることを保証する必要があり，そのため制約式([REF_st_prs_root])を追加している．
冒頭で述べた通り，本研究では単語間依存木から部分木を抽出する際は，根となり得るのは文中の動詞と，単語間依存木全体の根となる単語に限っている．
そこで，それ以外の単語が根となることを防ぐことを保証するため，制約式([REF_st_only_rc])を追加する．
ここで，[MATH]は文[MATH]中で根の候補となる単語，すなわち動詞のインデックス集合を返す関数である．
式([REF_st_s_has_w])は，文（に対応する単語間依存木の部分木）を要約に含めるための最低の単語数を規定するための制約式である．
これは，単語の削除により木を刈り込むという手法の性質上，極端に短く刈ってしまうと非文になる可能性が高くなることを防ぐ目的がある．
また，要約を最適化問題としてモデル化しているので，目的関数を最大化するために要約長の限界まで単語を選択しようとして，刈り込みを無制限に許容すると，極端な例では1単語からなる部分木を選択してしまうため，それを防ぐための制約である．
式([REF_st_has_sub])は，部分木を抽出する際は必ず一つ以上の主語を含むことを保証する制約である．
同様に式([REF_st_has_obj])は，目的語を一つ以上含むことを保証する制約である．
ここで，[MATH]と[MATH]は，それぞれ文[MATH]中の単語のうち係り受けラベルが主語，目的語である単語のインデックス集合を返す関数である．
提案手法の文圧縮が単語間依存木の刈り込みに基づいている以上，その操作により非文が生成されてしまう可能性がある．
ここで，非文となる部分木の生成を避けるための二種類の追加的な制約を導入する．
一つ目の制約式は単語対に対するものである：
式([REF_st_equal])は．
単語[MATH]と単語[MATH]は必ず同時に要約に含まれることを保証する．
これは，片方だけを要約に含めてしまう場合に非文となってしまうような組に対して定義される．
具体的には，係り受けタグがPMOD  , VC である単語とその親の単語，否定詞とその親の単語，係り受けタグがSUBあるいはOBJである単語とその親となっている動詞，形容詞の比較級(JJR)あるいは最上級(JJS)とその親の単語，冠詞とその親の単語，``to''とその親の単語である．
二つ目の制約式は単語列に対するものである：
式([REF_st_span])は単語の集合に対し，集合中のいずれかの単語を要約に含めるとき，集合中の他の全ての単語も要約に含めることを保証する制約である．
具体的には，固有名詞列（品詞タグがPRP%, WP%あるいはPOSのいずれかである単語列）や，所有格とその係り先の単語，その間に含まれる全ての単語列である．
ここで，[MATH]は，単語[MATH]と，例に上げた関係にある単語インデックスの集合を返す関数である．
本研究の目的は，要約文書の一貫性と情報の網羅性が高く，かつ要約長に柔軟な要約手法を提案することである．
要約としての一貫性と要約長への柔軟性を獲得するために文書を入れ子依存木として表現し，入れ子依存木から要約文書を生成する問題を整数計画問題として定式化することで高い情報の網羅性を持った要約生成を行う．
本節では，入れ子依存木の構築についての詳細と，ILPでの定式化について説明する．
修辞構造理論(Rhetorical Structure Theory; RST)[CITE]は，文書の談話構造を表現するために提案された理論である．
文書をEDUに分割し，連続したEDU同士（あるいは，複数のEDUをつなぎあわせたテキストスパン）を修辞関係で関連付けることで，談話構造木を構築する．
構築される木は，終端ノードがEDU，非終端ノードが子ノード間の修辞関係をラベルに持つ木構造で表現される．
図[REF_fig:rstdt]に，談話構造木の例を示す．
図において二つの非終端ノードの間に書かれているラベルがそのノード間の修辞関係である．
具体的には例示，補足，背景などの関係により，テキストスパン同士がどのような関係にあるかを表現する．
今回用いたコーパスでは合計で89種類の修辞関係が存在した．
また，修辞関係と共に各テキストスパンには核(Nuclear)か衛星(Satellite)のいずれかのラベルが付与される．
核はその修辞関係において中心的な役割を担い，衛星は補助的な役割を持つ．
例えば補足という修辞関係では，補足される方のテキストスパンが核であり，その内容を具体的に補足したテキストスパンが衛星となる．
図においては，各非終端ノードのNとSがそれぞれ核と衛星を表している．
なお，図[REF_fig:rstdt]の[MATH]のように，複数の核からなる多核(multinucleus)という性質を持った修辞関係も存在する．
Hiraoら[CITE]はRSTの木構造を変換することで依存構造に基づくDEP-DTを構築した．
DEP-DTは，EDU間の依存関係を直接表現しており，この依存木を刈り込むことで一貫性を保った要約が生成できる．
図[REF_fig:deptrees]に，図[REF_fig:rstdt]の木構造から変換されたDEP-DTと本研究で用いる文間依存木を示す．
Hiraoらの用いたDEP-DTは，EDUをノードとするものであったが，本研究では文間の関係をとらえた同時モデルのため，これを文をノードとした依存木へと変換する．
具体的には，同じ文に属するEDU集合をまとめ，文内の親となっているEDUの依存先を，その文の依存先として採用する．
依存先のEDUは他の文に属しているため，この変換規則により，文間の依存関係を持った木構造（文間依存木）を取得することができる．
次に文間依存木の各ノードとなる文に対し依存構造解析を行い，単語間の依存構造（単語間依存木）を獲得する．
以上の処理により，文書が文の係り受け木，各文内では単語の係り受け木により構成された入れ子依存木を構築する．
本研究では，この入れ子依存木から不要な単語を刈り込むことで要約文書を生成する．
入れ子依存木からの単語の削除による要約文書の生成は，整数計画問題として定式化できる．
具体的には，ある目的関数のもと，文間依存木の根付き部分木，根付き部分木中の各文は単語間依存木の（任意の）部分木となるように単語を選択することで要約を生成する．
提案手法は次の整数計画問題で定式化できる．
\text{max.} & \displaystyle\sum_{i}^n \sum_{j}^{m_i} w_{ij} z_{ij} \nonumber
\text{s.t.} & \sum_{i}^n \sum_{j}^{m_i} z_{ij} \leq L ;&
& x_{i} \geq z_{ij} ;& \forall i,j
& x_{parent}(i) \geq x_i ;& \forall i
& z_{parent}(i,j) + r_{ij} \geq z_{ij} ;& \forall i,j
& r_{ij} + z_{parent}(i,j) \leq 1 ;& \forall i,j
& \sum_{j=0}^{m_i} r_{ij} = x_i ;& \forall i
& r_{ij} \leq z_{ij} ;& \forall i,j
& \sum_{j \notin R_c(i)} r_{ij} = 0 ;& \forall i
& r_{i \text{root}(i)} = z_{i \text{root}(i)} ;& \forall i
& \sum_{j=0}^{m_i} z_{ij} \geq\text{min}(\theta, m_i) x_i ;& \forall i
& \sum_{j \in\text{sub}(i)} z_{ij} \geq x_i ;& \forall i
& \sum_{j \in\text{obj}(i)} z_{ij} \geq x_i ;& \forall i
& x_i \in{0,1} ;& \forall i
& z_{ij} \in{0,1} ;& \forall i,j
& r_i \in{0,1} ;& \forall i
[MATH]は対象とする原文書に含まれる文数であり，[MATH]は文[MATH]の単語数である．
[MATH]は単語[MATH]（[MATH]番目の文における[MATH]番目の単語）の重みである．
[MATH]は，文[MATH]を要約に含めるときに1となる決定変数であり，[MATH]は，単語[MATH]を要約に含めるときに1となる決定変数である．
目的関数は，要約に含まれた単語の重みの総和であり，この関数を最大にするように単語を選択する．
式([REF_st_length])は，要約として選択される単語数が[MATH]以下であることを保証するための制約式である．
式([REF_st_word_in])は要約に含まれていない文中の単語を要約に含めてしまうことを防ぐための制約式である．
式([REF_st_sent_dep])は文間依存木から文を選択する時に，その木構造を保つことを保証する．
これは文間依存木からは必ず根を含む根付き部分木が選択されることを意味する．
[MATH]は，文間依存木において文[MATH]の親となる文のインデックスを返す関数である．
式([REF_st_word_dep])から式([REF_st_prs_root])には決定変数[MATH]が含まれている．
[MATH]は，単語[MATH]を根とした部分木を要約文書に含める場合に1となる．
式([REF_st_word_dep])は，単語間依存木から単語を選ぶ場合，その木構造を保つことを保証する．
ただし，単語間依存木の根以外の単語[MATH]を根として部分木を抽出する場合は，その単語[MATH]には必ず親となる単語[MATH]が存在する．
その状況では[MATH]が1のまま[MATH]を0にすることが許容されなければならず，それを可能とするのが左辺第二項の[MATH]である．
なお，[MATH]は，文[MATH]に対応する単語間依存木において，単語[MATH]の親となる単語のインデックスを返す関数である．
ただし，このままでは，[MATH]と[MATH]のどちらも1である場合も許容されてしまうため，2つの変数が同時に1となることを制限するための制約式([REF_st_r_is_top])を追加する．
同様に，このままでは[MATH]のみが1となっている場合も許容されてしまう．
[MATH]が1である場合はその単語[MATH]は必ず要約に含まれなければならないため，制約式([REF_st_r_with_z])を追加することで対処する．
本研究では文[MATH]が要約に含まれる場合([MATH] = 1)は，そこから抽出される部分木は高々一つであるとしている．
そこで，式([REF_st_one_root])により，一つの文から複数の部分木（の根）が生じることを制限している．
また，文[MATH]における単語間依存木の根に相当する単語([MATH])に関しては，根付き部分木を抽出する場合，すなわち[MATH]が1であるときのみ要約に含めることを保証する必要があり，そのため制約式([REF_st_prs_root])を追加している．
冒頭で述べた通り，本研究では単語間依存木から部分木を抽出する際は，根となり得るのは文中の動詞と，単語間依存木全体の根となる単語に限っている．
そこで，それ以外の単語が根となることを防ぐことを保証するため，制約式([REF_st_only_rc])を追加する．
ここで，[MATH]は文[MATH]中で根の候補となる単語，すなわち動詞のインデックス集合を返す関数である．
式([REF_st_s_has_w])は，文（に対応する単語間依存木の部分木）を要約に含めるための最低の単語数を規定するための制約式である．
これは，単語の削除により木を刈り込むという手法の性質上，極端に短く刈ってしまうと非文になる可能性が高くなることを防ぐ目的がある．
また，要約を最適化問題としてモデル化しているので，目的関数を最大化するために要約長の限界まで単語を選択しようとして，刈り込みを無制限に許容すると，極端な例では1単語からなる部分木を選択してしまうため，それを防ぐための制約である．
式([REF_st_has_sub])は，部分木を抽出する際は必ず一つ以上の主語を含むことを保証する制約である．
同様に式([REF_st_has_obj])は，目的語を一つ以上含むことを保証する制約である．
ここで，[MATH]と[MATH]は，それぞれ文[MATH]中の単語のうち係り受けラベルが主語，目的語である単語のインデックス集合を返す関数である．
提案手法の文圧縮が単語間依存木の刈り込みに基づいている以上，その操作により非文が生成されてしまう可能性がある．
ここで，非文となる部分木の生成を避けるための二種類の追加的な制約を導入する．
一つ目の制約式は単語対に対するものである：
式([REF_st_equal])は．
単語[MATH]と単語[MATH]は必ず同時に要約に含まれることを保証する．
これは，片方だけを要約に含めてしまう場合に非文となってしまうような組に対して定義される．
具体的には，係り受けタグがPMOD  , VC である単語とその親の単語，否定詞とその親の単語，係り受けタグがSUBあるいはOBJである単語とその親となっている動詞，形容詞の比較級(JJR)あるいは最上級(JJS)とその親の単語，冠詞とその親の単語，``to''とその親の単語である．
二つ目の制約式は単語列に対するものである：
式([REF_st_span])は単語の集合に対し，集合中のいずれかの単語を要約に含めるとき，集合中の他の全ての単語も要約に含めることを保証する制約である．
具体的には，固有名詞列（品詞タグがPRP%, WP%あるいはPOSのいずれかである単語列）や，所有格とその係り先の単語，その間に含まれる全ての単語列である．
ここで，[MATH]は，単語[MATH]と，例に上げた関係にある単語インデックスの集合を返す関数である．
