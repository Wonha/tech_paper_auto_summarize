提案手法では，Salient Referent List[CITE]に基づく文脈的素性を導入し，単語や品詞，係り受けなどの伝統的に利用されている素性と組合わせる．
これらの素性はひとつの木構造として表現され，ブースティングに基づく分類アルゴリズムに渡される．
本手法における処理の流れは次の通りである．
テキストに出現する固有表現の組が入力され，(1)形態素解析や固有表現抽出，係り受け解析を行なう基盤解析部，(2)提案する文脈的素性や係り受けなどに基づく素性を抽出する素性抽出部，(3)抽出された素性に基づいて正例と負例に分ける分類部を通り，入力された固有表現の組が意味的関係を有するか否かを判定した結果を出力する．
ここでは，文脈的素性の基本的な考え方と関係性判定に利用する具体的な素性について説明する．
異なる文に出現する固有表現の組が意味的関係を有するということは，与えられた固有表現の組のうち，先に出現する固有表現が，後に出現する固有表現を含む文において「文脈的に参照され易い」ことを意味する．
例えば，例1のテキストにおいて，「ケン⇔アメリカ」の組は先に出現する「ケン」が後に出現する「アメリカ」を含む文において文脈的に参照され易い（実際にガ格ゼロ代名詞の先行詞である）ため『ケンがアメリカに渡る』という意味的関係を持つが，「ナオミ⇔アメリカ」の組の場合は文脈的に参照されにくいため意味的関係を持たない．
（例1）明日、[MATH]は大阪を訪れ、ナオミと会う。
\phantom{（例1）}その後（[MATH]ガ）アメリカに渡りトムと旅行する。
以上のことから，与えられた固有表現の組のうち，先に出現する固有表現が，後側の固有表現が出現する文脈において参照されるか否かという情報を素性として用いることが意味的関係の有無を判定するのに有用であると考えられる．
本研究では，上記の情報を取得するために，ある名詞句が後続する文脈において「どの程度参照され易いか」を評価するアルゴリズムの[CITE]手法を用いる．
Nariyamaは，談話の構造と焦点の移り変わりを説明する理論であるセンタリング理論{[CITE]}を日本語ゼロ代名詞の照応解析に適用するアルゴリズムとしてSalient Referent Listとその優先規則を提案した．
このアルゴリズムは，言い換えると，ゼロ代名詞よりテキスト前方に出現した名詞句を先行詞になりやすい順に並び替えるものである．
Nariyamaのゼロ代名詞照応解析手法は，1文前の先行詞候補のみを対象としてきたセンタリング理論の考え方に対し，先行詞候補を蓄える記憶領域であるSalient Referent Listに2文以上前の候補も保持することができる．
また，この手法では，次に示す先行詞らしさの選好を用いる．
主題（``は''）{[MATH]}主語（``ガ格''）{[MATH]}間接目的（``二格''）{[MATH]}直接目的（``ヲ格''）{[MATH]}その他
この選好は，日本語は主題であるほど省略されやすく，また主題は助詞``は''を用いて記される傾向があるという知見に基づいたものである．
Salient Referent Listは上記の要素（主題，主語，間接目的，直接目的，その他）のそれぞれにスタック（後入れ先出し構造）を持ち，先行詞候補を保持する際には，ゼロ代名詞の直前まで，次の処理を繰り返す．
テキストの先頭から文の流れに沿って1つずつ先行詞候補（名詞句）を抽出し，格情報に対応するスタックにPushする．
ゼロ代名詞を補完する際は，Salient Referent Listに保持されている情報と，上に示した選好，スタックに基づき，優先度の高い候補から順にガ格，二格，ヲ格に同定する．
例1のテキストを用いて，ゼロ代名詞（{[MATH]}ガ）の照応解析時の処理の流れを示す．
まず，テキスト先頭から文の流れに沿って，ゼロ代名詞の直前までにある「明日」，「ケン」，「大阪」，「ナオミ」を，順に格助詞に対応するスタックにPushする．
結果，図{[REF_center]}のような情報がSalient Referent Listに保持される．
次に，ゼロ代名詞を補完するために，先に示した選好とスタックに基づき，1.「ケン」，2.「大阪」，3.「ナオミ」，4.「明日」と優先度の高い順に並び替える．
この並び替えによって最上位になった「ケン」をゼロ代名詞（{[MATH]}ガ）の先行詞に同定する．
固有表現間の関係性判定では，与えられた固有表現の組のうち，先に出現する固有表現が，後に出現する固有表現を含む文脈において参照され易いか否かを取得するために，上記のSalient Referent Listを利用する．
ここで，本研究においては，ゼロ代名詞を見つけ，その先行詞を同定するといった明示的な省略補完は行わないことに注意されたい．
固有表現間の関係性判定にSalient Referent Listを適用するにあたって，NariyamaアルゴリズムにおけるSalient Referent Listへの名詞句の格納処理を，「ゼロ代名詞の直前まで」ではなく，「後に出現する固有表現の直前まで」と変更する．
つまり，与えられた固有表現の組のうち，後に出現する固有表現の直前まで，次の処理を繰り返し，Salient Referent Listに名詞句を保持する．
テキストの先頭から文の流れに沿って1つずつ名詞句を抽出し，格情報に対応するスタックにPushする．
そして，Salient Referent Listに保持されている情報と，{[REF_centering]}で示した選好，スタックに基づき，優先度の高い順に並び替える．
提案手法では，先に出現する固有表現が，並び替えられた情報の中で最上位の名詞句か否かを文脈的素性として利用する．
つまり，先に出現する固有表現と並び替えによって最上位になった名詞句が一致すれば，先に出現する固有表現は，後に出現する固有表現を含む文脈において参照され易いと判断する．
この参照され易いか否かを文脈的素性として利用する．
本論文では，本素性を``SRL-T'' (Salient Referent List Top)と呼び，素性の値は，参照され易いと判断されれば1となる．
例1のテキストにおいて，「ケン⇔アメリカ」の組が与えられた時の処理の流れを示す．
テキストの先頭から文の流れに沿って，後に出現する固有表現「アメリカ」の直前までにある名詞句の「明日」，「ケン」，「大阪」，「ナオミ」を順に，格情報に対応したスタックにPushする．
結果，図{[REF_center]}のような情報がSalient Referent Listに保持される．
次に，{[REF_centering]}で示した選好とスタックに基づき，1.「ケン」，2.「大阪」，3.「ナオミ」，4.「明日」と優先度の高い順に並び替える．
ここで，先に出現する固有表現「ケン」と最上位になった名詞句「ケン」が一致するので，「ケン」は「アメリカ」を含む文脈において参照され易いと判断し，文脈的素性``SRL-T''を1とする．
一方，同テキストにおいて，「ナオミ⇔アメリカ」の組が与えられた時は，後に出現する固有表現「アメリカ」が上の例と同じため，同じ並び替え結果（1.「ケン」，2.「大阪」，3.「ナオミ」，4.「明日」）が得られる．
ここでは，先に出現する固有表現「ナオミ」と最上位になった名詞句「ケン」が一致しないので，「ナオミ」は「アメリカ」を含む文脈において参照されにくいと判断し，文脈的素性``SRL-T''を0とする．
このようにSalient Referent Listを利用した文脈的素性によって，{[REF_anaphora]}で述べた例1のテキストにおける「ケン⇔アメリカ」と「ナオミ⇔アメリカ」の意味的関係の有無を適切に判定できると期待できる．
{[REF_centering]}で述べたNariyamaのゼロ代名詞照応解析手法で用いられている選好は，日本語は主題であるほど省略されやすいという知見に基づいており，この選好によって並び替えられる名詞句は，当然主題になりやすいものが上位にくる傾向にある．
つまり，上記のようにSalient Referent Listを選好で並び替え，その最上位を用いる方法では，与えられた固有表現の組のうち，先に出現する固有表現が地名や時間などの主題になりにくい固有表現の場合，後に出現する固有表現を含む文脈において，参照されにくいと判断されることが多い．
（例2）昨日、大阪でパーティーが開かれた。
\phantom{（例2）}ケンやトムが出席した。
例えば，例2のテキストにおいて「大阪⇔ケン」の組が与えられた時，テキストの先頭から文の流れに沿って，後に出現する固有表現「ケン」の直前までにある名詞句の「昨日」，「大阪」，「パーティー」を順に，格情報に対応したスタックにPushし，図{[REF_center2]}の情報がSalient Referent Listに保持される．
そして{[REF_centering]}で示した選好とスタックに基づき，1.「パーティー」，2.「大阪」，3.「昨日」と優先度の高い順に並び替えられる．
ここで，先に出現する固有表現「大阪」と最上位になった名詞句「パーティー」が一致しないので，「大阪」は「ケン」を含む文脈において参照されにくいと判断され，文脈的素性``SRL-T''は0となる．
このように，Salient Referent Listをゼロ代名詞照応解析のための選好で並び替える方法では，地名や時間などの主題になりにくい固有表現が，後続する文脈において参照され易いか否かを判定することができない．
これはゼロ代名詞照応解析は述語の場所格や時間格などの任意格要素の補完を対象としていないからである．
そこで，地名や時間などの固有表現が，後続する文脈において参照され易いか否かを判定するために，Salient Referent Listをゼロ代名詞照応解析のための選好で並び替えず，地名や時間としてどの程度参照され易いかを素性として利用する．
本論文では，Salient Referent Listに保持された情報を，構造を持つ情報と捉え，その構造情報を固有表現間の関係性判定に用いる．
Salient Referent Listに保持された情報から構造情報を生成する方法は，まず，Salient Referent Listに保持された情報は，与えられた固有表現の組のうち，後に出現する固有表現の直前の情報であるため，生成する構造情報の根ノードを後に出現する固有表現とする．
次に，各要素（主題，主語，間接目的，直接目的，その他）ごとにスタックから最上位の名詞句をPopして，根ノードの子ノードに配置し，そして，スタックが空になるまで，名詞句を順次Popし，1つ前にPopされた名詞句の子ノードに配置する．
ここで各ノードに，どの要素の情報かを区別するため，``は''などのラベルも付与する．
提案手法では，地名や時間としてどの程度参照され易いかを得るために，生成した構造情報における二つの固有表現の最短パスの構造を文脈的素性として利用する．
本論文では，本素性を``SRL-S'' (Salient Referent List Structure)と呼ぶ．
例2のテキストの「大阪⇔ケン」の組が与えられたときの処理の流れを示す．
後に出現する固有表現「ケン」の直前までの名詞句の「昨日」，「大阪」，「パーティー」を順に，格情報に対応するスタックにPushし，図{[REF_center2]}の情報がSalient Referent Listに保持される．
このSalient Referent Listに保持された情報は，後に出現する固有表現「ケン」の直前の情報であるため，構造情報の根ノードを「ケン」とする．
次に，``主題''は情報が空のためスキップし，``主語''の最上位の名詞句「パーティー」をPopして根ノードの子ノードに要素ラベルを付与した「ガ格：パーティー」配置する．
そして，``間接目的''と``直接目的''の情報も空のためスキップし，``その他''の最上位の名詞句「大阪」をPopして根ノードの子ノードに「他：大阪」を配置する．
最後に，``その他''の名詞句「昨日」をPopして，1つ前にPopした名詞句「他：大阪」の子ノードに「他：昨日」を配置する．
生成された構造情報を図{[REF_center_str2]}を示す．
この構造において二つの固有表現「大阪⇔ケン」の最短パスの構造（図{[REF_feature2]}）を文脈的素性``SRL-S''とする．
このように，Salient Referent Listに保持された情報を構造として捉えることで，先に出現する固有表現が地名や時間の場合も，後続する文脈において参照され易いか否かが取得でき，例2のテキストにおける「大阪⇔ケン」の意味的関係の有無を適切に判定できると期待できる．
提案した2つの文脈的素性は，共に，先に出現する固有表現が，後続する文脈で参照され易いか否かを表現しているが，前者のSalient Referent Listの最上位を用いた素性``SRL-T''は，主題になりやすい人名や組織名の，後者のSalient Referent Listの構造を用いた素性``SRL-S''は，主題になりにくい地名や時間の参照され易さを示している．
Salient Referent Listの構造を用いた素性``SRL-S''でも，主題になり易い人名や組織名の参照され易さを表現することができるが，``SRL-S''は，先に出現する固有表現が保持されているスタックしか考慮しないため，例えば，先に出現する固有表現が``主語''の1番目に保持されている時，``SRL-S''は，``主題''に他の名詞句が保持されている・いないに関わらず同じ構造が素性となるが，``SRL-T''は，``主題''に他の名詞句が保持されていれば0に，``主題''に他の名詞句が保持されていなければ1になる．
このように提案した2つの素性は，常に同じ情報になるわけではない．
そこで，本論文では，{[REF_bunrui]}で後述すように，2つの文脈的素性を組み合わせる．
分類器には，構造情報を用いた研究で高精度な分類結果が報告されている構造情報を明示的に利用した分類手法を用いる．
構造情報を明示的に利用した分類手法には，Tree Kernel[CITE]やHDAG Kernel[CITE]などのカーネル法を利用した手法と，部分木を素性とするブースティングに基づく手法[CITE]などがある．
今回の実験では，比較的学習時間が短く実験が容易に行える工藤らのアルゴリズムが実装された分類器BACTを使用した．
固有表現間の関係性判定では，{[REF_tekiyou]}で提案した2つの文脈的素性と従来から用いられている固有表現間の単語や係り受けに基づく素性を，まとめてひとつの大きな木構造で表現する．
ここで，Salient Referent Listの最上位を利用した素性と固有表現間の間の単語とその品詞に基づく素性は木構造で表現されていないため，各素性を1つのノードからなる木構造とする．
そして，全ての木構造をまとめる際は，根ノードに``Root''と書かれたノードを用意して，その子ノードに各木構造を配置する．
また，どの素性に属するノードかを区別するため，各ノードに``SRL-T''などのラベルを付与した．
例えば，例2のテキストにおける「ケン⇔大阪」の組の素性をひとつの大きな木構造で表現すると図{[REF_tree]}のようになる．
この木構造を用いて，学習時には，分類に有効な規則集合（部分木）を学習し，解析時には，学習した規則集合を適用することで固有表現の組が意味的関係を有するか否かを判定する．
