本節では，MSLRパーザ・ツールキットにおけるLR表作成器の機能と特徴について詳しく説明する．
一般化LR法で用いられるLR表には，SLR (Simple LR), CLR (Canonical LR), LALR (Lookahead LR)の3種類がある．
我々のLR表作成器は，これら3種類のLR表を作成する機能を持つ．
実際の自然言語文の解析では，最も状態数の少ないLALRが用いられる場合が多い．
したがって，以後LR表といえばLALRを意味するものとする．
これらのLR表の違いの詳細については文献[CITE]を参照していただきたい．
本ツールキットにおけるLR表作成器の最も大きな特徴は，LR表に品詞間の接続制約を反映させることができる点にある．
品詞間の接続制約をLR表に反映させるということは，接続制約に違反する構文木を生成する動作をLR表からあらかじめ除去することに相当する．
このことを図[REF_fig:lalr_gra]の文法[MATH]を例に説明する．
[MATH]において，書き換え規則の右側にある数字は規則番号を表わす．
また，終端記号は品詞である．
[MATH]から通常のLR表作成アルゴリズムによって作成されたLR表を図[REF_fig:lalr_table]に示す．
但し，図[REF_fig:lalr_table]のLR表はaction部のみであり，goto部は省略されている．
今，このLR表に図[REF_fig:lalr_con]の接続表に記述された接続制約を反映させることを考える．
図[REF_fig:lalr_con]の接続表において，行列要素[MATH]が1なら[MATH]行目の品詞[MATH]と[MATH]列目の品詞[MATH]がこの順序で連接可能であることを示し，[MATH]が0なら[MATH]と[MATH]が連接不可能であることを意味する．
また，``$''は文末を表わす特殊な品詞である．
[htbp]
[htbp]
[htbp]
[MATH]では，VSを構成する品詞としてvs_5k, vs_5m, vs_5wが，VEを構成する品詞としてve_i, ve_ki, ve_maがあるので，規則(5)から，Vを構成する品詞列は[MATH]通りあることがわかる．
これに対し，図[REF_fig:lalr_con]の接続表を考慮した場合，これら9通りの品詞列のうち``vs_5k ve_ki''，``vs_5m ve_ma''，``vs_5w ve_i''の3組だけが接続制約を満たす．
したがって，これら以外の品詞列は受理すべきではない．
ここで，図[REF_fig:lalr_table]のLR表の状態[MATH]，先読み記号ve_iの欄にある[MATH]という\reactに着目する．
[MATH]は，[MATH]における規則(11)に対応した部分木を作ることを意味する(図[REF_fig:re_act])．
ところが，先読み記号がve_iであることから，``vs_5k ve_i''という品詞列に対してこの動作を実行することになるが，この品詞列は図[REF_fig:lalr_con]の接続制約に違反する．
同様に，図[REF_fig:lalr_table]において，``*''のついた動作もまた接続制約に違反する動作である．
したがって，このような動作を事前にLR表から削除しておけば，接続制約に違反する解析結果の生成を防ぐことができる．
接続制約に違反する動作をLR表から除去する方法としては，まず図[REF_fig:lalr_table]のように接続制約を考慮しないLR表を作成してから，接続制約に違反する動作をLR表から削除する方法が考えられる．
しかしながら，文法の規模が大きくなると，接続制約を考慮しないLR表の大きさが非常に大きくなるために望ましくない．
これに対して，本ツールキットでは，LR表を作成する段階で接続制約を考慮し，接続制約に違反する動作を除いたLR表を直接生成する方法を採用している．
接続制約を組み込みながらLR表を作成するアルゴリズムの詳細については文献[CITE]を参照していただきたい．
接続制約をLR表に組み込む主な利点としては以下の3つが挙げられる．
接続制約を事前に組み込んだLR表を用いて解析を行った場合，解析時には品詞間の連接可能性をチェックする必要がないので，解析時の効率を上げることができる．
接続制約に違反する構文木を生成する動作をLR表から除去することにより，LR表の状態数・動作数を大幅に減らし，メモリ使用量を小さくすることができる．
品詞間の接続制約は，接続表として記述してからLR表に組み込む代わりに，書き換え規則の細分化によって組み込むこともできる．
例えば，[MATH]の例では，規則(5)の代わりに，図[REF_fig:rules]に挙げる3つの規則を導入すれば，接続制約を満たす品詞列のみ受理することができる．
[tbp]
[MATH]
しかしながら，このように接続制約を組み込んだ文法を作成することは，規則数が組み合わせ的に増大するために望ましくない．
品詞間の接続制約は，接続表として文法とは独立に記述し，LR表を作成する段階で接続制約を組み込む方が，最終的に得られるLR表の状態数・動作数も少なく，メモリ使用量を小さくすることができる．
また，文法記述者の負担も減らすことができる．
LR表に品詞間の接続制約を組み込む効果を調べる簡単な実験を行った．
本ツールキットに付属されている日本語解析用の文法と接続表を用いて，品詞間の接続制約を組み込む場合と組み込まない場合のLR表を比較した．
使用した文法の規則数は1,408，非終端記号数は218，終端記号数は537である．
実験に使用した計算機はSun Ultra Enterprise 250 Server(主記憶2GB，CPU周波数300MHz)である．
結果を表[REF_tab:tblgen eval]に示す．
[htbp]
表[REF_tab:tblgen eval]において，「CPU時間」はLR表作成に要したCPU時間を，「状態数」は作成されたLR表の状態の数を，「動作数」は作成されたLR表の動作(\shactと\react)の数を示している．
この表から，品詞間の接続制約を組み込むことによって，状態数はほとんど変わらないが，動作数は約半分に減ることがわかる．
したがって，LR表のために必要なメモリ使用量を大幅に縮小することができる．
一方，「CPU時間」は，接続制約を考慮する場合としない場合とでそれほど大きな差は見られなかった．
一般に，接続制約を組み込む場合は，品詞間の連接可能性を調べながらLR表を作成するために，それに要する時間は長くなることが予想される．
しかしながら，接続制約に違反する無駄なアイテムが生成されなくなることから，LR表作成に要する時間が短縮される効果も生じる．
そのため，LR表作成時間が劇的に増大するわけではないことが実験的に確かめられた．
本節では，MSLRパーザの機能と特徴について概説する．
[REF_sec:introduction]節で述べたように，MSLRパーザは形態素解析と構文解析を同時に行う[CITE]．
また，形態素・構文解析結果として構文木を出力する．
例えば，図[REF_fig:lalr_gra]の文法([MATH])，図[REF_fig:lalr_con]の接続表，図[REF_fig:parser_dic]の辞書を用いたときの「あいこにたのまれた」という文の解析結果(構文木)を図[REF_fig:parse tree1]に示す．
実際には，MSLRパーザは以下のような括弧付けで表現された構文木を出力する．
\normalbaselineskip
[<S>,[<VP>,[<PP>,[<N>,[noun,あいこ]],[<P>,[postp,に]]],[<VP>,[<V>,[<VS>, [vs_5m,たの]],[<VE>,[ve_ma,ま]]],[<AX>,[<AX>,[aux,れ]],[aux,た]]]]]
\normalbaselineskip
解析結果が複数ある場合には，その中から[MATH]個の構文木をランダムに選んで出力する．
ただし，[REF_sec:pglr]項で述べるPGLRモデルを用いる場合には，構文木の生成確率の大きい上位[MATH]個の構文木を取り出すことができる．
また，[MATH]の値は起動時のオプション指定により変更できる．
[tbp]
MSLRパーザのアルゴリズムは，一般化LR法の構文解析アルゴリズムを拡張したものである．
一般化LR法が通常は品詞列を入力とするのに対して，MSLRパーザは文字列を入力とし，辞書引きによる単語分割と構文解析を同時に行う．
以下，一般化LR法とMSLRパーザの解析アルゴリズムとの違いを簡単に説明する．
MSLRパーザの解析アルゴリズムの詳細については文献[CITE]を参照していただきたい．
入力文が与えられたとき，品詞と品詞の間に位置番号をつける代わりに，図[REF_fig:mslr_posit]のように入力文の文字間に位置番号をつける．
[htb]
\phantom{位置番号}
解析が位置[MATH]まで進んだとき，位置[MATH]から始まる全ての単語を辞書引きし，その結果をスタックに登録する．
例えば，図[REF_fig:mslr_posit]の例文を図[REF_fig:parser_dic]の辞書を用いて解析した場合，位置[MATH]では``(あ,vs_5k)'',``(あ,vs_5w)'',``(あいこ,noun)''という3つの品詞付けの結果が解析スタックに登録される．
これらの品詞付けの結果は，通常の一般化LR法における多品詞語と全く同様に取り扱われる．
\shactを実行して先読み記号をスタックにプッシュする際には，その品詞を構成する文字列の一番最後の位置まで解析スタックを延ばす．
例えば，位置[MATH]でvs_5kという先読み記号(品詞)をプッシュする際には，vs_5kが位置[MATH]〜[MATH]に位置する単語「あ」の品詞であるので，スタックの先頭を位置[MATH]まで延ばす．
そして，位置[MATH]から始まる単語の辞書引き結果をもとに以後の解析を進める．
同様に，位置[MATH]でnounという品詞をプッシュする際には，nounが位置[MATH]〜[MATH]に位置する単語「あいこ」の品詞であるので，スタックの先頭を位置[MATH]まで延ばす．
以後の解析は，位置[MATH]から始まる単語の辞書引き結果をもとに進められる．
例文「あいこにたのまれた」を解析する際，形態素解析結果の候補としては以下の2つがある．
a.  (あいこ,noun)(に,postp)(たの,vs_5m)(ま,ve_ma)(れ,aux)(た,aux)
b.  (あいこ,noun)(に,vs_1)(た,aux)(の,vs_5m)(ま,ve_ma)(れ,aux)(た,aux)
文法[MATH]はb.の品詞列を受理しないが，形態素解析と構文解析を逐次的に行う方法では，形態素解析結果の候補としてa., b.ともに出力し，それぞれの品詞列に対して構文解析が試みられる．
これに対し，MSLRパーザは形態素解析と構文解析を同時に行い，文法に記述された構文的な制約で排除される形態素解析の結果を早期に取り除くことができるため，解析効率がよい．
例えば，位置[MATH]まで解析が進んだとき，「あいこ」という文字列が図[REF_fig:parse tree1]の点線で囲まれた部分木を構成することがわかっている．
このとき，位置[MATH]から始まる単語を辞書引きする際に，品詞列b.は受理されないという文法的な制約から，``(に,vs_1)''という品詞付けが適切でないことがわかる．
具体的には，位置[MATH]におけるスタックトップの状態[MATH]において，``vs_1''を先読み記号とする動作が図[REF_fig:lalr_table]のLR表に存在しないことから，``(に,vs_1)''という辞書引き結果を含む解析はこの時点で中断される．
したがって，誤りである形態素解析結果の候補b.を早期に取り除くことができる．
このことは，MSLRパーザの大きな特徴の1つである．
MSLRパーザは括弧付けによる制約を加えた文を解析することができる．
具体的には，MSLRパーザは次のような文字列を入力として，括弧付けに矛盾しない解析結果のみを出力する機能を持つ．
[*,太郎が渋谷で買った]本を借りた
この例では括弧による制約はひとつしかないが，括弧による制約は複数あってもよい．
また，複数の制約が入れ子になっても構わない．
以下に例を挙げる．
[*,太郎が[*,渋谷で買った]][*,本を借りた]
上記の入力例において，``*''は括弧で示された範囲を支配する非終端記号に特に制約がないことを表わしている．
これに対し，``*''の位置に非終端記号を指定することにより，括弧に矛盾する解析結果だけでなく，括弧で囲まれた文字列を支配する非終端記号を限定することもできる．
例えば，以下のような入力に対して，MSLRパーザは「あいこに」を支配する非終端記号が``<PP>''となる解析結果のみを出力する．
[<PP>,あいこに]たのまれた
括弧付けによる制約を取り扱う機能は，前編集によりあらかじめ部分的な制約を付加する際に利用することができる．
構文解析を完全に自動で行うのではなく，インタラクティブに人間の知識を利用しながら半自動的に構文解析を行うことは，解析精度を向上させる有効な手段のひとつである．
解析を行う前に，係り受けに関する部分的な制約をうまく人手で与えれば，構文的曖昧性を激的に減らすことができ，結果として構文解析の精度を飛躍的に向上させることが期待できる．
PGLRモデル[CITE]は，一般化LR法の枠組に基づいて構文木の生成確率を与える確率モデルである．
PGLRモデルにおける構文木の生成確率は，構文木を作り出す際に実行されるLR表上の動作(\shactもしくは\react)の実行確率の積として推定される．
この生成確率は，生成される複数の構文木の中から最も正しい構文木を選択する構文的曖昧性解消に利用できる．
ここで注意すべき点は，PGLRモデルによって与えられる構文木の生成確率は品詞を葉とする構文木の生成確率だということである．
すなわち，単語の導出確率や単語の共起関係などの語彙的な統計情報は考慮されていない．
LR表の動作の実行確率には若干の文脈依存性が反映されていると考えられる．
したがって，PGLRモデルは，文脈自由な言語モデルである確率文脈自由文法よりも推定パラメタ数は多くなるが，文脈依存性が考慮されたより精密なモデルを学習することが可能であり，構文的曖昧性解消の精度も向上することが実験的にも確かめられている[CITE]．
本ツールキットでは，PGLRモデルを学習する機能，及びPGLRモデルによる構文木の生成確率を計算する機能を備えている．
以下，それぞれの機能の概要について説明する．
PGLRモデルの学習は，LR表上の各動作の実行確率を推定することにより行われる．
動作の実行確率の推定に必要なものは，構文木が付与された構文木付きコーパスである．
まず，例文に付与された構文木に対して，構文木を生成する際に実行するLR表上の動作の使用回数[MATH]を数え上げる．
ここで，[MATH]はLR表における状態を，[MATH]は先読み記号を，[MATH]は動作を表わし，[MATH]は，状態が[MATH]で先読み記号が[MATH]のときに動作[MATH]が実行された回数を表わす．
LR表上の各動作の実行確率は式([REF_eq:act_prob1])([REF_eq:act_prob2])によって推定する．
式([REF_eq:act_prob1])([REF_eq:act_prob2])において，[MATH]は\shact直後に到達する状態の集合，[MATH]はそれ以外の状態の集合を表わす．
LR表における全ての状態は[MATH]または[MATH]のどちらか一方に必ず属する．
図[REF_fig:lalr_table]のLR表の例では，[MATH], [MATH]である．
初期状態[MATH]は[MATH]に属することに注意していただきたい．
式([REF_eq:act_prob1])は，[MATH]のときには，状態[MATH]で実行されうる全ての動作で実行確率を正規化することを意味する．
言い換えれば，LR表における同じ行に属する動作の実行確率の和は1となる．
例えば，図[REF_fig:lalr_table]のLR表の状態[MATH]にある5つの\shactは，これらの実行確率の和が1になるように正規化される．
これに対して式([REF_eq:act_prob2])は，[MATH]のときには，状態[MATH]，先読み記号[MATH]のときに実行されうる全ての動作で実行確率を正規化することを意味する．
すなわち，LR表における同じマス目に属する動作の実行確率の和は1となる．
例えば，図[REF_fig:lalr_table]のLR表の状態[MATH]，先読み記号vs_1の欄にある2つの動作([MATH])の実行確率は，これらの和が1になるように正規化される．
また，[MATH]に属する状態の場合，shift/reduceコンフリクトがない限り，その状態に属する動作の実行確率は必ず1となる．
本ツールキットにおけるPGLRモデル学習の手続きは以下の通りである．
まず，MSLRパーザは，構文解析を行う際に，LR表の各動作の使用回数を出力する機能を持っている．
さらに，[REF_sec:brackets]項で述べた括弧付けによる制約を取り扱う機能を利用し，訓練用コーパスに付与された構文木を入力として解析を行うことにより，訓練用コーパス中の構文木を生成する際に使われた各動作の使用回数[MATH]を求めることができる．
また本ツールキットには，このようにして得られた[MATH]から式([REF_eq:act_prob1])([REF_eq:act_prob2])に従って各動作の実行確率を推定し，その実行確率が付与されたLR表を作成するツールが含まれている．
このツールは，パラメタ推定の平滑化のために，LR表に登録されている全ての動作の実行回数にある一定の頻度を加える機能を備えている．
MSLRパーザは，解析結果となる構文木とそのPGLRモデルに基づく生成確率を同時に出力することができる．
また，生成確率の高い順に構文木を並べて出力することができる．
すなわち，PGLRモデルに基づく生成確率を用いた解析結果の優先順位付けを行うことができる．
MSLRパーザは，まず文法が受理する全ての解析結果を求め，それらをまとめた圧縮統語森を生成する．
次に，この圧縮統語森を展開して個々の構文木を出力する際に，PGLRモデルに基づく構文木の生成確率を考慮し，生成確率の上位の構文木から優先して出力する．
解析の途中で生成確率の低い部分木を除去するなどの枝刈りを行っていないため，生成確率の上位[MATH]位の構文木が必ず得られることが保証される代わりに，長文など構文的曖昧性が非常に多い文を解析する際にメモリ不足によって解析に失敗する可能性も高い．
したがって，我々は解析途中で生成確率の低い部分木を除去して探索空間を絞り込む機構も必要であると考えている．
SornlertlamvanichはPGLRモデルを利用した効率の良い枝刈りのアルゴリズムを提案しているが[CITE]，現在公開しているMSLRパーザには実装されていない．
本項では，MSLRパーザを用いた簡単な日本語文解析実験について報告する．
実験用コーパスとして，ATRが作成した日本語対話コーパス[CITE]を使用した．
実験に用いた文法は，対話文解析用の文脈自由文法で，非終端記号数172，終端記号数441，規則数は860である[CITE]．
今回の実験では，日本語対話コーパス約20,000文のうち，上記の文法による構文木が付与された例文10,020文を使用した．
辞書及び接続表は，これら10,020文から自動的に作成した．
評価用テキストとして，単語数4〜14，15以上の文をランダムに1000文ずつ取り出し，それぞれSet A, Set Bとした．
これらの評価用例文について，分かち書きされていない文字列を入力とし，MSLRパーザを用いて形態素・構文解析を行った．
また，評価用テキスト以外の例文約9000文からPGLRモデルを学習し，そのPGLRモデルに基づく構文木の生成確率によって解析結果の順位付けを行った．
使用した計算機は，[REF_sec:tblgen exam]項の実験と同じSun Ultra Enterprise 250 Serverである．
実験結果を表[REF_tab:exp parser1], [REF_tab:exp parser2]に示す．
また，解析結果の具体例を付録[REF_sec:appendix]に示す．
[tbp]
[tbp]
表[REF_tab:exp parser1]において，「平均解析木数」は1文あたりに生成される構文木の平均であり，「平均解析時間」は1文の解析に要した時間(単位はミリ秒)の平均を表わしている．
Set Aのような短い文の場合は7ミリ秒程度，Set Bのような長めの文の場合でも27ミリ秒程度で解析を行うことができる．
また，表[REF_tab:exp parser2]の【形態素解析の文正解率】は，PGLRモデルに基づく構文木の生成確率の上位[MATH]位の解析結果の中に，単語分割と品詞付けの結果がコーパスに付加されたものと一致する構文木が含まれる文の割合を表わしている．
同様に【構文解析の文正解率】は，上位[MATH]位の解析結果の中にコーパスに付加されたものと一致する構文木が含まれる文の割合を示している．
この表から，例えば生成確率の1位の構文木について，Set Aでは約80%，Set Bでは約36%の文に対して正しい形態素・構文解析結果が得られたことがわかる．
今回の実験で使用したコーパスがドメインの限られたコーパスであり，また辞書と接続表を評価用テキストと訓練用テキストの両方を用いて作成したこともあり，比較的良い結果が得られている．
