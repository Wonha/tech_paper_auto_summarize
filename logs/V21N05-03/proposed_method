図[REF_fig:flow]に示すように，事後並べ替えによる機械翻訳方式[CITE]は2つのステップに分けられる．
最初のステップでは入力文をそのままの並びで出力言語文（中間言語文）へと翻訳する．
そして，次のステップにおいて中間言語文を並べ替え，出力言語の語順になった文を生成する．
文献[CITE]はこの2番目のステップを構文解析によってモデル化し，そのための学習データを次のような手順で作成している．
まず，図[REF_fig:treealign]の左図に示すように，英語文に対して語彙化構文木を作成する．
次に，主辞後置変換規則によって，図[REF_fig:treealign]の右図に示すような木（中間英語木）へと変換する．
この変換では，非終端記号に付随する主辞をその句の後方へと移動する．
例えば，左図のPP(with)[MATH]PR(with) NP(telescope)の辺では，PPの主辞となるwithはtelescopeの前に位置するが，右図ではPP[MATH]N(telescope)[MATH] PR(with)のようにtelescopeの後ろに位置する．
#は並べ替えを意味するマークである．
右図の木構造における葉ノードから成る文を中間英語文と呼ぶ．
さらに，中間英語文からは冠詞(the, a, an)が消去されており，逆に，日本語の助詞（が(ga)，は(wa)，を(wo)）が挿入されているが，これらは日本語文との単語対応をとりやすくするためである．
削除された冠詞はそれが先頭に挿入される句を表す品詞ないしは非終端記号にマークしている．
例えば，N(telescope)[MATH]である．
文献[CITE]はこのような削除した冠詞のマークを行っていないが，提案手法では削除した冠詞の挿入を構文解析の枠組みとして定式化するため，このようなマークを行っている．
#や冠詞マークを使うことで，図[REF_fig:treealign]の右図に示す中間英語木から元の英語文を復元することは可能である．
よって，中間英語木から学習した構文解析器によって，翻訳器が出力した中間英語文に中間英語木構造を自動推定することで，機械翻訳の単語並べ替えを行うことができる．
第[REF_sec:post]節で説明した単語並べ替え（及び，冠詞生成）問題は，文献[CITE]などで言及されているように，Inversion trasduction文法(ITG) [CITE]と関連付けられる．
本来，ITGは2言語の構文解析(biparsing)を扱う枠組みであるが，単語並べ替え問題を扱う場合，1言語の構文解析として定式化する点に注意する（単一言語のITG）．
単一言語のITG [MATH]は[MATH]から成る．
ここで[MATH]は非終端記号，及び，品詞の集合，[MATH]は終端記号の集合，[MATH]は生成規則の集合，[MATH]は冠詞挿入(``the''，``a/an''，``no article'')を行う非終端記号及び品詞の候補集合，TOPは開始記号である．
生成規則の集合[MATH]は
の形式を持つ規則から構成される([MATH]，X, X[MATH], Y, Z[MATH])．
最初の規則は単語[MATH]を生成する語彙生成規則，次の2つは2分生成規則，最後は終了規則である．
単一言語のITGに対するシフトリデュース構文解析法を定義する．
本稿で用いる記法は，文献[CITE]や[CITE]を参考にしているため，以下の定義を読解する上で，それらを参考にすると良いだろう．
シフトリデュース構文解析は状態とアクションを使って解析を進める．
基本的な動作原理は，まず，入力文[MATH]をバッファ[MATH]に積み込み（慣習に従い，左端が先頭），シフトと呼ばれるアクションによって，バッファの先頭単語に語彙生成規則を適用して，状態が持つスタックの先頭へと移す．
そして，リデュースと呼ばれるアクションを使って，状態が持つスタックの先頭2つの要素に対して2分生成規則を適用して，構文木を組み上げていく．
本稿ではさらに，挿入アクションを使って，冠詞の生成問題も同時にモデル化する．
シフトリデュース構文解析における状態[MATH]は
として定義され，[MATH]はステップ数，[MATH]はスタックを表す．
スタックは[MATH]を要素に持ち，各要素は部分解析木を表現する．
慣習に従い，スタックの要素は右端を先頭とし，各要素を[MATH]で区切る．
[MATH]はスタック先頭要素[MATH]が持つ部分解析木の左端単語の[MATH]中での位置インデックスを表し，[MATH]はバッファ[MATH]の先頭単語の[MATH]中での位置インデックスを表す．
[MATH]は予測前状態へのポインタ集合である．
予測前状態とは，現状態の[MATH]が構築される直前の状態のことであり，[MATH]はそこへのバックポインタを保持する．
[MATH]が集合となるのは，文献[CITE]の動的計画法により状態の結合が起こると，[MATH]をもう一方の状態の[MATH]へと結合するからである．
各スタックの要素は以下の部分解析木に関する変数を持つ．
ここでHとは[MATH]が持つ部分解析木のルートにある非終端記号または品詞ラベルの変数を表す．
[MATH]はHに付随する主辞単語の[MATH]中のインデックスを表す変数である，[MATH]は``the''，``a/an''，``no article''，またはnullが割り当てられる変数を示している．
[MATH]と[MATH]は部分解析木が覆う並べ替え文字列の左端と右端単語を表す変数である（解析時に並べ替えが起こったとき，[MATH]と[MATH]だけを明示的に並べ替えることに注意）．
[MATH]の要素[MATH]は[MATH]として参照する．
図[REF_fig:state]には状態の説明図を示す．
以下のアクションに関する説明が煩雑になることを防ぐため，スタック要素の定義からL, R, [MATH]は除いたが，後述する識別モデルの素性にはこれらを利用する．
LはHの左側の子供となる非終端記号，Rは右側の子供となる非終端記号，[MATH]はLに付随する主辞単語の[MATH]中の位置インデックスを表す変数である．
提案手法はシフト-X，挿入-[MATH]，リデュースMR-X，リデュースSR-X[MATH]，終了の5種類のアクションを持つ．
以下，各アクションは推論規則
を使って定義する．
条件部にはアクションの適用条件を記述し，状態[MATH]にアクションを適用すると，状態[MATH]になることを表す．
解析は初期状態[MATH]から始まり，終了アクションによって導かれる終了状態に至るまで続ける．
シフト-X:バッファの先頭単語をスタックに積み，品詞を割り当てる．
ここで[MATH]はH=X，[MATH]，[MATH]，[MATH]，[MATH]となり，単語[MATH]に品詞Xが割当られたことを意味する．
挿入-[MATH]:現在の状態が持つスタック先頭要素の部分解析木が覆う単語列の先頭に``the''，``a/an''，``no articles''のいずれか（変数[MATH]で表す）を挿入する操作を行う．
\frac{p: [\ell: \langle i, j, S|s_{0}')\rangle: \pi]}{p': [\ell+1: \langle i, j, S|s_{0}\rangle: \pi]} s_{0}'.
\text{X} \in I\wedge
(s_{0}'.
a=\text{null }||\text{ }x\neq\text{``no article''}\wedge s_{0}'.
a\neq\text{``the''}\wedge s_{0}'.
a\neq\text{``a/an''}).
ここで[MATH]はH=[MATH]H，[MATH]，[MATH]，[MATH]，[MATH]となる．
アクションの適用条件で[MATH]は現状態でまだ一度も冠詞挿入が行われていないことを意味し，``the''，``a/an''，``no article''が代入できる．
一方，すでに``no article''が挿入された位置には，条件[MATH]によって，``the''か``a/an''のみ挿入可能で，そのいずれかを挿入以後，その位置には冠詞挿入は行えない．
リデュース：リデュースMR-XとリデュースSR-X[MATH]の2種類を定義する．
これらは同じ形式の推論規則で表記できる．
リデュースは[MATH]と[MATH]を文法規則X[MATH]Y Zによって結合し，新たなスタック要素[MATH]を作り出す．
リデュースMR-Xでは
を新たに作り出す．
新たな非終端記号はXとなり，その主辞単語は[MATH]として，Zの主辞単語の位置インデックスを代入する．
リデュースMRは非終端記号YとZが覆う2つの句をそのままの並びで結合するため，Xが覆う句の左端は[MATH]，右端は[MATH]となる．
冠詞変数は[MATH]として，Yの先頭に挿入された冠詞変数が代入される．
リデュースSR-X[MATH]はMR-Xとは逆に，文法規則X[MATH]Y ZによってYとZの句を並べ替えて結合し，新たなスタック要素
を作り出す．
新たな非終端記号はX[MATH]となり，その主辞単語はリデュースMR同様に[MATH]として，Zの主辞単語の位置インデックスを代入する．
リデュースSRは非終端記号YとZが覆う2つの句を並べ替えて結合するため，X[MATH]が覆う句の左端は[MATH]，右端は[MATH]となる．
冠詞変数は[MATH]として，Zの先頭に挿入された冠詞変数が代入される．
終了：シフトやリデュースをこれ以上適用できなくなり，終了規則が適用できる場合，
として，終了状態[MATH]を導く．
ただし，[MATH]，[MATH]とする．
終了状態[MATH]からバックトレースすることで，中間英語木，または，英語文は出力できる．
図[REF_fig:process]に解析の例を示す．
図[REF_fig:process]では，解析の過程が全て理解できるよう，スタック要素を省略せず，解析部分木を全て示した．
入力文[MATH]が与えられたとき，初期状態[MATH]から終了状態に至る状態とアクションの系列を完全アクション状態系列と呼び，
と定義すると，シフトリデュース構文解析の探索問題は以下のように定式化される．
ここで[MATH]は，[MATH]に対して解析可能な全ての完全アクション状態系列の集合を表す．
一般に，[MATH]は識別モデルによってモデル化される．
素性関数[MATH]は状態[MATH]とアクション[MATH]を素性ベクトル[MATH]へ写像する関数である，素性ベクトルは発火した素性が対応する次元に1，それ以外は0をとる．
[MATH]は重みベクトルで，素性ベクトルとの内積をスコアとする．
表[REF_tab:feats]には本稿の実験で使用した素性テンプレートを示す．
[MATH]によって結合された要素は組み合わせ素性を表し，状態[MATH]が持つ要素から全て計算される．
さらに，全ての素性は[MATH]を結合して，状態[MATH]でアクション[MATH]を行う判断をモデル化している．
例えば，図[REF_fig:process]のstep5の状態でレデュースSR-VP[MATH]アクションを行う場合，素性テンプレートの[MATH]はV[MATH]NP[MATH]N[MATH]レデュースSR-VP[MATH]という素性になり，素性関数[MATH]によって素性ベクトルの対応する次元へ写像される．
表の最も下の行は並べ替え文字列に関わる素性で，本稿ではこれらを非局所素性(non-local feature, nf)と呼ぶ．
実装上では，解析性能を高めるため，ビームサーチ[CITE]により，各ステップではスコアが上位beam個の状態をビームスタックに保持して解析を行う．
単一言語のITGに従って，ある文字列の並べ替えを行う場合，様々な導出過程から同一の並べ替え文字列を作り出すことができる．
例えば，図[REF_fig:amb]のような例である．
これは元の文``e1 e2 e3 e4''を並べ替えない場合のITG木が複数存在することを示している．
この現象をSpurious Ambiguityの問題と呼ぶ．
文献[CITE]ではSpurious Ambiguityを解消するために，左分岐重視(Left heavy)のITGを提案しているが，図[REF_fig:treealign]のような一般的な複数の非終端記号を持つ文法規則において，一意な構造に変換する方法は自明ではない．
シフトリデュース構文解析におけるビームサーチでは，Spurious Ambiguityが及ぼす問題は大きい．
なぜなら，同じ並べ替え文字列を表現した冗長な状態により，ビームスタックが無駄に消費されるからである．
実際にこのことは第[REF_sec:exp_amb]節の実験で示す．
提案法では，この問題に対応するため，2つの手法を活用する．
1つは文献[CITE]の動的計画法に基づくシフトリデュース構文解析法を適用することである．
この手法では，識別モデルの素性ベクトルが同じになる状態を結合し，ビームスタック上に不要な解を保持する必要がなくなる．
そのため，冗長な状態の多くを効率的に抑えることができる．
もう1つは並べ替え文字列を解析と同時に構築し，ハッシュテーブルによって同じ文字列を持つ状態を枝刈りする方法である．
同じステップにある状態で，並べ替え文字列とスタック要素[MATH]と[MATH]の部分木のルート非終端記号が全て一致する場合，モデルスコアの低い方の状態を削除する．
[MATH]と[MATH]のルート非終端記号を考慮するのは，解析エラーを軽減するためである．
シフトリデュース構文解析は最適解を求められる保証はないが，入力文長に対して，線形時間に動作するという利点がある．
一方で，CKY構文解析法は最適解を求めることはできるが，1次の主辞・従属辞関係を考慮した場合，最悪計算量が[MATH]に及ぶことが知られている([MATH]は入力文長，[MATH]は非終端記号の集合サイズ) [CITE]．
さらに，単一言語のITGに対して，第[REF_sec:sr]節で定義したような並べ替え単語列の左端単語[MATH]と右端単語[MATH]を特徴量（非局所素性）に考慮すると，リデュースMRに対応するCKY構文解析の推論規則は以下のようになる．
ここで[MATH]はある1つのCKYアイテムを表し，[MATH]はアイテムが表現する解析結果の左端と右端のインデックス，[MATH]は主辞のインデックスを表す．
この推論規則では，長さ[MATH]に対する9つの自由変数[MATH]，非終端記号の集合[MATH]から3つの記号X,X',X''を考慮するため，計算量は[MATH]となる．
本稿では，主辞は必ず後置することを仮定しているため，[MATH]と[MATH]はそれぞれ[MATH]と[MATH]から参照でき，計算量は[MATH]となる．
[MATH]-gramを考慮した構文解析がこのような高い計算量に及ぶことは，文献[CITE]の係り受けと品詞タグ付けの同時解析でも言及されている（品詞タグ付けの場合，連接部分の計算量は[MATH]ではなく，品詞の候補数となる）．
CKY構文解析ではあるCKYアイテムに対して，ビタビスコア[MATH]を最大にする解をボトムアップに計算していく．
\beta([i,j,\text{X''},w_{left},w_{right}']) = \max_{k,w_{right},w_{left}',\text{X},\text{X'}} ([i,k,\text{X},w_{left},w_{right}])\cdot\beta([k,j,\text{X'},w_{left}',w_{right}'])
\cdot p(\text{X''}\rightarrow\text{X}\text{X'})\cdot nf(w_{right},w_{left}').
[MATH]は規則のスコア，[MATH]は並べ替え文字列から計算される[MATH]-gramモデルなどの非局所素性に関わるスコアである．
[MATH]-gramを考慮したCKY構文解析の計算量はHook Trickと呼ばれる分配法則によってさらに削減できる[CITE]．
Hook Trickは式([REF_eq:cky])の右辺に対して，次のような式変換を行う（[MATH]演算は積に対して分配的であることに従う）．
\max_{k,w_{left}',\text{X'}}\bigl_{w_{right},\text{X}}\bigl([i,k,\text{X},w_{left},w_{right}])\cdot p(\text{X''}\rightarrow\text{X}\text{X'})\cdot nf(w_{right},w_{left}')\bigr
\cdot\beta([k,j,\text{X'},w_{left}',w_{right}'])\bigr
内部[MATH]演算では[MATH]とX,X',X''を考慮し，外部[MATH]演算では[MATH]
[MATH]とX',X''を考慮する．
これより計算量は[MATH]から[MATH]となる．
しかし，このような計算量は一般にコストが大きく，提案法と比較して，実用的ではない．
非局所素性を考慮したCKY構文解析はCube Pruningと呼ばれる近似解法[CITE]を使うと，[MATH]のCKY構文解析として解くことはできるが，最適解が求められる保証はなくなる．
これより，CKY法や同様の原理（動的計画法）に基づくBerkeley構文解析などと比較して，提案法は単語並べ替え問題において，実用性の観点から大きな利点がある．
事後並べ替え手法は須藤ら[CITE]によって提案された．
須藤らは日本語文から中間英語文への翻訳を行った後，再び機械翻訳によって中間英語文を英語文へと翻訳している．
後藤らは中間英語文から英語文への並べ替えを構文解析によって行うことで，須藤らの手法を上回る精度を達成した．
本稿でも同様に，構文解析によって事後並べ替えをモデル化した．
提案法はシフトリデュース構文解析法を基盤にしており，単語並べ替えと冠詞生成を同時に処理する仕組みや非局所素性の導入を行うことで，精度と解析効率をさらに向上させた．
これらの点から，提案法は後藤らの手法と明確に区別できる．
文献[CITE]では，機械翻訳の後編集において冠詞挿入を行うことの重要性を提唱し，英語文への冠詞挿入を決定木によって行った．
後続的にいくつかの文献で英語文への冠詞挿入を機械学習によって解く手法が提案されているが[CITE]，構文解析と冠詞挿入を同時に行う枠組みを提唱したのは，著者らの知る限り，本稿が初めてである．
提案手法で採用したシフトリデュース構文解析法は様々な文法理論の構文解析に応用されている．
例えば，依存文法[CITE]，文脈自由文法[CITE]，組み合わせ範疇文法[CITE]などへの応用がある．
シフトリデュース構文解析法を単一言語のITGへ応用した例は本稿が初めてである．
