文節を削除/選択の単位として行う文の簡約は，原文からできるだけ``良い''部分文節列を選択することであると考えることができる．
この問題を明確に定式化するためには，文節列の``良さ''を計る評価関数が必要である．
このような評価関数は，理想的には，文脈を考慮した上で原文の意味を理解し，その意味を部分文節列がどの程度保つかという観点から定められるべきものであろう．
しかし，そのような評価関数を構成することは現時点では困難である．
そもそも，文の``意味''とは何かということさえ，現時点で明確に定義づけることは困難と思われる．
そこで，本研究では，各文節の重要度と二文節間の係り受け整合度という限られた情報のみを用いて，現実的に定義や計算ができるようなアプローチを採る．
すなわち，文の簡約においては，
簡約された文が原文の持つ重要な情報をできるだけ保つこと，
簡約された文ができるだけ文法的に良い構造を持つこと．
の２つが重要であることを考慮し，ここでは，部分文節列の``良さ"を計る評価関数を，a),b)に対応した２つの評価関数の和として以下のように定義する．
まず，原文を文節列として[MATH]と表し，その中の長さ[MATH]の部分文節列[MATH]を考える．
もし，各文節[MATH]の重要度を表す関数[MATH]が与えられているとすると，この部分文節列の重要度はそれらの総和[MATH]で計ることができよう．
もちろん，他の定義も可能であるが，ここでは，これを部分文節列の重要度を計る評価関数として採用する．
また，文節[MATH]が文節[MATH]に係るときの係り受け整合度[MATH]が与えられているとすると，このような係り受け整合度の総和が大きい値となる係り受け構造が存在するような文節列は，日本語文として見たとき，文法的に``良い''文節列であると考えられる．
文節列[MATH]上の係り受け構造は，係り文節番号を受け文節番号に対応させる写像
によって表される．
ただし[MATH]は
後方単一性: [MATH]
非交差性: [MATH]ならば[MATH]
を満たす必要がある．
本研究では，写像[MATH]を用いて，文節列[MATH]の文法的な``良さ''を[MATH]で定義することとする．
ここで，最大化は可能な全ての係り受け構造に対して行う．
以上のことから，本論文では文節列[MATH]の``良さ''を計る評価関数[MATH]を次のように定義する:
評価関数[MATH]を用いると，[MATH]文節からなる原文を[MATH]文節からなる文に簡約する問題は次のように述べることができる．
文簡約問題
文節列[MATH]の部分文節列[MATH] [MATH]の中で，関数[MATH]が最大になるものを求めよ．
与えられた原文の部分文節列の総数は有限である．
また，各部分文節列上の係り受け構造の総数も有限である．
したがって，上の文簡約問題は，原理的には枚挙法で解くことができるが，計算量の点で現実的でない．
本論文では，動的計画法の原理に基づき，この問題を効率的に解くアルゴリズムを導出する．
評価関数[MATH]の定義には，文節重要度[MATH]と係り受け整合度[MATH]の２つの関数が含まれている．
これらの関数をどのように定義するかは実際の応用においては重要な問題であるが，本論文ではこれについては議論しない．
しかし，文節重要度[MATH]の定め方については，例えば[CITE]のような方法が考えられ，係り受け整合度[MATH]の定め方については係り受け解析の分野で研究されている[CITE]などの方法が利用できると考えられる．
3節で導かれるアルゴリズムは，これらの関数の定義には依らない．
二文節間の係り受け整合度の総和は，従来，係り受け解析にも用いられている評価関数であり，その意味で本手法による簡約文は，係り受け整合度[MATH]が適切に設定されていれば，原文の部分的な係り受け構造を保った自然な係り受け構造を持つことが期待できる．
しかし，それにより原文の意味がどの程度保たれるかについては，最終的には人間の簡約結果と比較するなどの評価が必要となる．
本論文では，そこまでは立ち入らず，上のような評価関数を用いて問題を定式化したとき，それを現実的な計算量で解くアルゴリズムが構成できることを示すことに重点を置いている．
文簡約問題，すなわち関数[MATH]の最大化問題を解くために，その``部分解とそれらの間の関係''を考える．
まず，先頭文節を[MATH]に，末尾文節を[MATH]に，文節列長を[MATH]に固定したときの最大化を考え，その最大値を表す関数[MATH]を以下のように定義する．
{最大値関数[MATH]}
そうすると[MATH]は次の再帰式を満たすことが示される．
証明は付録とする．
{再帰式}
[MATH]のとき: ( [MATH]の動く範囲: [MATH]のみ)
[MATH]のとき: ( [MATH]の動く範囲: [MATH])
[MATH]のとき
[MATH]のとき
[MATH]のとき
再帰式は[MATH]のとき，[MATH]となる[MATH]と[MATH]の全てが既に計算されていれば，高々3つの変数に関する最大化問題を解くことにより[MATH]が計算できることを表している．
すなわち式([REF_eqn:eqn1])より，[MATH]は，入力文節の重要度から直接計算できる．
また，式([REF_eqn:eqn2])より2文節の重要度とその間の係り受け整合度の和から，[MATH]が計算できる．
これらから始めて，[MATH]のときは[MATH]を2変数[MATH]が制約条件を満たす範囲で最大化を行ない，[MATH]では3変数[MATH]が制約条件を満たす範囲で最大化を行なうという再帰的な処理によって，[MATH]を計算することができる．
以上の事実に注意すると，計算済の[MATH]の値を図[REF_fig:region]のようなテーブルの升目に順次埋めていくアルゴリズムが構成できる．
図[REF_fig:region]には[MATH]を埋める場合を示した．
再帰式によると，[MATH]の計算は，その左の領域[MATH]から[MATH]を，その下の領域[MATH]から[MATH]を選択する組合わせの中から，それぞれの持つ[MATH]の値と両者の係り受け構造間の係り受け整合度の総和が最大となるような[MATH]を探索することで行なわれていく．
このとき，係り文節[MATH]は必ず受け文節[MATH]より文頭側にあること，文節列[MATH]を簡約する場合，簡約後の部分文節列の長さは原文節の長さより大きくなることがないことから，変数には以下のような制約が課せられる．
[MATH]
[MATH]のとき[MATH]
[MATH]のとき[MATH]
これを図示したものが図[REF_fig:region2]である．
また，ここでは[MATH]を満たす任意の[MATH]に対して最適解が探索できる領域を考えているが，[MATH]の最大値[MATH]があらかじめ定まっているときは，[MATH]の動く範囲を[MATH]に制限できる．
したがって[MATH]の場合には探索領域はさらに小さくてすみ，計算量と記憶量を減らすことができる．
図[REF_fig:region]のテーブルの升目を埋める順序については，[MATH]を計算する際に[MATH]と[MATH]が制約条件の範囲で全て計算済であるという条件さえ満たしていればよいので，その順序には大きな自由度がある．
変数[MATH]を動かすとき，アルゴリズム[REF_alg:recursion]のように最外ループを[MATH]に関するループとすると，入力文節に同期した処理が可能なアルゴリズムとなる．
すなわち，文頭文節からある文節までが入力されたとき，そこまでの情報に基づいてできる計算は，それより後の文節に関係なく済ませることができる．
そして，もし必要ならば，その時点で3.3に述べるバックトレースを行い，そこまでの入力に対する簡約文を出力することができる．
また，最外ループを[MATH]に関するループとすれば，そのループの第[MATH]ステップの処理が終わった時点で，[MATH]としてバックトレースが可能になるので，文節数[MATH]から順に求めたい文節数までの簡約文を出力するアルゴリズムが構成できる．
{再帰式の実行}
\=  \=  \=  \=  \=  \=  \+ \kill
for [MATH] to [MATH]  \+
begin
for [MATH] downto [MATH] do \+
begin
if ([MATH]) then [MATH]; \` \makebox[10zw]式([REF_eqn:eqn1])
else \+
begin
for [MATH] to [MATH] do \+
begin
if ([MATH]) then [MATH] .
..
; \` \makebox[10zw]式([REF_eqn:eqn2])
else if([MATH]) then [MATH] .
..
; \` \makebox[10zw]式([REF_eqn:eqn3]a,[REF_eqn:eqn3]b)
else [MATH] .
..
; \` \makebox[10zw]式([REF_eqn:common]a, [REF_eqn:common]b, [REF_eqn:common]c)
end; \-
end; \-
end; \-
end;
アルゴリズム１の計算結果から最適部分文節列を構成することを，ここでは「バックトレース」という．
ここで用いるバックトレースの方法は[CITE]の手法に類似したものであり，形式的な証明も可能であるが，ここでは，考え方の概略とアルゴリズムを示すにとどめる．
まず「係り受け構造の分解」について述べる．
[MATH]を文節列とし，その上の係り受け構造[MATH]を考える．
[MATH]において，末尾の文節[MATH]に係る最も文頭側の文節を[MATH]とすると，[MATH]は[MATH]上の係り受け構造と[MATH]上の係り受け構造に分解できる．
ただし，[MATH]が[MATH]に係るという情報を加えておく必要がある[CITE]．
付録の証明から明らかなように，[MATH]に対する再帰式の導出においては，この事実が以下のように利用されている．
[MATH]を計算するためには，[MATH]から始まり，[MATH]で終わる長さ[MATH]の部分文節列上の係り受け構造を考慮する必要がある．
上に述べたことから，そのような係り受け構造は，[MATH]に係る最も文頭側の文節を[MATH]とするとき，[MATH]から始まり[MATH]で終わる長さ[MATH]の部分文節列上の係り受け構造と，ある文節[MATH]から始まり[MATH]で終わる長さ[MATH]の部分文節列上の係り受け構造に分解できる．
ただし，[MATH]が[MATH]に係るという情報を加えておく必要がある．
さて，再帰式の証明が示すように，[MATH]を求めるためには，評価関数[MATH]を，上のように分解した部分文節列，および係り受け構造に関して最大化すればよい．
それは，
を，[MATH]，[MATH]，[MATH]に関して最大化することに帰着する．
最大値を与えるこれらの変数の値を再び[MATH]，[MATH]，[MATH]と表せば，以上のことから，[MATH]を与える最適部分文節列[MATH]は[MATH]を与える最適部分文節列[MATH]と[MATH]を与える最適部分文節列[MATH]の連接で与えられること，また[MATH]上の最適係り受け構造は[MATH]上の最適係り受け構造と[MATH]上の最適係り受け構造を併せたものに，[MATH]が[MATH]に係るという情報を加えたものになることが分かる．
また，[MATH]の場合は[MATH]しか許されず，[MATH]を与える最適部分文節列は``[MATH]''となる．
したがって，アルゴリズム[REF_alg:recursion]の各ステップで最大値を与える[MATH]，[MATH]，[MATH]の値(最適分割点)を記憶しておけば，アルゴリズム[REF_alg:recursion]の終了後，任意の長さの簡約文と，必要ならばその上の係り受け構造を再帰的に得ることができる．
最適分割点はバックトレースのための，いわゆるバックポインタの役割を果たす．
実際の計算では，アルゴリズム[REF_alg:recursion]の各ステップにおいて最適分割点を記憶するための変数[MATH]を用意する．
最適分割点は再帰式中の場合に応じて，次のように設定される．
[MATH]は再帰式の中で最大値を与えるそれらの変数の値を表す．
{最適分割点}
[MATH]の場合
何も記憶する必要がない．
[MATH]の場合
与えられた文節列から[MATH]の範囲で任意に指定した長さ[MATH]の最適部分文節列を探索するには，まず，最も評価値の高い[MATH]を見つけることから始める．
そして，この[MATH]を出発点として，アルゴリズム[REF_alg:backtrace]で示す再帰関数を用いて最適部分文節列が得られる:
ここでは，最適分割点が一意に定まる場合を考えているが，これが複数個存在する場合には，その全てを記憶し，そのそれぞれに対して最適部分文節列を求めればよい．
異なる最適分割点から，同じ最適部分文節列が得られる可能性があるが，この場合，これらの最適部分文節列上には複数の最適係り受け構造が存在している．
{バックトレース} ([MATH]は文字列の連接を表す)
ここで，本アルゴリズムにおける最適分割点と簡約文の係り受け構造の対応について述べる．
[MATH]は文節列[MATH]を長さ[MATH]に簡約するときの最適分割点であるが，再帰式の証明(付録)からわかるように，[MATH]は簡約結果において[MATH]に係る文節の中で最も文頭側にあるものの番号である．
したがって，[MATH]は[MATH]に係ることがわかる．
これを再帰的に繰り返せば，簡約文中の全ての文節の係り先がわかる．
すなわち，アルゴリズム[REF_alg:backtrace]を用いてバックトレースを行なうとき，[MATH]ならば[MATH]であることを記憶し，まとめて出力すれば，簡約文中の全ての文節に対する[MATH]の値，つまり係り受け構造を知ることができる．
まず，アルゴリズム[REF_alg:recursion]における加算回数について考察する．
計算ステップ[MATH]における加算回数を[MATH]とすると[MATH]に対する再帰式より，次のことが容易に分かる．
\tiny
[MATH]のとき:
[MATH]のとき:
[MATH]のとき:
[MATH]のとき：
\tiny
総加算回数[MATH]は[MATH]を[MATH]，[MATH]について加え合わせたものになるが，[MATH]のときは[MATH]であり，そのとき[MATH]であるから，
となる．
詳細は省略するが，この右辺を計算すると，
が得られる．
同様の計算により，総比較演算回数[MATH]は
で与えられる．
したがって計算量のオーダは[MATH],[MATH]共に[MATH]となる．
これはかなり大きな計算量のように見えるが，最高次の係数が小さいことと[MATH]は高々40程度までを考えておけばよいことから，計算が困難なほど大きな値にはならない．
実際，[MATH]の場合，加算回数と比較演算回数は表[REF_tbl:order]で示したように，[MATH]であり，アルゴリズム[REF_alg:recursion]をCで実装しUltraSPARC-IIi(270MHz)上で処理したときの処理時間は，1秒以内である．
また，アルゴリズム[REF_alg:backtrace]の実行時間は，これに比べて無視できる程度である．
本手法の評価は今後の課題であるが，アルゴリズムの動作を示すため，文節重要度と係り受け整合度を仮に与えて実行した例を2つ示す．
簡約文の係り受け構造も[CITE]による括弧表記を用いて示している．
本アルゴリズムで必要とされる係り受け整合度は，[CITE]の係り受けペナルティに[MATH]を乗じたものとした．
ここで定義されているペナルティ関数は学習コーパス中の係り受け距離の頻度分布を元に作成されている．
また文節重要度は，
主部/述部や名詞/動詞を含む文節に形容詞や動作の程度や目的を表す文節より大きい値
文末の動詞には大きな値
形式名詞には小さな値
を人手で設定した．
この例における具体的な値を表[REF_tbl:example]に示す．
例にあげた文は[CITE]の手法で正しく係り受け解析できたものである．
簡約文の文節数[MATH]を原文の文節数[MATH]に等しく設定すると簡約文は原文そのものしかあり得ない．
したがって，その場合には本アルゴリズムは原文の係り受け解析のみを行なうことになり，その結果は[CITE]の手法によるものと一致する．
実際に簡約文を出力するためには，その長さ[MATH]を指定する必要がある．
これは，現実の場面で文章全体をどの程度に圧縮したいかという要求と簡約文の品質を考え合わせて決めるものであるが，本手法を人が文を簡約するときの支援システムとして使用する場合には[MATH]の値を順次変化させ，それに応じて得られる簡約文の中から人が適切なものを選ぶという使い方も考えられる．
また，評価関数の値を利用して，「できるだけ短く」と「できるだけ情報を保つ」という相反する要求のバランスを自動的に取ることも考えられるが，それは今後の問題である．
文節を削除/選択の単位として行う文の簡約は，原文からできるだけ``良い''部分文節列を選択することであると考えることができる．
この問題を明確に定式化するためには，文節列の``良さ''を計る評価関数が必要である．
このような評価関数は，理想的には，文脈を考慮した上で原文の意味を理解し，その意味を部分文節列がどの程度保つかという観点から定められるべきものであろう．
しかし，そのような評価関数を構成することは現時点では困難である．
そもそも，文の``意味''とは何かということさえ，現時点で明確に定義づけることは困難と思われる．
そこで，本研究では，各文節の重要度と二文節間の係り受け整合度という限られた情報のみを用いて，現実的に定義や計算ができるようなアプローチを採る．
すなわち，文の簡約においては，
簡約された文が原文の持つ重要な情報をできるだけ保つこと，
簡約された文ができるだけ文法的に良い構造を持つこと．
の２つが重要であることを考慮し，ここでは，部分文節列の``良さ"を計る評価関数を，a),b)に対応した２つの評価関数の和として以下のように定義する．
まず，原文を文節列として[MATH]と表し，その中の長さ[MATH]の部分文節列[MATH]を考える．
もし，各文節[MATH]の重要度を表す関数[MATH]が与えられているとすると，この部分文節列の重要度はそれらの総和[MATH]で計ることができよう．
もちろん，他の定義も可能であるが，ここでは，これを部分文節列の重要度を計る評価関数として採用する．
また，文節[MATH]が文節[MATH]に係るときの係り受け整合度[MATH]が与えられているとすると，このような係り受け整合度の総和が大きい値となる係り受け構造が存在するような文節列は，日本語文として見たとき，文法的に``良い''文節列であると考えられる．
文節列[MATH]上の係り受け構造は，係り文節番号を受け文節番号に対応させる写像
によって表される．
ただし[MATH]は
後方単一性: [MATH]
非交差性: [MATH]ならば[MATH]
を満たす必要がある．
本研究では，写像[MATH]を用いて，文節列[MATH]の文法的な``良さ''を[MATH]で定義することとする．
ここで，最大化は可能な全ての係り受け構造に対して行う．
以上のことから，本論文では文節列[MATH]の``良さ''を計る評価関数[MATH]を次のように定義する:
評価関数[MATH]を用いると，[MATH]文節からなる原文を[MATH]文節からなる文に簡約する問題は次のように述べることができる．
文簡約問題
文節列[MATH]の部分文節列[MATH] [MATH]の中で，関数[MATH]が最大になるものを求めよ．
与えられた原文の部分文節列の総数は有限である．
また，各部分文節列上の係り受け構造の総数も有限である．
したがって，上の文簡約問題は，原理的には枚挙法で解くことができるが，計算量の点で現実的でない．
本論文では，動的計画法の原理に基づき，この問題を効率的に解くアルゴリズムを導出する．
評価関数[MATH]の定義には，文節重要度[MATH]と係り受け整合度[MATH]の２つの関数が含まれている．
これらの関数をどのように定義するかは実際の応用においては重要な問題であるが，本論文ではこれについては議論しない．
しかし，文節重要度[MATH]の定め方については，例えば[CITE]のような方法が考えられ，係り受け整合度[MATH]の定め方については係り受け解析の分野で研究されている[CITE]などの方法が利用できると考えられる．
3節で導かれるアルゴリズムは，これらの関数の定義には依らない．
二文節間の係り受け整合度の総和は，従来，係り受け解析にも用いられている評価関数であり，その意味で本手法による簡約文は，係り受け整合度[MATH]が適切に設定されていれば，原文の部分的な係り受け構造を保った自然な係り受け構造を持つことが期待できる．
しかし，それにより原文の意味がどの程度保たれるかについては，最終的には人間の簡約結果と比較するなどの評価が必要となる．
本論文では，そこまでは立ち入らず，上のような評価関数を用いて問題を定式化したとき，それを現実的な計算量で解くアルゴリズムが構成できることを示すことに重点を置いている．
文簡約問題，すなわち関数[MATH]の最大化問題を解くために，その``部分解とそれらの間の関係''を考える．
まず，先頭文節を[MATH]に，末尾文節を[MATH]に，文節列長を[MATH]に固定したときの最大化を考え，その最大値を表す関数[MATH]を以下のように定義する．
{最大値関数[MATH]}
そうすると[MATH]は次の再帰式を満たすことが示される．
証明は付録とする．
{再帰式}
[MATH]のとき: ( [MATH]の動く範囲: [MATH]のみ)
[MATH]のとき: ( [MATH]の動く範囲: [MATH])
[MATH]のとき
[MATH]のとき
[MATH]のとき
再帰式は[MATH]のとき，[MATH]となる[MATH]と[MATH]の全てが既に計算されていれば，高々3つの変数に関する最大化問題を解くことにより[MATH]が計算できることを表している．
すなわち式([REF_eqn:eqn1])より，[MATH]は，入力文節の重要度から直接計算できる．
また，式([REF_eqn:eqn2])より2文節の重要度とその間の係り受け整合度の和から，[MATH]が計算できる．
これらから始めて，[MATH]のときは[MATH]を2変数[MATH]が制約条件を満たす範囲で最大化を行ない，[MATH]では3変数[MATH]が制約条件を満たす範囲で最大化を行なうという再帰的な処理によって，[MATH]を計算することができる．
以上の事実に注意すると，計算済の[MATH]の値を図[REF_fig:region]のようなテーブルの升目に順次埋めていくアルゴリズムが構成できる．
図[REF_fig:region]には[MATH]を埋める場合を示した．
再帰式によると，[MATH]の計算は，その左の領域[MATH]から[MATH]を，その下の領域[MATH]から[MATH]を選択する組合わせの中から，それぞれの持つ[MATH]の値と両者の係り受け構造間の係り受け整合度の総和が最大となるような[MATH]を探索することで行なわれていく．
このとき，係り文節[MATH]は必ず受け文節[MATH]より文頭側にあること，文節列[MATH]を簡約する場合，簡約後の部分文節列の長さは原文節の長さより大きくなることがないことから，変数には以下のような制約が課せられる．
[MATH]
[MATH]のとき[MATH]
[MATH]のとき[MATH]
これを図示したものが図[REF_fig:region2]である．
また，ここでは[MATH]を満たす任意の[MATH]に対して最適解が探索できる領域を考えているが，[MATH]の最大値[MATH]があらかじめ定まっているときは，[MATH]の動く範囲を[MATH]に制限できる．
したがって[MATH]の場合には探索領域はさらに小さくてすみ，計算量と記憶量を減らすことができる．
図[REF_fig:region]のテーブルの升目を埋める順序については，[MATH]を計算する際に[MATH]と[MATH]が制約条件の範囲で全て計算済であるという条件さえ満たしていればよいので，その順序には大きな自由度がある．
変数[MATH]を動かすとき，アルゴリズム[REF_alg:recursion]のように最外ループを[MATH]に関するループとすると，入力文節に同期した処理が可能なアルゴリズムとなる．
すなわち，文頭文節からある文節までが入力されたとき，そこまでの情報に基づいてできる計算は，それより後の文節に関係なく済ませることができる．
そして，もし必要ならば，その時点で3.3に述べるバックトレースを行い，そこまでの入力に対する簡約文を出力することができる．
また，最外ループを[MATH]に関するループとすれば，そのループの第[MATH]ステップの処理が終わった時点で，[MATH]としてバックトレースが可能になるので，文節数[MATH]から順に求めたい文節数までの簡約文を出力するアルゴリズムが構成できる．
{再帰式の実行}
\=  \=  \=  \=  \=  \=  \+ \kill
for [MATH] to [MATH]  \+
begin
for [MATH] downto [MATH] do \+
begin
if ([MATH]) then [MATH]; \` \makebox[10zw]式([REF_eqn:eqn1])
else \+
begin
for [MATH] to [MATH] do \+
begin
if ([MATH]) then [MATH] .
..
; \` \makebox[10zw]式([REF_eqn:eqn2])
else if([MATH]) then [MATH] .
..
; \` \makebox[10zw]式([REF_eqn:eqn3]a,[REF_eqn:eqn3]b)
else [MATH] .
..
; \` \makebox[10zw]式([REF_eqn:common]a, [REF_eqn:common]b, [REF_eqn:common]c)
end; \-
end; \-
end; \-
end;
アルゴリズム１の計算結果から最適部分文節列を構成することを，ここでは「バックトレース」という．
ここで用いるバックトレースの方法は[CITE]の手法に類似したものであり，形式的な証明も可能であるが，ここでは，考え方の概略とアルゴリズムを示すにとどめる．
まず「係り受け構造の分解」について述べる．
[MATH]を文節列とし，その上の係り受け構造[MATH]を考える．
[MATH]において，末尾の文節[MATH]に係る最も文頭側の文節を[MATH]とすると，[MATH]は[MATH]上の係り受け構造と[MATH]上の係り受け構造に分解できる．
ただし，[MATH]が[MATH]に係るという情報を加えておく必要がある[CITE]．
付録の証明から明らかなように，[MATH]に対する再帰式の導出においては，この事実が以下のように利用されている．
[MATH]を計算するためには，[MATH]から始まり，[MATH]で終わる長さ[MATH]の部分文節列上の係り受け構造を考慮する必要がある．
上に述べたことから，そのような係り受け構造は，[MATH]に係る最も文頭側の文節を[MATH]とするとき，[MATH]から始まり[MATH]で終わる長さ[MATH]の部分文節列上の係り受け構造と，ある文節[MATH]から始まり[MATH]で終わる長さ[MATH]の部分文節列上の係り受け構造に分解できる．
ただし，[MATH]が[MATH]に係るという情報を加えておく必要がある．
さて，再帰式の証明が示すように，[MATH]を求めるためには，評価関数[MATH]を，上のように分解した部分文節列，および係り受け構造に関して最大化すればよい．
それは，
を，[MATH]，[MATH]，[MATH]に関して最大化することに帰着する．
最大値を与えるこれらの変数の値を再び[MATH]，[MATH]，[MATH]と表せば，以上のことから，[MATH]を与える最適部分文節列[MATH]は[MATH]を与える最適部分文節列[MATH]と[MATH]を与える最適部分文節列[MATH]の連接で与えられること，また[MATH]上の最適係り受け構造は[MATH]上の最適係り受け構造と[MATH]上の最適係り受け構造を併せたものに，[MATH]が[MATH]に係るという情報を加えたものになることが分かる．
また，[MATH]の場合は[MATH]しか許されず，[MATH]を与える最適部分文節列は``[MATH]''となる．
したがって，アルゴリズム[REF_alg:recursion]の各ステップで最大値を与える[MATH]，[MATH]，[MATH]の値(最適分割点)を記憶しておけば，アルゴリズム[REF_alg:recursion]の終了後，任意の長さの簡約文と，必要ならばその上の係り受け構造を再帰的に得ることができる．
最適分割点はバックトレースのための，いわゆるバックポインタの役割を果たす．
実際の計算では，アルゴリズム[REF_alg:recursion]の各ステップにおいて最適分割点を記憶するための変数[MATH]を用意する．
最適分割点は再帰式中の場合に応じて，次のように設定される．
[MATH]は再帰式の中で最大値を与えるそれらの変数の値を表す．
{最適分割点}
[MATH]の場合
何も記憶する必要がない．
[MATH]の場合
与えられた文節列から[MATH]の範囲で任意に指定した長さ[MATH]の最適部分文節列を探索するには，まず，最も評価値の高い[MATH]を見つけることから始める．
そして，この[MATH]を出発点として，アルゴリズム[REF_alg:backtrace]で示す再帰関数を用いて最適部分文節列が得られる:
ここでは，最適分割点が一意に定まる場合を考えているが，これが複数個存在する場合には，その全てを記憶し，そのそれぞれに対して最適部分文節列を求めればよい．
異なる最適分割点から，同じ最適部分文節列が得られる可能性があるが，この場合，これらの最適部分文節列上には複数の最適係り受け構造が存在している．
{バックトレース} ([MATH]は文字列の連接を表す)
ここで，本アルゴリズムにおける最適分割点と簡約文の係り受け構造の対応について述べる．
[MATH]は文節列[MATH]を長さ[MATH]に簡約するときの最適分割点であるが，再帰式の証明(付録)からわかるように，[MATH]は簡約結果において[MATH]に係る文節の中で最も文頭側にあるものの番号である．
したがって，[MATH]は[MATH]に係ることがわかる．
これを再帰的に繰り返せば，簡約文中の全ての文節の係り先がわかる．
すなわち，アルゴリズム[REF_alg:backtrace]を用いてバックトレースを行なうとき，[MATH]ならば[MATH]であることを記憶し，まとめて出力すれば，簡約文中の全ての文節に対する[MATH]の値，つまり係り受け構造を知ることができる．
まず，アルゴリズム[REF_alg:recursion]における加算回数について考察する．
計算ステップ[MATH]における加算回数を[MATH]とすると[MATH]に対する再帰式より，次のことが容易に分かる．
\tiny
[MATH]のとき:
[MATH]のとき:
[MATH]のとき:
[MATH]のとき：
\tiny
総加算回数[MATH]は[MATH]を[MATH]，[MATH]について加え合わせたものになるが，[MATH]のときは[MATH]であり，そのとき[MATH]であるから，
となる．
詳細は省略するが，この右辺を計算すると，
が得られる．
同様の計算により，総比較演算回数[MATH]は
で与えられる．
したがって計算量のオーダは[MATH],[MATH]共に[MATH]となる．
これはかなり大きな計算量のように見えるが，最高次の係数が小さいことと[MATH]は高々40程度までを考えておけばよいことから，計算が困難なほど大きな値にはならない．
実際，[MATH]の場合，加算回数と比較演算回数は表[REF_tbl:order]で示したように，[MATH]であり，アルゴリズム[REF_alg:recursion]をCで実装しUltraSPARC-IIi(270MHz)上で処理したときの処理時間は，1秒以内である．
また，アルゴリズム[REF_alg:backtrace]の実行時間は，これに比べて無視できる程度である．
本手法の評価は今後の課題であるが，アルゴリズムの動作を示すため，文節重要度と係り受け整合度を仮に与えて実行した例を2つ示す．
簡約文の係り受け構造も[CITE]による括弧表記を用いて示している．
本アルゴリズムで必要とされる係り受け整合度は，[CITE]の係り受けペナルティに[MATH]を乗じたものとした．
ここで定義されているペナルティ関数は学習コーパス中の係り受け距離の頻度分布を元に作成されている．
また文節重要度は，
主部/述部や名詞/動詞を含む文節に形容詞や動作の程度や目的を表す文節より大きい値
文末の動詞には大きな値
形式名詞には小さな値
を人手で設定した．
この例における具体的な値を表[REF_tbl:example]に示す．
例にあげた文は[CITE]の手法で正しく係り受け解析できたものである．
簡約文の文節数[MATH]を原文の文節数[MATH]に等しく設定すると簡約文は原文そのものしかあり得ない．
したがって，その場合には本アルゴリズムは原文の係り受け解析のみを行なうことになり，その結果は[CITE]の手法によるものと一致する．
実際に簡約文を出力するためには，その長さ[MATH]を指定する必要がある．
これは，現実の場面で文章全体をどの程度に圧縮したいかという要求と簡約文の品質を考え合わせて決めるものであるが，本手法を人が文を簡約するときの支援システムとして使用する場合には[MATH]の値を順次変化させ，それに応じて得られる簡約文の中から人が適切なものを選ぶという使い方も考えられる．
また，評価関数の値を利用して，「できるだけ短く」と「できるだけ情報を保つ」という相反する要求のバランスを自動的に取ることも考えられるが，それは今後の問題である．
