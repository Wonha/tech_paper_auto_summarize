我々の機械翻訳システムは主に日英を対象としている．
アラインメントは日本語，英語の構文解析器や対訳辞書などを用いて，以下のステップにより達成される．
日本語文は形態素解析器JUMAN [CITE]と構文解析器KNP [CITE]を用いて依存構造木に変換される．
依存構造木の各ノードにはただ1つの内容語が含まれており，それに付随する助動詞や接尾辞などの機能語は同じノードに含まれる．
英語文については，まずCharniakらのnlparser [CITE]を用いて構文解析し，さらにヘッドを定義するルールにより依存構造木に変換する．
日本語の場合と同様，各ノードは1つの内容語とそれに付随する機能語とからなる．
図[REF_fig:Amb]に木構造の例を示す．
木構造のルートノードは一番左に配置されており，それぞれの句は上から下に語順どおりに配置されている．
日英間の単語/句対応の候補探索には，対訳辞書，Transliteration，数字のマッチング，部分文字列アラインメントなどいくつかの手がかりを利用する．
日本語の単語と英語の単語の全ての組み合わせを対訳辞書から探し，対応候補を見つける．
このとき，1語ずつではなく複合名詞などの複数語の探索も行う．
また現時点では対訳辞書には確率的な情報は含まれていない．
日本語で形態素解析器によって人名や地名などの固有名詞と判定された語や，一般的に外来語に用いられることの多いカタカナ語に対して，英語へのtransliteration候補を自動的に生成し，これら候補と英語文に現れる単語との類似度を計算する．
類似度は編集距離を元にして計算され，類似度が閾値を越える組み合わせがあった場合，それらを対応候補とする．
例えば以下の例は対訳辞書では対応候補として得られないが，transliterationにより対応候補とされる．
新宿[MATH] Shinjuku [MATH] Shinjuku（類似度：1.0）
ローズワイン[MATH] rosuwain [MATH] rose wine（類似度：0.78）
それぞれの言語において異なる数字表現を算用数字に汎化することにより，対応候補を得る．
例えば日本語の「二百六十万」と英語の``2.6 million''は共に同じ数字``2600000''を表しているため，それぞれ汎化することにより対応候補とすることができる．
対訳文の中には特別な言い回しや辞書に載っていない専門用語などを含んだもの，文の内容に過不足があるものなどが存在する．
これまで挙げた手がかりだけでは，このような対訳文を正確にアラインメントするのに十分な対応候補を見つけることができない場合がある．
このため，言語資源に依存しない統計的なアラインメント手法も併用することが必要となる．
統計的手法として，我々はCromieresの手法[CITE]を利用した．
この手法は，対訳コーパス中の各言語の任意の部分文字列（分かち書きされている場合は単語列）の共起頻度を元にして対訳文のアラインメントを行う手法である．
任意の部分文字列についてアラインメントするため形態素解析が不要な点，またSuffix Arrayを用いて高速にアラインメントできる点で優れている．
例えば以下の対訳文を考える．
Source:参院選での社会党の大敗は必至と言われる．
Target: It is said that the Social Democratic Party will suffer a major loss at the House of Councillors election.
対訳辞書情報から得られる対訳候補は``言われる[MATH] said that''のみであり，不十分だが，Cromieresの手法を用いることにより``参院[MATH] the House of Councillors'', ``選[MATH] election'', ``の社会[MATH] the social'', \makebox{``党の[MATH] Democratic Party''}の各対応が得られる．
前章で得られた対応候補の中には，曖昧性を持つ候補や，曖昧ではないが文脈上不適切な候補が含まれることがある．
例えば図[REF_fig:Amb]において，日本語の``保険''と英語の``insurance''はそれぞれ2度ずつ出現しており，組み合わせで4つの対応候補が得られることになり，曖昧性が生じる．
さらに``申し立て''の訳語として``file''と``claim''の2つがみつかり，ここでも曖昧性が生じる．
このため，見つかった対応候補の中から適切な候補のみを選び出す基準が必要となる．
これについての詳細は[REF_proposed]章で述べる．
ここまでの処理により対訳文間にいくつかの対応が見つかったが，いくつかのノードが対応付けられずに残る場合がある．
これらのノードは簡単なルールにより他の対応に併合する．
まず日本語，英語ともに名詞句内で未対応部分があれば名詞句内の他の対応に併合し，それ以外の未対応ノードはすべて親ノードの対応に併合する．
ただし，節の区切りなどの大きな区切りを越えての併合は行わない．
対訳文全体として整合的なアラインメントを行うために，任意の1組の対応に対して整合性スコアを定義する．
最も整合的なアラインメントは整合性スコアの平均を最大とするような対応候補の組み合わせとして得られる．
上式で[MATH]と[MATH]は互いに異なる任意の対応候補であり，整合性スコアは対応候補のペアに対して定義される．
整合性スコアの定義については次章以降で詳しく述べる．
アラインメントの精度を左右するのは，曖昧な対応や誤った対応が含まれるたくさんの対応候補の中から，いかに正しいものを選択するかである．
これを実現するために，対訳文全体を整合的に対応付けられるロバストな手法が必要である．
英語とヨーロッパ言語のように言語構造の似た言語対ならば，広く研究されている統計的な手法でも高精度にアラインメントすることが可能であるが，日本語と英語では言語構造が大きくことなるため，統計的な手法での高精度なアラインメントは難しい．
しかし我々のMTシステムは依存構造木をベースとした深い言語処理を行っているため，リッチな情報を利用して言語構造の違いを吸収できるようなアラインメントが可能である．
我々の提案する手法を説明する前に，アラインメントの整合性とは何かを考えてみよう．
図[REF_fig:consistency]において，それぞれの三角形は各言語の木構造上の節を表しており，2つの木構造にまたがって引かれた直線の1つ1つが対応候補を表している．
すべての対応候補のうちで，×印が記された候補が全体の整合性を低下させていることが見て取れる．
このような不整合は視覚的には明らかである．
この不整合さを定量的に評価するために，我々は一組の対応候補の木構造上での距離に注目する．
図[REF_fig:consistency]の例で×印が記された候補と他の1つの候補とに注目すると，原言語側での2つの直線の距離は遠いのに対して，目的言語側では非常に近い．
句の依存情報を元にした木構造上で議論すると，このようなことが起こることは稀である．
つまり，一方の言語で構造的に近い句同士が他方の言語では遠くなるようなことはほぼありえないということである．
このように，あらゆる対応候補のペアの距離を適切に扱うことにより，全体的に整合的なアラインメントを得ることができると考えられる．
この距離を扱うために，我々は次章で説明する整合性スコアを提案する．
整合的なアラインメントを得るために，依存構造木上で整合性スコアを定義する．
整合性スコアは2つ1組の対応候補に対して計算され，対応候補ペアの距離の関係が適切ならばプラス，そうでなければマイナスのスコアとなる．
まず，任意の対応候補ペア[MATH]([MATH], [MATH])と[MATH]([MATH], [MATH])に注目する．
[MATH]と[MATH]はそれぞれ対応候補[MATH]によって対応づけられている原言語，目的言語の句を表しており，[MATH]と[MATH]も同様である．
原言語側の係り受け距離[MATH]は，[MATH]と[MATH]の間の木構造上での距離として定義され，目的言語側についても同様に[MATH]が定義される．
この距離を用いて整合性スコアは以下のように計算される．
ここで[MATH]は[MATH]を省略して表記したもので，[MATH]も同様である．
[MATH]は原言語側と目的言語側の距離のペアをスコアに変換する関数であり，距離—スコア関数と呼ぶ．
係り受け距離と距離スコア関数については次章で詳しく述べる．
対訳文全体のアラインメントの整合性は，式[REF_eq:sum]に表されるように，あらゆる組み合わせの対応候補ペアの整合性スコアの和として定義される．
正しい対応候補は，その近くにある対応候補により支持され，プラスのスコアが与えられ，さらに全体のアラインメントの整合性に寄与する．
ここで，近くにある対応候補とは，原言語側，目的言語側ともに，距離が小さい対応候補ということである．
この章では，係り受け距離[MATH]や[MATH]の計算方法を説明する．
最も単純な設定としては，すべての枝の距離を1とし，係り受け距離はあるノードから別のノードまでに通る枝の数とすることが考えられる．
しかしながら，高度な言語処理技術により得られる知識を利用し，より精度の高いシステムの構築を目指すことは自然である．
日本語依存構造解析器KNPおよび英語のCharniakのnlparserはそれぞれ係り受けタイプの情報を出力する．
これらの情報を利用して，係り受けタイプスコアを定義する．
このスコアは係り受けの強さ，つまり枝の距離を表しており，係り受けの強さが強い（区切りが弱い）ほど小さく，係り受けの強さが弱い（区切りが強い）ほど大きくなるように設定する．
例えば複号名詞内の形態素の区切りなどは係り受けが強いのでスコアは小さく，逆に節の区切りなどは係り受けが弱いのでスコアは大きくなる．
係り受けタイプは高々30種類程度しかないため，係り受けタイプスコアは人手により設定する．
図[REF_fig:dep_dist]にその一部を示す．
日本語の係り受けタイプは南による分類[CITE]に基づいて，構文解析器KNP [CITE]が出力するものである．
スコアの値は主観的に定義したものであり，正確に言語現象を反映した値ではない可能性がある．
この値を自動学習により設定することは，今後の課題である．
係り受けタイプスコアを実際の対訳文に適用した例を図[REF_fig:exgood]に示す．
図[REF_fig:exgood]で各枝上のラベルが係り受けタイプを示しており，その上の数字が係り受けタイプスコアである．
係り受け距離[MATH]や[MATH]は，あるノードから別のノードまで最短ルートでたどるときに通る枝の係り受けタイプスコアの和と定義する．
例えば図[REF_fig:exgood]でペア1の距離は，日本語側([MATH])は``保険[MATH]請求の''の枝を通るので，[MATH]となり，英語側([MATH])は``insurance [MATH] an claim''の枝を通るので，[MATH]となるため，[MATH]となる（図で丸で囲まれた数字のある枝を通る）．
同様にペア2の距離は，日本語側はペア1と同じで[MATH]だが，英語側は``insurance [MATH] with the office''，``with the office [MATH] will have to file''，``an claim [MATH] will have to file''の3つの枝を通るので，枝の距離を合計して[MATH]となるため，[MATH]となる（図で四角で囲まれた数字のある枝を通る）．
木構造を用いずに単純な単語列として見た場合，2つの``insurance''はどちらも``claim''から近いと判断されてしまうため，正しい曖昧性解消ができなくなる．
このようなことは他の例でもしばしば起こりうることであり，木構造を用いることの利点がここで示される．
距離スコア関数[MATH]は2つの距離の組[MATH]に対して，それらの関係が適切かどうかを反映するスコアを与える．
この関数を設定するために，まず実際のデータにおける現象を観測した．
正解のアラインメントが付与された4万文の新聞記事対訳コーパス[CITE]を用いて，距離の組の出現頻度を係数した．
図[REF_fig:learn]に観測結果を示す（状況がとらえやすいように，別角度からの図を2つ示す）．
縦軸が頻度の対数であり，2つの横軸は2つの距離にそれぞれ対応する．
結果を見ると，距離が等しいペアの頻度は高く，逆に距離に差があるペアの頻度が著しく低下することがわかる．
この観測結果を踏まえて，距離—スコア関数[MATH]を人手で設定した．
このとき，以下の条件を満たすようにする：
[MATH]と[MATH]が共に小さい場合は，注目した対応候補の関係が適切であると判断できるので，プラスのスコアを与える
[MATH]と[MATH]が共に大きい場合（距離10以上）は，対応候補は互いに関係性を持たないと判断し，0とする．
[MATH]と[MATH]の差が大きい場合は，対応候補の関係が不適切であると判断できるので，マイナスのスコアを与える．
例えば図[REF_fig:exgood]において，ペア1[MATH]にはプラスのスコアを与えるが，ペア2[MATH]に対してはマイナスのスコアを与える．
アラインメントの整合性は式[REF_eq:sum]に示したように，全ての対応候補ペアの[MATH]の和として定義される．
また最適なアラインメントは，この和を最大とするアラインメントである．
しかしながら，考えうる全てのアラインメントのパターンをチェックしようとすると，組み合わせ爆発を起こすので，最適なアラインメントの探索は近似的に行う．
まず，ある1つの対応候補[MATH]に対するスコアを以下のように定義する：
これにより，全ての対応候補の1つ1つに個別にスコアが計算される．
ここで，最も高いスコアとなった対応候補は正しい対応であると判断し，採用する．
同時に，採用された対応と衝突している対応候補は棄却する．
そして各対応候補のスコアを再計算し，採用・棄却を繰り返す．
これをすべての対応候補が採用か棄却されるまで繰り返すことにより，近似的に最適なアラインメントが得られる．
