MSLRパーザと従来の組み込み手法
\label{sec:mslr}

本節では，従来のLR表への接続制約の組み込み手法とその問題点を述べるが，
その前に，第\ref{sec:evaluation}節の評価実験で使用する
MSLRパーザ \cite{shirai:00} の原理について概略を説明する．


\subsection{MSLRパーザの原理}
\label{sec:principle}

MSLR (Morpho-Syntactic LR) パーザは，GLR構文解析アルゴリズムを拡張し，
日本語などの分かち書きされていない文の形態素解析と構文解析を
同時に行うことのできるパーザである．
図\ref{fig:mslr}に示すように，
MSLRパーザは，文法(CFG)からLR表を生成し，
それを参照しながら入力文の解析を行う．
LR表を生成する段階では，文法のほかに
品詞間接続制約を組み込むことも可能である．
品詞間接続制約を組み込むことにより，
LR表のサイズを小さくし，解析効率を向上させることができる．
また，MSLRパーザは，平文を入力とすることで
形態素解析と構文解析を同時に行うことができるが，
形態素区切りや品詞，係り受けなどの部分的な制約を入力に加えて
解析を行うこともできる．
さらに，確率一般化LR (Probabilistic Generalized LR; PGLR)モデル
\cite{inui:00} により，
GLRアルゴリズムの枠組みにおいて構文木の生成確率を求めることもできる．

\begin{figure}[t]
\begin{center}
\includegraphics{16-3ia4f1.eps}
\end{center}
\caption{MSLRパーザの動作の流れ}
\label{fig:mslr}
\end{figure}

MSLRパーザでは，$\varepsilon$規則（右辺の記号列長が0の規則）を含む文法は扱えない．
文法が大規模化するにつれ，文法作成者が予期しない$\varepsilon$規則の適用や，
それによる解析結果の曖昧性の増大が起きるため，
MSLRパーザの仕様として，文法に$\varepsilon$規則は含まれないことを
前提としている．
本論文でも，$\varepsilon$規則を含まない文法を前提とする．


\subsection{接続制約と接続表}

終端記号と文末記号$\$$の集合 $\{t_1,t_2,\dots ,t_n,t_{n+1}(=\$)\}$
の接続制約は，$n$行$n+1$列の表（接続表）で表現できる．
\[
  \mathrm{connect}[t_i,t_j]=
  \begin{cases}
    1 & \text{$t_it_j$ の順で接続可能な場合} \\
    0 & \text{$t_it_j$ の順で接続不可能な場合}
  \end{cases}
\]
ただし，$1\leq i\leq n$，$1\leq j\leq n+1$ である．
また，終端記号または非終端記号$X$の直後に接続可能な終端記号の集合を
返す関数Connectを
\pagebreak
以下のように定義する．
\[
  \mathrm{Connect}(X)=
  \begin{cases}
    \{t|\mathrm{connect}[X,t]=1 \wedge t\in\mathrm{Follow}(X)\}
    & \text{$X$ が終端記号の場合}\\
    \bigcup\{\mathrm{Connect}(t)\cap\mathrm{Follow}(X)|t\in\mathrm{Last}(X)\}
    & \text{$X$ が非終端記号の場合}
  \end{cases}
\]
ただし，$\mathrm{Follow(X)}$と$\mathrm{Last}(X)$は，それぞれ
CFGの開始記号から展開した場合に非終端記号$X$の直後に出現し得る終端記号の集合，
$X$を展開した場合に末尾に出現し得る終端記号の集合を表す．
さらに，終端記号または非終端記号列$\alpha (=\beta Y)$の場合や，
終端記号または非終端記号の集合$\Sigma$の場合は，
関数Connectを以下のように定義する
（$Y$は終端記号または非終端記号）．
\begin{align*}
  \mathrm{Connect}(\alpha)&=\mathrm{Connect}(Y)\\
  \mathrm{Connect}(\Sigma)&=\bigcup_{X\in \Sigma}\mathrm{Connect}(X)
\end{align*}


\subsection{従来の接続制約組み込み手法}

LR表への品詞間接続制約の組み込み手法には，
まず接続制約を考慮しないLR表を作成してから不要な動作を削除する手法
\cite{tanaka:95}，
LR表作成前と作成後の両方で不要動作を削除する手法
\cite{li:95}などがある．
ここでは，MSLRパーザのLR表生成器で採用されている
2つ目のLR表作成前と作成後の両方で不要動作を削除する手法（Liの手法）について述べる．

LR構文解析では，LRアイテムを利用してCFGから状態遷移図（gotoグラフ）を作成する．
Liらは，gotoグラフを作成する段階で，接続制約を利用して
アイテムの生成を抑制することにより，
接続制約を組み込んだgotoグラフを作成する．
さらに，接続制約を組み込んだgotoグラフからLR表を作成した後，
接続制約を伝播させることにより，
LR表作成前に削除できなかった動作を削除する．

接続制約を利用したLR(0)アイテムの生成の抑制は，
核アイテム$[X\to\alpha\cdot\beta]\in\mathrm{Goto}(I,Z)$を
closure展開する際，以下の2つの条件を満たすLR(0)アイテムのみを生成する
ことにより行う
\footnote{LR(1)アイテム$[X\to\alpha\cdot\beta;t]\in\mathrm{Goto}(I,Z)$の
  場合は，第2条件を$t\in\mathrm{Connect}(\beta)$に置き換える．}．
\begin{align*}
  \mathrm{Connect}(Z)\cap\mathrm{First}(\beta)&\neq\emptyset\\
  \mathrm{Follow}(X)\cap\mathrm{Connect}(\beta)&\neq\emptyset
\end{align*}
ただし，$\mathrm{Goto}(I,Z)$は，
gotoグラフにおいて状態$I$から終端記号または非終端記号$Z$で遷移した
先の状態を表す．
また，$\mathrm{First}(\beta)$は，$\beta$を展開した場合に
先頭に出現し得る終端記号の集合を表す．

接続制約を組み込んだgotoグラフを作成したら，
それをもとにLR表を作成する．
この時点で既にいくらかの不要な動作は削除されているが，
削除できずに残っている動作もあるため，
LR表作成後に接続制約を伝播させることにより，
さらに不要な動作を削除する．
具体的には，LR表中の各動作について，
その直前に実行すべき動作が存在しない場合，
または直後に実行すべき動作が存在しない場合，
その動作を削除する．


\subsection{従来手法の問題点}
\label{sec:problem}

図\ref{fig:ex_cfg3}に示すような文法$G$
\footnote{LR構文解析では，与えられた文法$G$からLR表を作成する際，便宜的に，
  非終端記号$\mathit{SS}$を$G$の非終端記号集合に，
  文末を表す終端記号$\$$を終端記号集合に追加し，
  $\mathit{SS}\to S\$$を$G$に追加する
 （$S$は元の$G$の開始記号）．
  本論文では，新たに追加するCFG規則の番号を常に0番とする．}
と接続制約$C$（と文法$G$から作成されるgotoグラフ）を
例に，従来手法（Liの手法）の問題点を述べる．

\begin{figure}[b]
\begin{center}
\includegraphics{16-3ia4f2.eps}
\end{center}
  \caption{CFGと接続制約の例}
  \label{fig:ex_cfg3}
\end{figure}

Liの手法により作成されるLR表を表\ref{tab:lr_table_hashimoto}に示す．
ただし，括弧で囲まれた動作は，接続制約により削除されたものである．
ここで，状態2，先読み$c$における移動(shift)動作$\mathrm{sh}_7$に注目する．
この動作は，Liの手法では削除されない．

このshift動作に関連する動作実行列として，
以下のような場合が想定される
（$(2,c,\mathrm{sh}_7)$は，状態2，先読み$c$における
shift動作$\mathrm{sh}_7$を表す）．
\[
  (2,c,\mathrm{sh}_7) \to (7,d,\mathrm{sh}_{13}) \to (13,d,\mathrm{re}_6) \to (2, Z, \mathrm{goto}_5) \to (5,d,\mathrm{sh}_{11})
\]
一方，以下のような動作実行列も存在する．
\[
  (3,c,\mathrm{sh}_7) \to (7,d,\mathrm{sh}_{13}) \to (13,e,\mathrm{re}_6) \to (3, Z, \mathrm{goto}_9) \to (9,e,\mathrm{sh}_{14})
\]
接続制約より，終端記号$d$は終端記号$e$と接続するが，
終端記号$d$とは接続しないため，前者の実行列は制約に違反する．
その結果，$(13,d,\mathrm{re}_6)$は削除される．
しかし，$(7,d,\mathrm{sh}_{13})$は，もう一方の接続制約を満たす動作実行列に含まれるため，残される．
$(2,c,\mathrm{sh}_7)$は，接続制約を満たすどのような動作実行列にも含まれず，
削除すべき動作であるが，次の$(7,d,\mathrm{sh}_{13})$が残されるため，
Liの手法では削除できない．

\begin{table}[t]
  \caption{Liの手法により作成されるLR表}
  \label{tab:lr_table_hashimoto}
\input{04table01.txt}
\end{table}

従来手法では，1つ先または1つ前の動作が存在しないことが判明した場合に，
その動作を削除する．
この例では，2つ先の動作が存在するか否かを調べなければ，
削除可能かどうかを判断できない．
これを一般化すると，1つ先や2つ先だけでなく，$n$個先の動作が
存在するか否かを調べる必要があり，
連続する動作の存在を局所的に調べるだけでは，
接続制約に違反する動作を完全に削除することはできない．
このような例でも動作を削除できるようにするためには，
その動作実行列が最終的にacc動作に到達可能であるか否かを
調べる必要がある
\footnote{動作実行列が（acc動作に到達できない）無限ループを形成するような
  文法と接続制約の例も存在する．
  これは$n$をどれだけ大きくしても，
  無限ループ内の動作が削除可能であることを発見できない究極の例である．}．


提案アルゴリズム
\label{sec:improvement}

初期状態から実行すべき動作を順番に決めていくと，
動作の実行列（アクションチェイン）ができる．
このアクションチェインがacc動作に到達すれば，
解析が成功することになる．
一方，実行すべき動作がLR表から決まらないときには，
解析が失敗することになる．
このアクションチェインは有向グラフ（アクションチェイングラフ） として表現できる．

初期状態からacc動作に至るアクションチェインを成功パスと呼ぶ．
成功パス上の動作は，必要な動作としてLR表に残す．
提案アルゴリズムでは，アクションチェインを最終状態（acc動作）から
逆向きに横型探索によりたどることにより，成功パスを探索する．
すなわち
開始記号を左辺に持つCFG規則について，
その右辺の末尾の記号から順番に展開しながら
（最右導出を行いながら）
接続制約を満たすか否かをチェックする．

\begin{figure}[b]
\begin{center}
\includegraphics{16-3ia4f3.eps}
\end{center}
  \caption{gotoグラフ}
  \label{fig:proposed}
\end{figure}

開始記号$S$を左辺に持つ $S\to X_1X_2\dots X_n$
というCFG規則（規則番号を$m$とする）があったとする．
gotoグラフには図\ref{fig:proposed}(a)に示すような
状態とリンクが存在する（開始状態を0とする）．
このCFG規則の展開に対応するLR表中の動作は，
状態$s_n$，先読み$\$$におけるreduce動作 $\mbox{re}_m$と
その後の状態0，非終端記号$S$における状態$s_0$への遷移であり，
この動作をアクションチェインに追加する．
そして，右辺の各終端記号または非終端記号について，
$X_n$，$X_{n-1}$，…$X_1$の順に接続制約を満たすか否かをチェックする．
$X_n$が終端記号の場合，$X_n$と$\$$の間の接続制約をチェックする．
接続制約を満たすならば，
状態$s_{n-1}$，先読み$X_n$におけるshift動作 $\mbox{sh}_{s_n}$
をアクションチェインに追加し，$X_{n-1}$のチェックに移る（先読みは$X_n$となる）．
$X_n$が非終端記号の場合は，$X_n$を左辺とするCFG規則で展開する．
このCFG規則が$X_n\to Y_1Y_2\dots Y_{n^{\prime}}$（規則番号$m^{\prime}$）であるとすると，
gotoグラフ中では図\ref{fig:proposed}(b)に示すような状態とリンクが存在する．
このCFG規則の展開に対応する，
状態$s^{\prime}_{n^{\prime}}$，先読み$\$$におけるreduce動作 $\mbox{re}_{m^{\prime}}$
と状態$s_{n-1}$，記号$X_n$における状態$s_n$への遷移を
アクションチェインに追加し，
$Y_{n^{\prime}}$，$Y_{n^{\prime}-1}$，…$Y_1$の順に接続制約を満たすか否かを同様にチェックする．
すべてのチェックが完了したら，$X_{n-1}$のチェックに移る
（先読みは$Y_1$のチェックで最後にアクションチェインに追加した
shift動作の先読みとなる）．
以下，同様に続け，最終的に状態0におけるshift動作が
アクションチェインに追加されたら，それが成功パスとなる．

提案アルゴリズムの概要を図\ref{fig:algorithm}に示す．
図中の記法については，以下のとおりである．
\begin{description}
\item[\protect{$[s,\mathrm{re}_n,\mathit{la},\mathit{status}]$}:]
  状態$\mathrm{LastState}(s,n)$，先読み$\mathit{la}$ で実行される
  $n$番目のCFG規則によるreduce動作を表すアクションチェインの要素．
  reduce後，状態$s$，非終端記号$\mathrm{LHS}(n)$ で
  状態$\mathrm{Goto}(s,\mathrm{LHS}(n))$へ遷移する．
  ただし，$n=0$ の場合は，reduce動作ではなくacc動作を表す要素となる．
  $\mathit{status}$は要素の処理状態を表す．
  要素の処理状態には，
  init（初期状態），wait（待機状態），check（調査中），pass（調査済），
  end（最終状態）があり，この順番で遷移する（initは飛ばされることもある）．
  \begin{description}
  \item[init:] 要素を作成しただけの状態
  \item[wait:] 次にアクションチェインに追加可能であることを表す状態
  \item[check:] アクションチェインに追加され，
    その後，解析開始状態（gotoグラフにおける状態0）に到達可能かどうか
（最終的に接続制約を満たすかどうか） を調査中であることを表す状態
  \item[pass:] 解析開始状態に到達可能であることが判明したことを表す状態
  \item[end:] 成功パスの要素であることを表す状態
  \end{description}
\item[\protect{$[s,\mathrm{sh},\mathit{la},\mathit{status}]$}:]
  状態$s$，先読み$\mathit{la}$ で実行されるshift動作を表す
  アクションチェインの要素．
\item[$\mathrm{Length}(n)$:] $n$番目のCFG規則の右辺の長さ．
\item[$\mathrm{LHS}(n)$:] $n$番目のCFG規則の左辺の非終端記号．
\item[$\mathrm{RHS}(n,i)$:] $n$番目のCFG規則の右辺の
  $i$番目の終端記号または非終端記号．$1\leq i\leq\mathrm{Length}(n)$
\item[$\mathrm{Rule}(\mathit{A})$:] 非終端記号$A$を左辺に持つ規則番号の集合．
  $\mathrm{Rule}(\mathit{A})=\{n|\mathrm{LHS}(n)=A\}$
\item[$\mathrm{PrevAction}(a)$:] 
  reduce動作またはshift動作$a$に続く動作の集合．
\item[$\mathrm{State}(s,n,i)$:] 
  $n$番目のCFG規則について，状態$s$から
  $\mathrm{RHS}(n,1)$，…$\mathrm{RHS}(n,i-1)$ を遷移した後の状態．
\item[$\mathrm{LastState}(s,n)$:] 状態$s$から$n$番目のCFG規則の右辺の
  終端記号または非終端記号列すべてを遷移した後の状態．
\item[$\mathrm{LA}(s,n)$:] 
  状態 $\mathrm{LastState}(s,n)$ における
  $n$番目のCFG規則によるreduce動作の先読みの集合．
\item[$\mathrm{PrevSym}(s)$:]
  状態$s$への遷移記号の集合．
  $\mathrm{PrevSym}(s)=\{\mathit{sym}|\mathrm{Goto}(s^{\prime},\mathit{sym})=s\}$
\item[$\mathrm{PrevState}(s,\mathit{sym})$:] 
  記号 $\mathit{sym}$ によって状態 $s$ に遷移する状態の集合．
  $\mathrm{PrevState}(s,\mathit{sym})=\{s^{\prime}|\mathrm{Goto}(s^{\prime},\mathit{sym})=s\}$
\end{description}

\begin{figure}[t]
\includegraphics{16-3ia4f4.eps}
  \caption{アルゴリズム概略}
  \label{fig:algorithm}
\end{figure}

\noindent
図\ref{fig:algorithm}の（2）では，
wait状態のreduce動作要素について，その状態をcheckとして，
対象となる動作の実行後に解析開始状態まで
接続制約に違反することなく到達可能かどうかのチェックを行う．
wait状態のshift動作要素ならば，その状態をcheckとして，
それに先行するinit状態の要素について，その状態をwaitとする．
ただし，先行する要素がshift動作要素の場合は，
両者の先読み記号の間の接続制約をチェックする．
また，gotoグラフにおける状態0でのshift動作要素の場合は，
解析開始状態まで到達可能であることが判明したので，要素の状態をpassとする．
図\ref{fig:algorithm}の（4）では，
pass状態の要素について，その状態をendとし，
そこから（2）のときとは逆に要素をたどり，
check状態の要素が解析開始状態まで到達可能であることを伝えていく
（状態をcheckからpassにする）．
最終的に状態がendとなった要素の列が成功パスとなる．

図\ref{fig:ex_cfg3}に示す文法$G$と接続制約$C$に対し，
上述のアルゴリズムを適用すると，
以下のような手順で処理が進行する．

\begin{figure}[p]
\includegraphics{16-3ia4f5.eps}
\vspace{1\baselineskip}
  \caption{アクションチェイングラフ作成の経過}
  \label{fig:chain}
\end{figure}

\begin{enumerate}
\item $[0,\mathrm{re}_0,\$,\mbox{wait}]$を作成．
\item $[0,\mathrm{re}_0,\$,\mbox{wait}]$について，
  処理状態をcheckに変更し，\\
  $[0,\mathrm{re}_1,\$,\mbox{wait}]$，
  $[0,\mathrm{re}_2,\$,\mbox{wait}]$を作成．
\item $[0,\mathrm{re}_1,\$,\mbox{wait}]$について，
  処理状態をcheckに変更し，\\
  $[0,\mathrm{sh},a,\mbox{init}]$，
  $[2,\mathrm{re}_3,e,\mbox{init}]$，
  $[4,\mathrm{sh},e,\mbox{wait}]$を作成．
\item $[0,\mathrm{re}_2,\$,\mbox{wait}]$について，
  処理状態をcheckに変更し，\\
  $[0,\mathrm{sh},b,\mbox{init}]$，
  $[3,\mathrm{re}_4,\$,\mbox{wait}]$を作成（図\ref{fig:chain}（1））．
\item $[4,\mathrm{sh},e,\mbox{wait}]$について，
  処理状態をcheckに変更し，\\
  $[2,\mathrm{re}_3,a,\mbox{init}]$の処理状態をwaitに変更．
\item $[3,\mathrm{re}_4,e,\mbox{wait}]$について，
  処理状態をcheckに変更し，\\
  $[3,\mathrm{re}_5,e,\mbox{init}]$，
  $[3,\mathrm{re}_6,e,\mbox{init}]$，
  $[9,\mathrm{sh},e,\mbox{wait}]$を作成．
\item $[2,\mathrm{re}_3,e,\mbox{wait}]$について，
  処理状態をcheckに変更し，\\
  $[2,\mathrm{re}_5,d,\mbox{init}]$，
  $[2,\mathrm{re}_6,d,\mbox{init}]$，
  $[5,\mathrm{sh},d,\mbox{wait}]$を作成（図\ref{fig:chain}（2））．
\item $[5,\mathrm{sh},d,\mbox{wait}]$について，
  処理状態をcheckに変更し，\\
  $[2,\mathrm{re}_5,d,\mbox{init}]$，$[2,\mathrm{re}_6,d,\mbox{init}]$の
  処理状態をwaitに変更．
\item $[9,\mathrm{sh},e,\mbox{wait}]$について，
  処理状態をcheckに変更し，\\
  $[3,\mathrm{re}_5,e,\mbox{init}]$，$[3,\mathrm{re}_6,e,\mbox{init}]$の
  処理状態をwaitに変更．
\item $[2,\mathrm{re}_5,d,\mbox{wait}]$について，
  処理状態をcheckに変更し，
  $[2,\mathrm{sh},b,\mbox{init}]$，
  $[6,\mathrm{sh},c,\mbox{wait}]$を作成．
\item $[2,\mathrm{re}_6,d,\mbox{wait}]$について，
  処理状態をcheckに変更し，
  $[2,\mathrm{sh},c,\mbox{init}]$を作成\\
  （$[6,\mathrm{sh},d,\mbox{wait}]$は，
  $\mathrm{connect}(d,d)=0$より作成しない）．
\item $[3,\mathrm{re}_5,e,\mbox{wait}]$について，
  処理状態をcheckに変更し，
  $[3,\mathrm{sh},b,\mbox{init}]$を作成\\
  （$[7,\mathrm{sh},c,\mbox{wait}]$は，
  $\mathrm{connect}(c,e)=0$より作成しない）．
\item $[3,\mathrm{re}_6,e,\mbox{wait}]$について，
  処理状態をcheckに変更し，
  $[3,\mathrm{sh},c,\mbox{init}]$，
  $[7,\mathrm{sh},d,\mbox{wait}]$を作成．
\item $[6,\mathrm{sh},c,\mbox{wait}]$について，
  処理状態をcheckに変更し，\\
  $[2,\mathrm{sh},b,\mbox{init}]$の処理状態をwaitに変更．
\item $[7,\mathrm{sh},d,\mbox{wait}]$について，
  処理状態をcheckに変更し，\\
  $[3,\mathrm{sh},c,\mbox{init}]$の処理状態をwaitに変更．
\item $[2,\mathrm{sh},b,\mbox{wait}]$について，
  処理状態をcheckに変更し，\\
  $[0,\mathrm{sh},a,\mbox{init}]$の処理状態をwaitに変更．
\item $[3,\mathrm{sh},c,\mbox{wait}]$について，
  処理状態をcheckに変更し，\\
  $[0,\mathrm{sh},b,\mbox{init}]$の処理状態をwaitに変更．
\item $[0,\mathrm{sh},a,\mbox{wait}]$について，
  処理状態をpassに変更．
\item $[0,\mathrm{sh},b,\mbox{wait}]$について，
  処理状態をpassに変更（図\ref{fig:chain}（3））．
\item $[0,\mathrm{sh},a,\mbox{pass}]$について，
  処理状態をendに変更し，\\
  $[2,\mathrm{sh},b,\mbox{check}]$の処理状態をpassに変更．
\item $[0,\mathrm{sh},b,\mbox{pass}]$について，
  処理状態をendに変更し，\\
  $[3,\mathrm{sh},c,\mbox{check}]$の処理状態をpassに変更．
\item $[2,\mathrm{sh},b,\mbox{pass}]$について，
  処理状態をendに変更し，\\
  $[6,\mathrm{sh},c,\mbox{check}]$の処理状態をpassに変更．
\item $[3,\mathrm{sh},c,\mbox{pass}]$について，
  処理状態をendに変更し，\\
  $[7,\mathrm{sh},d,\mbox{check}]$の処理状態をpassに変更．
\item 以下，同様に処理を続け，処理状態がpassの要素がなくなったら終了
（図\ref{fig:chain}（4））．
\end{enumerate}

\begin{table}[b]
  \caption{提案手法により作成されるLR表}
  \label{tab:lr_table}
\input{04table02.txt}
\end{table}

アルゴリズムを適用後，処理状態がendである動作要素をたどることにより，
成功パスを抽出できる（図\ref{fig:chain}（4）の実線のリンクが成功パスである）．
作成されるLR表を表\ref{tab:lr_table}に示す．
また，表\ref{tab:lr_table}において，括弧で囲まれた動作は，
Liの手法で削除できず，提案手法により削除されたものを表す．




提案アルゴリズムの完全性の証明
\label{sec:completeness}

本節では，提案アルゴリズムの完全性について考察する．
ここで，完全性とは，作成されるLR表に不要なアクションが存在しないことである．
これを示すためには，LR表が以下の2つの性質を満たすことを示せばよい．
\begin{itemize}
\item 妥当性

  任意の構文木$\mathit{tr}$に対し，以下が成り立つ．
\[
    \mathrm{Generate}(\mathit{tr}, G, C) = \mathrm{GenerateLR}(\mathit{tr}, T) 
\]

  ただし，
  \begin{description}
  \item[$G,C,T$:] CFG，接続制約，LR表
  \item[$\mathrm{Generate}(\mathit{tr},G,C)$:]
    文法$G$，接続制約$C$から構文木$\mathit{tr}$を生成可能ならば1，
    不可能ならば0
  \item[$\mathrm{GenerateLR}(\mathit{tr},T)$:]
    LR表$T$から構文木$\mathit{tr}$を生成可能ならば1，不可能ならば0
  \end{description}
\item 最小性

  妥当性を満たすLR表中の任意の要素（動作） $a$に対し，
  以下が成り立つような構文木$\mathit{tr}$が存在する．
\[
    \mathrm{GenerateLR}(\mathit{tr}, T) = 1  \wedge \mathrm{GenerateLR}(\mathit{tr}, T_a) = 0
\]

  ただし，
  \begin{description}
  \item[$T_a$:] LR表$T$から要素$a$を除いたLR表
  \end{description}
\end{itemize}

文法$G$は，第\ref{sec:principle}節で述べた，
$\varepsilon$規則を含まないという条件のほかに，
以下の条件を満たすことを前提とする．
\begin{enumerate}
\item 文法規則は重複しない．すなわち，文法$G$中の任意の2つの文法規則$A\to\alpha$，$B\to\beta$について，$A\neq B\vee\alpha\neq\beta$
\item 循環する導出は存在しない．すなわち，文法$G$中の任意の非終端記号$A$について，$A\stackrel{\ast}{\to}A$ となるような導出は存在しない
\end{enumerate}


\subsection{妥当性の証明}

提案アルゴリズムによって作成されるLR表が妥当性を満たすことを示すためには，
以下の2つを示せばよい．
\begin{enumerate}
\item $\mathrm{Generate}(\mathit{tr}, G, C) = 1$ ならば $\mathrm{GenerateLR}(\mathit{tr}, \mathrm{Table}(\mathit{ACG})) = 1$
\item $\mathrm{GenerateLR}(\mathit{tr}, \mathrm{Table}(\mathit{ACG})) = 1$ ならば $\mathrm{Generate}(\mathit{tr}, G, C) = 1$
\end{enumerate}
ただし，
\begin{description}
\item[$\mathit{ACG}$:]
  提案アルゴリズムによって生成されるアクションチェイングラフ
\item[$\mathrm{Table}(\mathit{ACG})$:] $\mathit{ACG}$から生成されるLR表
\end{description}

提案アルゴリズムでは，開始記号から最右導出を行いながら
アクションチェイングラフを生成し，
その中に含まれる成功パスからLR表を生成する．
ここで，$\mathrm{Generate}(\mathit{tr}, G, C) = 1$ を満たす構文木
$\mathit{tr}$ に相当する最右導出の際に，提案アルゴリズムによって生成される
アクションチェインは，成功パスである．
この成功パス中の要素に対応する動作は，
このアクションチェイングラフから生成されるLR表に含まれるので，
$\mathit{tr}$ は $\mathrm{Table}(\mathit{ACG})$ から生成可能である．
すなわち，
（1）
が成り立つ．

一方，ある構文木 $\mathit{tr}$ が
$\mathrm{GenerateLR}(\mathit{tr}, \mathrm{Table}(\mathit{ACG})) = 1$
を満たすと仮定する．
このとき， $\mathrm{Table}(\mathit{ACG})$ から $\mathit{tr}$ を
生成する際の実行動作列について，先頭の実行動作から順に，
以下の法則に従って $\mathit{ACG}$ 中のアクションチェイン要素を
たどることにより，成功パスを得ることができる．
\begin{itemize}
\item 注目する実行動作がacc動作の場合， $[0,\mathrm{re}_0,\$,\mathrm{end}]$ をたどる．
\item 注目する実行動作が状態$s$，先読み$\mathit{la}$におけるshift動作の場合，
  $[s,\mathrm{sh},\mathit{la},\mathrm{end}]$ をたどる．
\item 注目する実行動作が状態$s$，先読み$\mathit{la}$における
  規則番号$n$によるreduce動作，さらにその次の動作が
  状態$s^\prime$，非終端記号$\mathrm{LHS}(n)$における
  状態$s^{\prime\prime}$へのgoto動作の場合，
  $[s^\prime,\mathrm{re}_n,\mathit{la},\mathrm{end}]$ をたどる．
\end{itemize}
$\mathit{ACG}$ 中の成功パスに対応する構文木は
文法$G$，接続制約$C$を満たすので，
（2）
が成り立つ．

以上より，提案アルゴリズムによって作成されるLR表は妥当性を満たす．


\subsection{最小性の証明}

$T=\mathrm{Table}(\mathit{ACG})$ が最小性を満たさないと仮定すると，
次を満たす要素$a$が$T$中に少なくとも1つ存在する．
\begin{quotation}
  任意の$\mathit{tr}\in\{\mathit{tr}|\mathrm{GenerateLR}(\mathit{tr},T)=1\}$
  に対して，$\mathrm{GenerateLR}(\mathit{tr},T_a)=1$
\end{quotation}

このとき，$\{\mathit{tr}|\mathrm{GenerateLR}(\mathit{tr},T)=1\}\equiv\{\mathit{tr}|\mathrm{GenerateLR}(\mathit{tr},T_a)=1\}$
となり，$a$に対応する$\mathit{ACG}$中の要素を$e$とすると，
$\{\mathit{tr}|\mathrm{GenerateLR}(\mathit{tr},T_a)=1\}$中の任意の構文木を
生成する際の実行動作列に対応する$\mathit{ACG}$中の成功パスは，
$e$を含まない．

一方，$T$中に$a$が存在することから，
$\mathit{ACG}$中には$e$を含む成功パスが存在する．
その成功パスに対応する実行動作列は$a$を含み，
その実行動作列で生成される構文木を$\mathit{tr}^\prime$とすると，
以下が成り立つ．
\[
  \mathrm{GenerateLR}(\mathit{tr}^\prime, T) = 1 \wedge \mathrm{GenerateLR}(\mathit{tr}^\prime, T_a) = 0
\]
これは$T$が最小性を満たさないという仮定に矛盾する．

以上より，提案アルゴリズムによって作成されるLR表は最小性を満たす．



