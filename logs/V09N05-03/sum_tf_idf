================================================================
[section type  : abstract]
[section title : abstract]
================================================================
[i:0, score:0.38135] この論文で計算するものは，ある文字列を[MATH]回以上含むドキュメントの総数([MATH])である．
[i:2, score:0.33446] しかし，[MATH]の場合，Suffix Array，文字列のクラス分けを利用して，統計量をクラス毎に保存することで，これを[MATH]の表にできるという報告がある[CITE]．
[i:3, score:0.25883] このクラスは同じ統計量を持つ文字列の集合であり，コーパス内の全ての文字列の統計量はクラス毎に作成した統計量の表から取り出すことができる．

================================================================
[section type  : intro]
[section title : はじめに]
================================================================
[i:19, score:0.58044] ここで，重複度を考慮しないドキュメント頻度（単純ドキュメント頻度）については，ドキュメント頻度が同じ文字列をクラス分けができ，そのクラスごとに頻度を計測することが可能であるという報告[CITE]がある．
[i:24, score:0.60349] また，クラス分けをして，表を作成するならば，重複条件付きのドキュメント頻度は，クラスごと，つまりそのクラスを代表する一つの文字列についてのみ求めればよいが，単純な方法では，代表の文字列の個数が[MATH]，それぞれの計算に[MATH]かかることになり，全体で[MATH]の処理となる．
[i:29, score:0.55274] この論文では，重複条件付きドキュメント頻度の計測についても，クラス分けが使用できることを示し，その前処理として重複度の上限を与えた場合に，[MATH]で，クラスごとの重複条件付きドキュメント頻度の表を作ることができることを示す．

================================================================
[section type  : proposed_method]
[section title : 記号の定義]
================================================================
[i:35, score:0.39186] [MATH]は，文字列頻度と呼ばれるものであり，[MATH]は単純ドキュメント頻度と呼ばれるものである．
[i:37, score:0.38094] [MATH] :文字列[MATH]が1回以上出現するドキュメントの数
[i:38, score:0.39730] われわれが求めたい重複条件付きドキュメント頻度も[MATH]から求められるものである．

================================================================
[section type  : proposed_method]
[section title : Suffix Array]
================================================================
[i:42, score:0.27225] このデータ構造はあるテキストがあったときに，そのテキストのすべての文字からテキストの終了までの文字列(suffix;接尾辞)の集合を考え，その集合を辞書順に並べたものである．
[i:46, score:0.32907] /* size:コーパスの文字数, text:コーパスの先頭を指すポインタ*/ int suffix_compare(struct suffix_struct * x, struct suffix_struct * y) { return strcmp(text + x->position, text + y->position); /* x->position,y->positionはそれぞれx,yに対応する場所を指すポインタ*/ }
[i:49, score:0.39703] ドキュメント頻度を計算する場合，ドキュメントの長さに上限があればコーパス中の文字列はドキュメント毎に区切られていると見なすことができる．

================================================================
[section type  : proposed_method]
[section title : 文字列のクラス分け]
================================================================
[i:53, score:0.57960] 文字列の文献[CITE]の文字列のクラス分けの方法を使用するが，この論文では，重複条件付きドキュメント頻度を求める場合にもクラス分けを使用できることを述べる．
[i:71, score:0.42256] [性質1]クラス[MATH]があったとき，[MATH]の任意の2要素[MATH]，[MATH]について，任意のドキュメントを[MATH]とすると，[MATH]である．
[i:72, score:0.35877] 証明[MATH]は，[MATH]の中に出現する[MATH]の個数であるが，これは，[MATH]の出現する場所で，その場所がドキュメント[MATH]に属する回数に等しい．

================================================================
[section type  : proposed_method]
[section title : クラスの階層関係]
================================================================
[i:106, score:0.37524] [性質5] Suffix Arrayにおいて，すべてのsuffixはクラスによって階層構造を形成する．
[i:113, score:0.35299] 区間[MATH]において[MATH]，[MATH]なので，[MATH]となり，区間[MATH]は1つのsuffixからなる最下位クラスを形成する．
[i:114, score:0.39077] 証明性質5より，Suffix Arrayのすべてのsuffixはクラスによって階層構造を形成する．

================================================================
[section type  : proposed_method]
[section title : 重複条件付きドキュメント頻度の計測における問題点]
================================================================
[i:118, score:0.50983] すべてのクラスについて，それに属する文字列のドキュメント頻度を単純な方法で求めるとすると，通常の計算機では実用上問題がある．
[i:128, score:0.47029] このとき文字列abに続く文字のパターンがabcとabxの2つだけであったとすると，suffixの構造は図[REF_chofuku_df]に示されたような構造になる．
[i:132, score:0.61507] [CITE]で示されるように，単純なドキュメント頻度の計数であれば，重複して数えているところを差し引くという方法があるが，ドキュメントを計測する条件が，その文字列が2回以上出現するドキュメント数であった場合，クラスの上下によるドキュメント頻度の変化はさらに複雑になり，重複を差し引くという方法は使用できない．

================================================================
[section type  : proposed_method]
[section title : 出現場所の重複条件]
================================================================
[i:136, score:0.53878] 重複条件付きドキュメント頻度の計測のために，クラス階層で寄せ集められる数を定義し，その数の関数として重複条件付きドキュメント頻度を求めることを行う．
[i:140, score:0.58935] [定義]ある文字列[MATH]の出現場所の重複度が[MATH]であるとは，suffix順でその出現場所以下の場所で，かつ同一のドキュメントに属する文字列[MATH]の出現場所が[MATH]個あることとする．
[i:146, score:0.59972] [性質7]文字列[MATH]がドキュメント[MATH]に[MATH]個出現するとき，[MATH]個の出現場所について，すべて重複度を求め，それをsuffix順に並べると[MATH]となる．

================================================================
[section type  : proposed_method]
[section title : 重複条件付き文字列頻度]
================================================================
[i:147, score:0.47688] [記号][MATH]を文字列としたとき，重複条件付き文字列頻度[MATH]と重複条件付きドキュメント文字列頻度[MATH]と書く．
[i:149, score:0.44908] [定義][MATH]はドキュメント[MATH]中で，重複度が[MATH]以上の文字列[MATH]の出現数とする．
[i:152, score:0.38148] 重複度は，場所と文字列に関係するので注意が必要であるが，suffix順で順番をつけるので，[MATH]が定まれば，それぞれの要素についての重複度が一意に定まる．

================================================================
[section type  : proposed_method]
[section title : 重複条件付き文字列頻度とドキュメント頻度の関係]
================================================================
[i:154, score:0.46615] ドキュメント頻度と重複条件付き文字列頻度には下の単純な関係がある．
[i:161, score:0.51885] 図[REF_df_cf]の3つのドキュメントで，文字列abについて[MATH]，[MATH]を求める．
[i:164, score:0.46109] ドキュメント#2では，[MATH]であるので重複度[MATH]となる文字列abが一つだけ([MATH])存在する．

================================================================
[section type  : proposed_method]
[section title : 重複度判定のためのデータ構造]
================================================================
[i:180, score:0.47656] このデータ構造を作るには，ドキュメント数と同数の整数配列を用意して，それぞれの文字列の出現ごとに，ドキュメントの番号を求め，その配列からpreviousリンクの場所の情報を求めると同時に，その表を現在の場所に更新すればよい．
[i:183, score:0.47523] /* id_max:ドキュメント数，size:コーパスの文字数*/ for(i=0;i<id_max;i++) { last_suffixes[i] = -1; } for(i=0;i<size;i++) { suffix[i].
[i:187, score:0.48355] 重複度判定は，このpreviousリンクを[MATH]回たどることができ，かつその文字列が同じドキュメントにあるかどうかで判定できる．

================================================================
[section type  : proposed_method]
[section title : クラス検出のアルゴリズム]
================================================================
[i:198, score:0.34644] [MATH]はコーパスの文字列と同じ大きさの配列で，Suffix Arrayで次のsuffixと文字列が一致している長さである．
[i:199, score:0.38026] この文字列はドキュメントの長さを越えることはなく，したがって，計算量のオーダを増やすことはない．
[i:210, score:0.59055] [性質10]現在計算中のsuffixから始まり，ドキュメントの区切りまでの文字列を属するクラス毎に分類すると，そのクラスは現在計算中のクラスとなる．

================================================================
[section type  : proposed_method]
[section title : 単純な重複条件付き文字列頻度の計数]
================================================================
[i:212, score:0.35086] 重複度は文字列と場所の関数であるが，同一クラスに属する文字列の重複度が異なることはない．
[i:214, score:0.32082] そこでクラスの数だけのカウンタを用意し，各suffixについて処理を行なうことでも計数できる．
[i:217, score:0.34336] 計数の方法は，ある場所について，そこから始まるクラスの集合を求め，すべてのクラスに対してカウンタを用意し，クラス毎に重複度が[MATH]以上であるかを判定して，カウンタに1を加えるというものである．

================================================================
[section type  : proposed_method]
[section title : 重複条件付き文字列頻度の計数]
================================================================
[i:220, score:0.52065] 重複条件付き文字列頻度の計数を単純な方法で行うと，一つのsuffixに対し，それが含まれるクラスをすべて求め，そのクラスのすべてに対してカウンタの更新を行わなければならない．
[i:223, score:0.50033] [性質12]ある場所が与えられたとき，そこのsuffixの先頭の文字列に対応するクラスのうち，あるクラスの文字列について重複度が[MATH]であったとすると，そのクラスより上位のクラスの重複度は[MATH]以上である．
[i:225, score:0.45256] つまり，あるsuffixで重複度[MATH]以上となるクラスのうち，最下位のクラスのカウンタだけを加算しておき，下位クラスの計数が終了したときに，上位のクラスのカウンタにその計数値を加算していくことで，すべてのクラスの計数値を得ることができる．

================================================================
[section type  : proposed_method]
[section title : クラスの発見と頻度計算]
================================================================
-----------------------------------------------------
  [subsection title : クラスの始まりを発見したときの処理]
-----------------------------------------------------
  [i:lead, score:0.16156] あるクラスの始まりは[MATH]が増加したことで発見できる．
.....
  [i:227, score:0.42503] このとき，現在計測している重複条件付き文字列頻度の情報はほかのクラスの情報と同様にスタックに待避させ，重複条件付き文字列頻度は0に初期化して新たに計数する．
-----------------------------------------------------
  [subsection title : 重複度判定とクラス選択の融合]
-----------------------------------------------------
  [i:lead, score:0.28884] ある場所で，重複度が[MATH]より大きいクラスのなかで最も下位のクラスを特定する操作は，重複度判定と融合することができる．
.....
  [i:229, score:0.59969] 重複度の判定はpreviousリンクを[MATH]回たどった場所[MATH]と，現在の場所[MATH]の区間が一つのドキュメントに含まれるかどうかで行うので，逆にその区間を含むクラスの集合を求めておき，その中で[MATH]を求めることができる．
  [i:231, score:0.35612] これは，「ある場所で，重複度が[MATH]より大きい[MATH]」を定める区間[MATH]が，現在の場所[MATH]を終りに持つため，検出の途中では計算未終了のクラスとなっていることを利用する．
  [i:234, score:0.34918] そのクラスの重複条件付き文字列頻度を加算する．
-----------------------------------------------------
  [subsection title : クラスの終了を発見したときの処理]
-----------------------------------------------------
  [i:lead, score:0.16618] あるクラスの終了は[MATH]が減少することで発見できる．
.....
  [i:235, score:0.16618] あるクラスの終了は[MATH]が減少することで発見できる．
  [i:236, score:0.17114] このとき，上位クラスへ計数の値を伝える処理をする．
  [i:237, score:0.23655] 下位クラスの計数が終了したときに上位クラスのカウンタに，その計数値を加算することで，結果的にすべてのクラスに加算するのと同じ値を得ることができる．

================================================================
[section type  : proposed_method]
[section title : 実行例]
================================================================
[i:238, score:0.00830] サンプルとして処理するデータは以下のファイルである．
[i:239, score:0.27401] 一行が一つのドキュメントになっている．
[i:240, score:0.05660] abcabcabc abcd abcde bcde
-----------------------------------------------------
  [subsection title : Suffix Arrayの作成とクラス検出の準備]
-----------------------------------------------------
  [i:lead, score:0.09088] 第一段階では，Suffix Arrayを作成し，commonをもとめ，Previous Linkを作成する．
.....
  [i:245, score:0.39726] suffixが属するドキュメントの番号
  [i:246, score:0.39954] 同じドキュメントに属しているsuffixで，直前に現れたものの番号
  [i:247, score:0.24792] 直後のsuffixと「先頭から一致している文字列」の長さ
-----------------------------------------------------
  [subsection title : 求められたクラスの表の例]
-----------------------------------------------------
  [i:lead, score:0.16204] 本文で説明した方法で，[MATH]が2より大きなクラスを求める．
.....
  [i:252, score:0.40193] これを，クラスの先頭の場所を第1キー，長さを第2キーにしてソートし，同時に，重複条件付き文字列頻度から，文書頻度に変換する．
  [i:261, score:0.31830] 区間の先頭が同じ場合には，長さが短いほうが優先されることで，結果としてクラスの代表する文字列は辞書順に並ぶ．
  [i:262, score:0.44885] total=14 Class[ 4, 8] L=3 tf=5 df1=3 df2=1 df3=1 df4=0 S="abc" Class[ 5, 6] L=6 tf=2 df1=1 df2=1 df3=0 df4=0 S="abcabc" Class[ 7, 8] L=4 tf=2 df1=2 df2=0 df3=0 df4=0 S="abcd" Class[ 9, 14] L=2 tf=6 df1=4 df2=1 df3=1 df4=0 S="bc" Class[ 10, 11] L=5 tf=2 df1=1 df2=1 df3=0 df4=0 S="bcabc" Class[ 12, 14] L=3 tf=3 df1=3 df2=0 df3=0 df4=0 S="bcd" Class[ 13, 14] L=4 tf=2 df1=2 df2=0 df3=0 df4=0 S="bcde" Class[ 15, 20] L=1 tf=6 df1=4 df2=1 df3=1 df4=0 S="c" Class[ 16, 17] L=4 tf=2 df1=1 df2=1 df3=0 df4=0 S="cabc" Class[ 18, 20] L=2 tf=3 df1=3 df2=0 df3=0 df4=0 S="cd" Class[ 19, 20] L=3 tf=2 df1=2 df2=0 df3=0 df4=0 S="cde" Class[ 21, 23] L=1 tf=3 df1=3 df2=0 df3=0 df4=0 S="d" Class[ 22, 23] L=2 tf=2 df1=2 df2=0 df3=0 df4=0 S="de" Class[ 24, 25] L=1 tf=2 df1=2 df2=0 df3=0 df4=0 S="e"
-----------------------------------------------------
  [subsection title : 文字列に対する処理]
-----------------------------------------------------
  [i:lead, score:0.13807] 与えられた任意の文字列に対して，上記の表を二分探索することで[MATH]を求めることができる．
.....
  [i:263, score:0.13807] 与えられた任意の文字列に対して，上記の表を二分探索することで[MATH]を求めることができる．
  [i:264, score:0.05371] 二分探索であり，表の大きさは[MATH]であるので，この処理は[MATH]で終了する．
  [i:265, score:0.32297] abc -- Class[4,8]に該当（代表文字列）5 3 1 1 0 abc abcabc -- Class[5,6]に該当（代表文字列）2 1 1 0 0 abcabc abcd -- Class[7,8]に該当（代表文字列）2 2 0 0 0 abcd abca -- Class[5,6]に該当（代表文字列でない）2 1 1 0 0 abca abcab -- Class[5,6]に該当（代表文字列でない）2 1 1 0 0 abcab abcabc -- Class[5,6]に該当（代表文字列）2 1 1 0 0 abcabc abcabca --表になく，コーパスに存在する1 1 0 0 0 abcabca abcabcab --表になく，コーパスに存在する1 1 0 0 0 abcabcab abcabcabc --表になく，コーパスに存在する1 1 0 0 0 abcabcabc abcabcabca --表になく，コーパスに存在しない0 0 0 0 0 abcabcabca

================================================================
[section type  : proposed_method]
[section title : 実行時間の計測]
================================================================
[i:266, score:0.33380] 実行時間の計測は，どのようなドキュメントを用いても良いが，ここでは，技術用語のアブストラクトの集合を使用した．
[i:267, score:0.28985] そこからアブストラクトの本文だけを抜き出し，一行を一つのドキュメントに整形したものである．
[i:268, score:0.13651] 332,918文書，69,312,280文字，130,993,215バイトのコーパスである．
-----------------------------------------------------
  [subsection title : ボトムラインシステム]
-----------------------------------------------------
  [i:lead, score:0.04538] 最初の比較対象のシステムは，一番単純な方法で計測した場合である．
.....
  [i:271, score:0.48390] 文字列と重複度[MATH]が与えられたときに，[MATH]のドキュメント頻度をは，コーパスの先頭から順番に見るという方針で求めるものである．
  [i:273, score:0.16201] これば，クラス分けもクラスの階層構造も利用しないシステムとなっている．
  [i:278, score:0.26359] */ int dfn(int k, char *s) { int i; /* string position */ int t; /* term frequency in a document */ int n; /* document frequency */ n = 0; t = 0; for(i=0;i<size;i++) { if(string_sub(&text[i], s)) t++; if(text[i]=='\n') { if(t>=k) n++; t = 0; } } return n; }
-----------------------------------------------------
  [subsection title : ベースラインシステム]
-----------------------------------------------------
  [i:lead, score:0.17996] ベースラインシステムは，クラス分けを使用しているが，表を作成するときにクラスの階層構造を使用しないシステムである．
.....
  [i:280, score:0.18997] クラスの検出のあと，下のCのプログラムを使って，[MATH]から[MATH]までを同時にもとめて表にする．
  [i:282, score:0.41337] /*重複条件付きドキュメント頻度を一斉に求める関数結果は，staticな配列に保存する．
  [i:283, score:0.28583] */ static int dfn[MAX_C]; static void count_dfn(char *s, int len) { int i; /* string position */ int t; /* term frequency in a document */ int n; /* document frequency */ int k; n = 0; t = 0; for(k=0;k<MAX_C;k++) { dfn[k]=0; }; for(i=0;i<size;i++) { if(strncmp(&text[i], s, len)==0) t++; if(text[i]=='\n') { for(k=0;k<MAX_C;k++) { if(t>k) dfn[k]++; } t = 0; } } }
-----------------------------------------------------
  [subsection title : 提案システム]
-----------------------------------------------------
  [i:lead, score:0.20759] 提案するシステムはこの論文で記述した方法を用いたものであり，クラスの表を作成し，表の数値を計数するときに，クラスの階層の性質を使用したものである．
.....
  [i:285, score:0.01419] このシステムをclassと呼ぶことにする．
-----------------------------------------------------
  [subsection title : 計測]
-----------------------------------------------------
  [i:lead, score:0.40805] 実験は，10個のドキュメントのなかに含まれる文字列頻度が3をこえるすべての文字列について，[MATH]，[MATH]，[MATH]，[MATH]，[MATH]，[MATH]，[MATH]を求めることを行った．
.....
  [i:288, score:0.43767] 実行時間は，前処理の時間と，重複条件付きのドキュメント頻度を求める時間とに分けて計測した．
  [i:292, score:0.48934] 重複条件付きドキュメント頻度の分析対象とした文字列は，10ドキュメント，4156バイト，2190文字の部分文字列で，統計的に安定な頻度が3を越える文字列である．
  [i:304, score:0.43084] 以上，クラス分けによる表の作成と，クラスの階層構造を利用することによって，はじめて10万を越えるドキュメント数に対して分析ができるようになったことがわかる．
-----------------------------------------------------
  [subsection title : メモリ容量負荷]
-----------------------------------------------------
  [i:lead, score:0.11000] プログラムで使用するメモリの量を示すために，実行しているプロセスの大きさを計測する．
.....
  [i:309, score:0.16531] そして，表の作成に，1クラスあたり100バイト，表の検索に，1クラスあたり50バイト使用していることがわかる．
  [i:310, score:0.25205] 表の検索のプログラムは，クラス分けの表とSuffix Arrayを保持しており，プロセスの大きさの主要な部分は，その大きさである．
  [i:311, score:0.26473] 表を作成するには，クラス検出のためのデータ構造や，重複度判定のためのデータ構造などがあり，分析処理よりもメモリを多く必要とする．

================================================================
[section type  : proposed_method]
[section title : そのほかの応用]
================================================================
[i:312, score:0.49712] 任意の文字列について，前処理の後に[MATH]で重複条件付きドキュメント頻度の分析を行うことは，文字列の統計処理の基本技術であり，ここで述べた単語の境界の分析以外にも応用範囲がある．
-----------------------------------------------------
  [subsection title : 情報検索への応用]
-----------------------------------------------------
  [i:lead, score:0.40829] 日本語，中国語などの情報検索では２文字の文字列に対して，ドキュメント頻度を計測して，2文字に対して情報検索の重みを計算することが行われている．
.....
  [i:313, score:0.40829] 日本語，中国語などの情報検索では２文字の文字列に対して，ドキュメント頻度を計測して，2文字に対して情報検索の重みを計算することが行われている．
  [i:314, score:0.40368] [MATH]は，Adaptationと呼ばれる量で，ドキュメントの確率という空間において，ドキュメントにある文字列が出現するということを条件としたとき，そのドキュメントに2回文字列が出現する確率の推定値である．
  [i:317, score:0.14896] あらかじめ表を作成するのが難しいため，この報告の処理対象は2文字に限られていたが，ここで述べた方法を使って，任意の長さの文字列から検索に効果のある文字列を選びだし，情報検索の性能を向上させるのは有望な応用の一つだと考えられる．
-----------------------------------------------------
  [subsection title : 遺伝子情報への応用]
-----------------------------------------------------
  [i:lead, score:0.48575] 文献[CITE]は，自然言語で書かれたドキュメントを分析対象として，辞書を使わず，重複条件付きドキュメント頻度からキーワードを抽出していたが，これは「あるドキュメントに繰り返し現れる文字列」を効果的に取り出すシステムと解釈できる．
.....
  [i:318, score:0.48575] 文献[CITE]は，自然言語で書かれたドキュメントを分析対象として，辞書を使わず，重複条件付きドキュメント頻度からキーワードを抽出していたが，これは「あるドキュメントに繰り返し現れる文字列」を効果的に取り出すシステムと解釈できる．
  [i:319, score:0.05048] これを遺伝子情報に適用して，「遺伝子に繰り返し現れるDNA配列」を検出するのは有望な応用の一つと考えられる．
  [i:320, score:0.31308] 遺伝子の長さを考えると，ここで示した方法をつかってはじめて，遺伝子のドキュメント頻度の分析ができるようになると考えられる．
-----------------------------------------------------
  [subsection title : プログラミングツールへの応用]
-----------------------------------------------------
  [i:lead, score:0.16340] 文献[CITE]は，文字列の頻度を分析して，プログラム中にまれにしか現れない文字列を検出し，それがプログラムの欠損の判定に効果があることを示している．
.....
  [i:321, score:0.16340] 文献[CITE]は，文字列の頻度を分析して，プログラム中にまれにしか現れない文字列を検出し，それがプログラムの欠損の判定に効果があることを示している．
  [i:322, score:0.49325] このツールにおいて，使用しているのは文字列の総出現頻度だけであるが，重複条件付きドキュメント頻度はプログラム中の構造がより精密に判定できる情報源である．
  [i:323, score:0.01990] あらたな情報が提供されれば，このようなツールの検出性能が向上することが期待できる．

================================================================
[section type  : conclusion]
[section title : まとめ]
================================================================
[i:325, score:0.55100] その経過において，まず，出現場所の集合という概念を示すことで，既存のクラス分けの方法が重複条件付きドキュメント頻度の計数に使えることを述べた．
[i:326, score:0.58926] 次に，クラスの階層関係を利用して計数できる重複条件付文字列頻度を説明し，それを用いて重複条件付きドキュメント頻度の表を構成できることを述べた．
[i:327, score:0.49142] 最後に，クラス分けの効果とクラスの階層構造の利用が処理に効果があることを，332,918個のドキュメントをもつコーパスで検証し，ドキュメントの長さを[MATH]とするとき，前処理の処理時間が[MATH]であり，表を引く処理が[MATH]であることを確かめた．

