[MATH]を，ドキュメント[MATH]に含まれる文字列[MATH]の個数と定義する．
この論文で扱う頻度は，[MATH]で定義できるものである．
[MATH]は，文字列頻度と呼ばれるものであり，[MATH]は単純ドキュメント頻度と呼ばれるものである．
[MATH] :ドキュメント集合中に文字列[MATH]が出現する数
[MATH] :文字列[MATH]が1回以上出現するドキュメントの数
われわれが求めたい重複条件付きドキュメント頻度も[MATH]から求められるものである．
[MATH] :文字列[MATH]が[MATH]回以上出現するドキュメントの数
クラス分けのために，Suffix Arrayというデータ構造を用いる．
Suffix Arrayは文献[CITE]によって示されたデータ構造である(図[REF_suffix_array])．
このデータ構造はあるテキストがあったときに，そのテキストのすべての文字からテキストの終了までの文字列(suffix;接尾辞)の集合を考え，その集合を辞書順に並べたものである．
ここで，テキストの本体がメモリにあるとすると，一つの文字列を格納するのに，文字列の開始場所という一つの整数を格納すれば良い．
このため，任意の部分文字列の場所を知ることができるにもかかわらず，必要な記憶容量は[MATH]で済む．
Suffix Arrayは以下のルーチンで生成できる．
/* size:コーパスの文字数, text:コーパスの先頭を指すポインタ*/ int suffix_compare(struct suffix_struct * x, struct suffix_struct * y) { return strcmp(text + x->position, text + y->position); /* x->position,y->positionはそれぞれx,yに対応する場所を指すポインタ*/ }
for(i=0;i<size;i++) { suffix[i].
position = i; } qsort(suffix, size, sizeof(struct suffix_struct), suffix_compare);
ドキュメント頻度を計算する場合，ドキュメントの長さに上限があればコーパス中の文字列はドキュメント毎に区切られていると見なすことができる．
この条件の下で上記のアルゴリズムを使ってデータ構造を作成するためには，[MATH]時間必要である．
[htbp]
\epsfxsize=9cm \epsfbox{suffix_array.eps}
文字列の文献[CITE]の文字列のクラス分けの方法を使用するが，この論文では，重複条件付きドキュメント頻度を求める場合にもクラス分けを使用できることを述べる．
クラス分けはsuffixを用いて定義される．
Suffix Arrayのsuffixは辞書順に並んでいるので，文字列の先頭部分が次のsuffixと共通であることが多い．
そこで，[MATH]を[MATH]と[MATH]の文字列の先頭からの共通部分とする．
文献[CITE]のクラスの定義を下に示す．
ここで，定義の記述を簡単にするため[MATH]の場合[MATH]とする．
そして，[MATH]，[MATH]とする．
区間の境界での[MATH]の大きい方である[MATH]と定義し，区間内部での[MATH]の最小のもの[MATH]と定義する．
[定義]区間[MATH]がクラスを形成するとは，[MATH]であることをいう．
[MATH]は区間全体で共通部分となる文字列の長さであり，[MATH]であるとは区間を広げると全体で共通となる文字列が短くなるという意味となる．
区間[MATH]がクラスを形成するとき，区間[MATH]に共通する「長さ[MATH]から[MATH]までの部分文字列」の集合を，その区間に対応する文字列のクラスと定義する．
図[REF_suffix_array_class]で，区間[MATH]，[MATH]，[MATH]を見た場合，
となり，区間[MATH]は[MATH]，区間[MATH]は[MATH]となるのでクラスを形成するが，区間[MATH]は[MATH]となるのでクラスを形成しない．
[htbp]
\epsfxsize=7cm \epsfbox{suffix_array_class.eps}
文献[CITE]によると，クラス数は最大でも[MATH]であり，その表は作成し記憶することが実際的な大きさである．
[[MATH]の定義]クラス[MATH]で定まる区間[MATH]について，集合[MATH]を[MATH]とする．
[MATH]は，出現場所を示す整数の集合となる．
[性質1]クラス[MATH]があったとき，[MATH]の任意の2要素[MATH]，[MATH]について，任意のドキュメントを[MATH]とすると，[MATH]である．
証明[MATH]は，[MATH]の中に出現する[MATH]の個数であるが，これは，[MATH]の出現する場所で，その場所がドキュメント[MATH]に属する回数に等しい．
[MATH]の出現する場所は，[MATH]の属するクラス[MATH]の[MATH]で求まる．
[MATH]は，[MATH]の各要素である整数が，ドキュメント[MATH]に属しているかどうかで求めることができる．
つまり，[MATH]の属する[MATH]について，[MATH]の出現する位置の集合[MATH]を求めて，それから[MATH]を決定できる．
ここで，[MATH]が[MATH]と同じクラスの属していれば，両方とも[MATH]が同じであるため，[MATH]となる．
[性質2]クラス[MATH]があったとき，[MATH]の任意の2要素[MATH]，[MATH]について，
[MATH]
[MATH]
[MATH]
が成立する．
証明
性質1より，[MATH]なので，[MATH]を使用して定義できる頻度はすべて等しい．
すなわち，
証明は単純であるが，[MATH]の性質は未知であるため，同じクラスに属する文字列について，その値が等しいことを示すことは必要である．
クラスごとの頻度の表を高速に作成するために，クラス間の階層関係を利用するが，まず，クラスの階層関係を定義する．
区間[MATH]がクラス[MATH]を形成し，区間[MATH]がクラス[MATH]を形成していて，区間[MATH]が区間[MATH]に含まれているとき，[MATH]は[MATH]の下位のクラスと定義する．
また，[MATH]は[MATH]の上位のクラスと定義する．
[htbp]
\epsfxsize=7cm \epsfbox{class_kankei.eps}
[性質4] 2つのクラス[MATH]，[MATH]に交わりがあったときには，[MATH]は[MATH]の上位のクラスであるか[MATH]は[MATH]の下位のクラスであるかのどちらかである．
証明
[MATH]と[MATH]に交わりがあるということは，
のいずれかである．
[MATH]の場合，[MATH]であると仮定する．
区間[MATH]では
となるので，[MATH]である．
一方，区間[MATH]では，[MATH]，[MATH]となる[MATH]，[MATH]が存在する．
従って，
となり，区間[MATH]は
を満たさず，[MATH]の場合クラス[MATH]を形成しないので[MATH]と[MATH]に交わりはない．
[MATH]の場合はクラスの階層の定義より，[MATH]が[MATH]の上位クラスである，または，等しいクラスである．
[MATH]も[MATH]と同様に証明できる．
また，[MATH]の場合はクラスの階層の定義より，[MATH]が[MATH]の上位クラスであるか等しいクラスであり，[MATH]の場合は，[MATH]が[MATH]の上位クラスである，または，等しいクラスである．
以上より，2つのクラスに交わりがある場合は，一方がもう一方の上位クラス，または，下位クラスとなる．
[性質5] Suffix Arrayにおいて，すべてのsuffixはクラスによって階層構造を形成する．
証明
[MATH]より，最上位クラスは，すべてのsuffixを含むクラスである．
また，性質4よりあるクラスが他のクラスの部分クラスでない限り交わることはない．
このとき，部分クラスでは上位クラスよりその区間が短くなる．
以上のことから，すべての文字列の出現場所は文字列クラスによって階層構造を形成する．
[性質6]任意の区間[MATH]について，[MATH]を含む区間でクラスを形成する区間がある．
区間[MATH]において[MATH]，[MATH]なので，[MATH]となり，区間[MATH]は1つのsuffixからなる最下位クラスを形成する．
証明性質5より，Suffix Arrayのすべてのsuffixはクラスによって階層構造を形成する．
[記号]任意の区間[MATH]について，それを含むクラスを形成する区間のうち，もっとも下位のものを[MATH]から定まるクラスとし，[MATH]と記述する．
任意の区間について，それを含むもっとも下位のクラスが一意に定まることは，計算量を押さえたアルゴリズムを構成するときに必要な性質である．
[MATH]は，後述する頻度を計数するところで使用する．
すべてのクラスについて，それに属する文字列のドキュメント頻度を単純な方法で求めるとすると，通常の計算機では実用上問題がある．
クラスの大きさが高々[MATH]であったとしても，[MATH]，[MATH]，[MATH]のように条件を満たす集合を作って，その大きさを計測すると，各[MATH]の処理に[MATH]時間かかり，[MATH]が[MATH]個あれば，全体では[MATH]時間必要となる．
これは，コーパスの大きさから考えて，通常の計算機では実行できない処理となる．
文字列の出現頻度であれば，クラス階層に従って頻度の合計を求めることができる．
すなわち，下位のクラスの文字列頻度を合計して，上位の文字列頻度とすることができる．
言い換えれば，長い文字列の頻度から，短い文字列の頻度をもとめることができる．
しかし，ドキュメント頻度は，直接寄せ集めることができない．
たとえば，図[REF_chofuku_df]のようなコーパスについて考える．
文字列abcは6回出現し，それが出現するドキュメントの数が4個である．
また，文字列abxは7回出現し，それが出現するドキュメントの数が5個である．
このとき文字列abに続く文字のパターンがabcとabxの2つだけであったとすると，suffixの構造は図[REF_chofuku_df]に示されたような構造になる．
この状況で，abの出現回数は6+7回である．
しかし，この状況で，abが出現するドキュメントの数は9個とはいえない．
abcとabxが両方出現するドキュメントを2個と数えることが間違いだからである．
[CITE]で示されるように，単純なドキュメント頻度の計数であれば，重複して数えているところを差し引くという方法があるが，ドキュメントを計測する条件が，その文字列が2回以上出現するドキュメント数であった場合，クラスの上下によるドキュメント頻度の変化はさらに複雑になり，重複を差し引くという方法は使用できない．
[htbp]
\epsfxsize=12cm \epsfbox{chofuku_df.eps}
重複条件付きドキュメント頻度の計測行う準備として，この論文で新しく使用する「文字列の出現場所ごとの重複条件」を定義する．
重複条件付きドキュメント頻度の計測のために，クラス階層で寄せ集められる数を定義し，その数の関数として重複条件付きドキュメント頻度を求めることを行う．
ここで使用する頻度を定義するために，文字列の出現場所の重複度と重複条件を使用する．
すべての文字列の出現場所は，Suffix Array内の配列の番号で順序づけることができる．
この順序をsuffix順と定義し，これを利用して文字列の出現場所の重複条件と重複度を定義する．
[定義]ある文字列[MATH]の出現場所の重複度が[MATH]であるとは，suffix順でその出現場所以下の場所で，かつ同一のドキュメントに属する文字列[MATH]の出現場所が[MATH]個あることとする．
図[REF_chofuku]に重複度の例を示す．
suffix順でabx(suffix[3])以下の場所にあるのは，abc(suffix[0])とabd(suffix[1])，abe(suffix[2])，abx(suffix[3])である．
ここで，文字列abxについてdocument#1での文字列abの重複度[MATH]を求めると，ドキュメント中に文字列abc，abd，abxが出現するので，[MATH]である．
[htbp]
\epsfxsize=10cm \epsfbox{chofuku.eps}
[性質7]文字列[MATH]がドキュメント[MATH]に[MATH]個出現するとき，[MATH]個の出現場所について，すべて重複度を求め，それをsuffix順に並べると[MATH]となる．
[記号][MATH]を文字列としたとき，重複条件付き文字列頻度[MATH]と重複条件付きドキュメント文字列頻度[MATH]と書く．
[定義][MATH]はコーパス中で，重複度が[MATH]以上の文字列[MATH]の出現数とする．
[定義][MATH]はドキュメント[MATH]中で，重複度が[MATH]以上の文字列[MATH]の出現数とする．
[性質8]
文字列[MATH]の属するクラスを[MATH]とする．
重複度は，場所と文字列に関係するので注意が必要であるが，suffix順で順番をつけるので，[MATH]が定まれば，それぞれの要素についての重複度が一意に定まる．
したがって，[MATH]は[MATH]と同様に[MATH]と[MATH]の関数となる．
ドキュメント頻度と重複条件付き文字列頻度には下の単純な関係がある．
[定理文字列頻度とドキュメント頻度の関係]
証明
[MATH]のとき，[MATH]について，
[MATH]のとき[MATH], [MATH], [MATH],以下0が続くので，[MATH]について，
[MATH]であるので，
あるテキストにおいて，[MATH]と[MATH]を実際に求めた例を図[REF_df_cf]に示す．
図[REF_df_cf]の3つのドキュメントで，文字列abについて[MATH]，[MATH]を求める．
まず，[MATH]を計算する．
[MATH]，[MATH]である，ドキュメント#1，#3は，重複度[MATH]となる文字列abが存在しないため，[MATH]の数え上げに関係しない．
ドキュメント#2では，[MATH]であるので重複度[MATH]となる文字列abが一つだけ([MATH])存在する．
したがって，[MATH]．
同様に，[MATH]は，[MATH]，[MATH]となり，ドキュメント#1，#2によってそれぞれ1と2がカウントアップされるので，[MATH]となる．
他も同様である．
この様に[MATH]が求められたので，定理「文字列頻度とドキュメント頻度の関係」を用いることで，[MATH]を計算できる．
[htbp]
\epsfxsize=10cm \epsfbox{df_cf.eps}
[性質9]あるクラス[MATH]があったとき，その要素[MATH]については任意の[MATH]について，
証明[MATH]，[MATH]なので，
ここでは重複度を判定するためのデータ構造であるpreviousリンク(文献[DF1])について説明する．
previousリンクはそれぞれのsuffixについて，同じドキュメントに属し，かつsuffix順で前にある最も近いsuffixの順位を記録しておく．
もしそのような場所がなければ，-1をpreviousリンクとする．
このデータ構造はコーパスの大きさに比例した大きさのメモリ領域である．
文字列[MATH]のある出現重複度が[MATH]以上であることの判定は，その出現場所からpreviousリンクを[MATH]回たどれるかどうかと，たどれる場合，その文字列がまだ出現しているかを計測することで判定できる(図[REF_chofuku_struct])．
[htbp]
\epsfxsize=12cm \epsfbox{chofuku_struct.eps}
このデータ構造を作るには，ドキュメント数と同数の整数配列を用意して，それぞれの文字列の出現ごとに，ドキュメントの番号を求め，その配列からpreviousリンクの場所の情報を求めると同時に，その表を現在の場所に更新すればよい．
previousリンクを作成するプログラムは以下のような構造になる．
このデータ構造を作成するには，ドキュメント数と同じメモリ領域を用意し，コーパス全体を一度スキャンすることになる．
/* id_max:ドキュメント数，size:コーパスの文字数*/ for(i=0;i<id_max;i++) { last_suffixes[i] = -1; } for(i=0;i<size;i++) { suffix[i].
previous_suffix = last_suffixes[suffix[i].
id]; last_suffixes[suffix[i].
id] = i; }
重複度判定は，このpreviousリンクを[MATH]回たどることができ，かつその文字列が同じドキュメントにあるかどうかで判定できる．
(注)実際のプログラムでは，計算量を押さえるため，単純に重複度を判定せず，この重複度の判定と別の処理を同時に行っている．
クラスを検出するアルゴリズムの概略は以下のように行う．
Suffix Arrayをsuffix順が小さいものから見て行く．
クラスの開始場所を見つける．
クラスの終了場所を探す．
クラスは階層構造になっているため，そのクラスの終了場所が見つかる前に，他のクラスの開始場所が見つかることがある．
この場合は，スタックにその開始場所をプッシュする．
クラスの終了場所が見つかれば，報告しスタックを回復する．
上記のアルゴリズムでクラスを求めていったとき，求めるクラスの先頭が発見できていて，まだ，その終りが発見できていないクラスを計算中のクラスと呼ぶことにする．
アルゴリズムでは，スタック中のクラスを現在計算中のクラスとする．
[MATH]はコーパスの文字列と同じ大きさの配列で，Suffix Arrayで次のsuffixと文字列が一致している長さである．
この文字列はドキュメントの長さを越えることはなく，したがって，計算量のオーダを増やすことはない．
文字列のクラスは，[MATH]の増減にしたがっている．
[MATH]が増加したときは，現在計算中のクラスを計算終了していないクラスとして登録し，新しいクラスが開始したものとして処理する．
[MATH]が減少しているときは次の2つのケースがある．
現在のクラスは終了するが，実は現在のクラスと同じsuffixの場所から始まったクラスが，現在のクラス以外にもある場合．
現在のクラスを終了し，スタックトップのクラスの処理を継続しなければならない場合．
2番目のケースで，スタックトップの計算途中のクラスの処理を継続するときには，このクラスがすぐに終了しているかどうかの検査から処理を継続する．
クラスの発見をするには[MATH]ごとに，クラス終了判定の操作を行うことになる．
2番目のケースでは，計算途中のクラスの数だけ繰り返しが起きるのだが，その繰り返しの数を合計してもクラスの最大数を越えることはない．
したがって，クラスの最大数と[MATH]の個数からこの操作は[MATH]で完了できる．
現在計算中のクラスについて，以下の性質が成り立つ．
[性質10]現在計算中のsuffixから始まり，ドキュメントの区切りまでの文字列を属するクラス毎に分類すると，そのクラスは現在計算中のクラスとなる．
重複度[MATH]が与えられていたとき，すべての文字列[MATH]に対して重複度が[MATH]以上である[MATH]を求めることを考える．
重複度は文字列と場所の関数であるが，同一クラスに属する文字列の重複度が異なることはない．
また，同一クラスに属する文字列について，[MATH]は等しい．
そこでクラスの数だけのカウンタを用意し，各suffixについて処理を行なうことでも計数できる．
これを単純な方法とよぶ．
この方法はメモリ領域[MATH]であるが，計算時間が問題となる．
計数の方法は，ある場所について，そこから始まるクラスの集合を求め，すべてのクラスに対してカウンタを用意し，クラス毎に重複度が[MATH]以上であるかを判定して，カウンタに1を加えるというものである．
この方法を単純に行うと，一つのsuffixに関連するクラスが多数になり得るため，[MATH]以下の計算量では収まらない場合がある．
具体的には同じ文字が長く連続するようなデータがこのケースになる．
重複条件付き文字列頻度の計数を単純な方法で行うと，一つのsuffixに対し，それが含まれるクラスをすべて求め，そのクラスのすべてに対してカウンタの更新を行わなければならない．
しかし，以下の性質を利用することですべてのクラスに対しカウンタを更新することを避けられる．
[性質11]ある場所が与えられたとき，そのsuffixの先頭の文字列に対応するクラスの集合が求められるが，そのクラスには一意の階層関係がある．
[性質12]ある場所が与えられたとき，そこのsuffixの先頭の文字列に対応するクラスのうち，あるクラスの文字列について重複度が[MATH]であったとすると，そのクラスより上位のクラスの重複度は[MATH]以上である．
この２つの性質のため，カウンタの加算を一つのsuffixと一つの重複度[MATH]にに対して一つにすることができる．
つまり，あるsuffixで重複度[MATH]以上となるクラスのうち，最下位のクラスのカウンタだけを加算しておき，下位クラスの計数が終了したときに，上位のクラスのカウンタにその計数値を加算していくことで，すべてのクラスの計数値を得ることができる．
あるクラスの始まりは[MATH]が増加したことで発見できる．
このとき，現在計測している重複条件付き文字列頻度の情報はほかのクラスの情報と同様にスタックに待避させ，重複条件付き文字列頻度は0に初期化して新たに計数する．
ある場所で，重複度が[MATH]より大きいクラスのなかで最も下位のクラスを特定する操作は，重複度判定と融合することができる．
重複度の判定はpreviousリンクを[MATH]回たどった場所[MATH]と，現在の場所[MATH]の区間が一つのドキュメントに含まれるかどうかで行うので，逆にその区間を含むクラスの集合を求めておき，その中で[MATH]を求めることができる．
この操作は，さらにクラスの検出と同時に行うことができる．
これは，「ある場所で，重複度が[MATH]より大きい[MATH]」を定める区間[MATH]が，現在の場所[MATH]を終りに持つため，検出の途中では計算未終了のクラスとなっていることを利用する．
具体的には，まず，previousリンクを[MATH]回たどったところにある文字列の出現を求める．
次に，その出現場所と最初の出現場所を含む文字列から，共通かつ計算中の[MATH]を特定する．
そのクラスの重複条件付き文字列頻度を加算する．
あるクラスの終了は[MATH]が減少することで発見できる．
このとき，上位クラスへ計数の値を伝える処理をする．
下位クラスの計数が終了したときに上位クラスのカウンタに，その計数値を加算することで，結果的にすべてのクラスに加算するのと同じ値を得ることができる．
サンプルとして処理するデータは以下のファイルである．
一行が一つのドキュメントになっている．
abcabcabc abcd abcde bcde
第一段階では，Suffix Arrayを作成し，commonをもとめ，Previous Linkを作成する．
例に対しては以下のようなデータが作成される．
先頭から，
suffixの番号
suffixが属するドキュメントの番号
同じドキュメントに属しているsuffixで，直前に現れたものの番号
直後のsuffixと「先頭から一致している文字列」の長さ
そのsuffixの文字
である．
0 0 -1 0: 1 1 -1 0: 2 2 -1 0: 3 3 -1 0: 4 0 0 3:abc 5 0 4 6:abcabc 6 0 5 3:abcabcabc 7 1 1 4:abcd 8 2 2 0:abcde 9 0 6 2:bc 10 0 9 5:bcabc 11 0 10 2:bcabcabc 12 1 7 3:bcd 13 2 8 4:bcde 14 3 3 0:bcde 15 0 11 1:c 16 0 15 4:cabc 17 0 16 1:cabcabc 18 1 12 2:cd 19 2 13 3:cde 20 3 14 0:cde 21 1 18 1:d 22 2 19 2:de 23 3 20 0:de 24 2 22 1:e 25 3 23 0:e
本文で説明した方法で，[MATH]が2より大きなクラスを求める．
これを，クラスの先頭の場所を第1キー，長さを第2キーにしてソートし，同時に，重複条件付き文字列頻度から，文書頻度に変換する．
その結果は，以下のようになる．
この例では，[MATH]が2より大きなクラスは全部で14個ある．
クラスごとに，対応する区間，次に長さ，それぞれのクラスに対する統計値とクラスを代表する文字列となっている．
クラスを代表する文字列とは，そのクラスのなかで最長の文字列である．
この中には，区間の大きさが1のクラスは含まれていない．
この情報の中にはクラスに含まれる最短の文字列が何であるかという情報が含まれていない．
そのような文字列は，クラスを代表する文字列と先頭から比較していき，最も長く一致するものの中で最も上位のクラスの情報を取り出すことで対処している．
クラスのソートで，区間の先頭を第1キーにすることでほぼ辞書順に並ぶ．
区間の先頭が同じ場合には，長さが短いほうが優先されることで，結果としてクラスの代表する文字列は辞書順に並ぶ．
total=14 Class[ 4, 8] L=3 tf=5 df1=3 df2=1 df3=1 df4=0 S="abc" Class[ 5, 6] L=6 tf=2 df1=1 df2=1 df3=0 df4=0 S="abcabc" Class[ 7, 8] L=4 tf=2 df1=2 df2=0 df3=0 df4=0 S="abcd" Class[ 9, 14] L=2 tf=6 df1=4 df2=1 df3=1 df4=0 S="bc" Class[ 10, 11] L=5 tf=2 df1=1 df2=1 df3=0 df4=0 S="bcabc" Class[ 12, 14] L=3 tf=3 df1=3 df2=0 df3=0 df4=0 S="bcd" Class[ 13, 14] L=4 tf=2 df1=2 df2=0 df3=0 df4=0 S="bcde" Class[ 15, 20] L=1 tf=6 df1=4 df2=1 df3=1 df4=0 S="c" Class[ 16, 17] L=4 tf=2 df1=1 df2=1 df3=0 df4=0 S="cabc" Class[ 18, 20] L=2 tf=3 df1=3 df2=0 df3=0 df4=0 S="cd" Class[ 19, 20] L=3 tf=2 df1=2 df2=0 df3=0 df4=0 S="cde" Class[ 21, 23] L=1 tf=3 df1=3 df2=0 df3=0 df4=0 S="d" Class[ 22, 23] L=2 tf=2 df1=2 df2=0 df3=0 df4=0 S="de" Class[ 24, 25] L=1 tf=2 df1=2 df2=0 df3=0 df4=0 S="e"
与えられた任意の文字列に対して，上記の表を二分探索することで[MATH]を求めることができる．
二分探索であり，表の大きさは[MATH]であるので，この処理は[MATH]で終了する．
abc -- Class[4,8]に該当（代表文字列）5 3 1 1 0 abc abcabc -- Class[5,6]に該当（代表文字列）2 1 1 0 0 abcabc abcd -- Class[7,8]に該当（代表文字列）2 2 0 0 0 abcd abca -- Class[5,6]に該当（代表文字列でない）2 1 1 0 0 abca abcab -- Class[5,6]に該当（代表文字列でない）2 1 1 0 0 abcab abcabc -- Class[5,6]に該当（代表文字列）2 1 1 0 0 abcabc abcabca --表になく，コーパスに存在する1 1 0 0 0 abcabca abcabcab --表になく，コーパスに存在する1 1 0 0 0 abcabcab abcabcabc --表になく，コーパスに存在する1 1 0 0 0 abcabcabc abcabcabca --表になく，コーパスに存在しない0 0 0 0 0 abcabcabca
実行時間の計測は，どのようなドキュメントを用いても良いが，ここでは，技術用語のアブストラクトの集合を使用した．
そこからアブストラクトの本文だけを抜き出し，一行を一つのドキュメントに整形したものである．
332,918文書，69,312,280文字，130,993,215バイトのコーパスである．
測定には，Athlon MP 1.2Mhz，3G Byteメモリのシステムを使用した．
最初の比較対象のシステムは，一番単純な方法で計測した場合である．
文字列と重複度[MATH]が与えられたときに，[MATH]のドキュメント頻度をは，コーパスの先頭から順番に見るという方針で求めるものである．
具体的には，以下のようなプログラムで求める．
これば，クラス分けもクラスの階層構造も利用しないシステムとなっている．
このシステムは定義が単純であるため速度の比較だけでなく，プログラムの動作の正答を用意し，提案するシステムが正しく動作していることの確認にも使用した．
このシステムをlinearと呼ぶことにする．
/* s1の先頭がs2で始まっているかどうかを検査する関数*/ static int string_sub(char *s1, char *s2) { while(*s2) { if(*s1 != *s2) { return 0; } s1++; s2++; } return *s1; }
/*改行までの間に，文字列がk回出現するかどうか調べ，出現した回数をカウントする回数．
*/ int dfn(int k, char *s) { int i; /* string position */ int t; /* term frequency in a document */ int n; /* document frequency */ n = 0; t = 0; for(i=0;i<size;i++) { if(string_sub(&text[i], s)) t++; if(text[i]=='\n') { if(t>=k) n++; t = 0; } } return n; }
ベースラインシステムは，クラス分けを使用しているが，表を作成するときにクラスの階層構造を使用しないシステムである．
クラスの検出のあと，下のCのプログラムを使って，[MATH]から[MATH]までを同時にもとめて表にする．
このシステムをbaseと呼ぶことにする．
/*重複条件付きドキュメント頻度を一斉に求める関数結果は，staticな配列に保存する．
*/ static int dfn[MAX_C]; static void count_dfn(char *s, int len) { int i; /* string position */ int t; /* term frequency in a document */ int n; /* document frequency */ int k; n = 0; t = 0; for(k=0;k<MAX_C;k++) { dfn[k]=0; }; for(i=0;i<size;i++) { if(strncmp(&text[i], s, len)==0) t++; if(text[i]=='\n') { for(k=0;k<MAX_C;k++) { if(t>k) dfn[k]++; } t = 0; } } }
提案するシステムはこの論文で記述した方法を用いたものであり，クラスの表を作成し，表の数値を計数するときに，クラスの階層の性質を使用したものである．
このシステムをclassと呼ぶことにする．
実験は，10個のドキュメントのなかに含まれる文字列頻度が3をこえるすべての文字列について，[MATH]，[MATH]，[MATH]，[MATH]，[MATH]，[MATH]，[MATH]を求めることを行った．
コーパスの文字数[MATH]による効果を測定するために，使用するコーパスを，先頭から，316ドキュメント，1000ドキュメント，3162ドキュメント，10000ドキュメント，31623ドキュメント，100000ドキュメント，332918ドキュメントと変化させた実行時間を計測した．
実行時間は，前処理の時間と，重複条件付きのドキュメント頻度を求める時間とに分けて計測した．
表[REF_実行時間]にlinear，base，classの実行時間を示す．
表[REF_実行時間]の中の時間は，処理装置の使用時間を秒で示したものである．
また，すべてのプログラムが同一の頻度を出力することも確認した．
重複条件付きドキュメント頻度の分析対象とした文字列は，10ドキュメント，4156バイト，2190文字の部分文字列で，統計的に安定な頻度が3を越える文字列である．
この文字列の数は，コーパスが大きくなるにつれ増加するが，その増加は緩やかである．
linearシステムは，前処理は必要なく，前処理の時間はテキストを読む時間だけである．
この計測ではファイル処理の時間は除外しているので，前処理の時間は0.0となる．
linearシステムは直ちに結果を出力し始めるがコーパスのドキュメント数が増加することに比例して一つあたりの分析時間が大きくなっていく．
10個のドキュメントの分析という小さな問題であっても，実用的に使用できるのは，ドキュメントの数が１万程度までである．
baseシステムは，分析時間は高速になるが，前処理に[MATH]の時間がかかることが観測される．
実用的に使用できるのは，ドキュメントの数が数千個程度までである．
提案するシステム(class)の実行時間は，実データにおいて，前処理[MATH]となっている．
そして，分析時間を分析対象の文字数で割ることで求められる1文字列あたりの時間は，最大でも0.036ミリ秒であり，1000ドキュメントより大きなコーパスにおいて，[MATH]となっている．
332,918ドキュメントの前処理の時間は1223.4と[MATH]に比べて大きい．
ほかに比べて増加しているのは，実験に使用したコンピュータの実装メモリに近いプロセスの大きさになったためだと考えられる．
以上，クラス分けによる表の作成と，クラスの階層構造を利用することによって，はじめて10万を越えるドキュメント数に対して分析ができるようになったことがわかる．
プログラムで使用するメモリの量を示すために，実行しているプロセスの大きさを計測する．
これを表[REF_プロセス]に示す．
計測では分析する重複度の上限は5に設定している．
表[REF_プロセス]より，提案するシステムのメモリ負荷は，[MATH]となっていることがわかる．
そして，表の作成に，1クラスあたり100バイト，表の検索に，1クラスあたり50バイト使用していることがわかる．
表の検索のプログラムは，クラス分けの表とSuffix Arrayを保持しており，プロセスの大きさの主要な部分は，その大きさである．
表を作成するには，クラス検出のためのデータ構造や，重複度判定のためのデータ構造などがあり，分析処理よりもメモリを多く必要とする．
任意の文字列について，前処理の後に[MATH]で重複条件付きドキュメント頻度の分析を行うことは，文字列の統計処理の基本技術であり，ここで述べた単語の境界の分析以外にも応用範囲がある．
日本語，中国語などの情報検索では２文字の文字列に対して，ドキュメント頻度を計測して，2文字に対して情報検索の重みを計算することが行われている．
[MATH]は，Adaptationと呼ばれる量で，ドキュメントの確率という空間において，ドキュメントにある文字列が出現するということを条件としたとき，そのドキュメントに2回文字列が出現する確率の推定値である．
文献[CITE]は英語において，その確率が統計的に単語の性質を識別できることを示している．
この量を使って検索対象の文字列を区分けすると検索精度が向上するという報告[CITE]がある．
あらかじめ表を作成するのが難しいため，この報告の処理対象は2文字に限られていたが，ここで述べた方法を使って，任意の長さの文字列から検索に効果のある文字列を選びだし，情報検索の性能を向上させるのは有望な応用の一つだと考えられる．
文献[CITE]は，自然言語で書かれたドキュメントを分析対象として，辞書を使わず，重複条件付きドキュメント頻度からキーワードを抽出していたが，これは「あるドキュメントに繰り返し現れる文字列」を効果的に取り出すシステムと解釈できる．
これを遺伝子情報に適用して，「遺伝子に繰り返し現れるDNA配列」を検出するのは有望な応用の一つと考えられる．
遺伝子の長さを考えると，ここで示した方法をつかってはじめて，遺伝子のドキュメント頻度の分析ができるようになると考えられる．
文献[CITE]は，文字列の頻度を分析して，プログラム中にまれにしか現れない文字列を検出し，それがプログラムの欠損の判定に効果があることを示している．
このツールにおいて，使用しているのは文字列の総出現頻度だけであるが，重複条件付きドキュメント頻度はプログラム中の構造がより精密に判定できる情報源である．
あらたな情報が提供されれば，このようなツールの検出性能が向上することが期待できる．
[MATH]を，ドキュメント[MATH]に含まれる文字列[MATH]の個数と定義する．
この論文で扱う頻度は，[MATH]で定義できるものである．
[MATH]は，文字列頻度と呼ばれるものであり，[MATH]は単純ドキュメント頻度と呼ばれるものである．
[MATH] :ドキュメント集合中に文字列[MATH]が出現する数
[MATH] :文字列[MATH]が1回以上出現するドキュメントの数
われわれが求めたい重複条件付きドキュメント頻度も[MATH]から求められるものである．
[MATH] :文字列[MATH]が[MATH]回以上出現するドキュメントの数
クラス分けのために，Suffix Arrayというデータ構造を用いる．
Suffix Arrayは文献[CITE]によって示されたデータ構造である(図[REF_suffix_array])．
このデータ構造はあるテキストがあったときに，そのテキストのすべての文字からテキストの終了までの文字列(suffix;接尾辞)の集合を考え，その集合を辞書順に並べたものである．
ここで，テキストの本体がメモリにあるとすると，一つの文字列を格納するのに，文字列の開始場所という一つの整数を格納すれば良い．
このため，任意の部分文字列の場所を知ることができるにもかかわらず，必要な記憶容量は[MATH]で済む．
Suffix Arrayは以下のルーチンで生成できる．
/* size:コーパスの文字数, text:コーパスの先頭を指すポインタ*/ int suffix_compare(struct suffix_struct * x, struct suffix_struct * y) { return strcmp(text + x->position, text + y->position); /* x->position,y->positionはそれぞれx,yに対応する場所を指すポインタ*/ }
for(i=0;i<size;i++) { suffix[i].
position = i; } qsort(suffix, size, sizeof(struct suffix_struct), suffix_compare);
ドキュメント頻度を計算する場合，ドキュメントの長さに上限があればコーパス中の文字列はドキュメント毎に区切られていると見なすことができる．
この条件の下で上記のアルゴリズムを使ってデータ構造を作成するためには，[MATH]時間必要である．
[htbp]
\epsfxsize=9cm \epsfbox{suffix_array.eps}
文字列の文献[CITE]の文字列のクラス分けの方法を使用するが，この論文では，重複条件付きドキュメント頻度を求める場合にもクラス分けを使用できることを述べる．
クラス分けはsuffixを用いて定義される．
Suffix Arrayのsuffixは辞書順に並んでいるので，文字列の先頭部分が次のsuffixと共通であることが多い．
そこで，[MATH]を[MATH]と[MATH]の文字列の先頭からの共通部分とする．
文献[CITE]のクラスの定義を下に示す．
ここで，定義の記述を簡単にするため[MATH]の場合[MATH]とする．
そして，[MATH]，[MATH]とする．
区間の境界での[MATH]の大きい方である[MATH]と定義し，区間内部での[MATH]の最小のもの[MATH]と定義する．
[定義]区間[MATH]がクラスを形成するとは，[MATH]であることをいう．
[MATH]は区間全体で共通部分となる文字列の長さであり，[MATH]であるとは区間を広げると全体で共通となる文字列が短くなるという意味となる．
区間[MATH]がクラスを形成するとき，区間[MATH]に共通する「長さ[MATH]から[MATH]までの部分文字列」の集合を，その区間に対応する文字列のクラスと定義する．
図[REF_suffix_array_class]で，区間[MATH]，[MATH]，[MATH]を見た場合，
となり，区間[MATH]は[MATH]，区間[MATH]は[MATH]となるのでクラスを形成するが，区間[MATH]は[MATH]となるのでクラスを形成しない．
[htbp]
\epsfxsize=7cm \epsfbox{suffix_array_class.eps}
文献[CITE]によると，クラス数は最大でも[MATH]であり，その表は作成し記憶することが実際的な大きさである．
[[MATH]の定義]クラス[MATH]で定まる区間[MATH]について，集合[MATH]を[MATH]とする．
[MATH]は，出現場所を示す整数の集合となる．
[性質1]クラス[MATH]があったとき，[MATH]の任意の2要素[MATH]，[MATH]について，任意のドキュメントを[MATH]とすると，[MATH]である．
証明[MATH]は，[MATH]の中に出現する[MATH]の個数であるが，これは，[MATH]の出現する場所で，その場所がドキュメント[MATH]に属する回数に等しい．
[MATH]の出現する場所は，[MATH]の属するクラス[MATH]の[MATH]で求まる．
[MATH]は，[MATH]の各要素である整数が，ドキュメント[MATH]に属しているかどうかで求めることができる．
つまり，[MATH]の属する[MATH]について，[MATH]の出現する位置の集合[MATH]を求めて，それから[MATH]を決定できる．
ここで，[MATH]が[MATH]と同じクラスの属していれば，両方とも[MATH]が同じであるため，[MATH]となる．
[性質2]クラス[MATH]があったとき，[MATH]の任意の2要素[MATH]，[MATH]について，
[MATH]
[MATH]
[MATH]
が成立する．
証明
性質1より，[MATH]なので，[MATH]を使用して定義できる頻度はすべて等しい．
すなわち，
証明は単純であるが，[MATH]の性質は未知であるため，同じクラスに属する文字列について，その値が等しいことを示すことは必要である．
クラスごとの頻度の表を高速に作成するために，クラス間の階層関係を利用するが，まず，クラスの階層関係を定義する．
区間[MATH]がクラス[MATH]を形成し，区間[MATH]がクラス[MATH]を形成していて，区間[MATH]が区間[MATH]に含まれているとき，[MATH]は[MATH]の下位のクラスと定義する．
また，[MATH]は[MATH]の上位のクラスと定義する．
[htbp]
\epsfxsize=7cm \epsfbox{class_kankei.eps}
[性質4] 2つのクラス[MATH]，[MATH]に交わりがあったときには，[MATH]は[MATH]の上位のクラスであるか[MATH]は[MATH]の下位のクラスであるかのどちらかである．
証明
[MATH]と[MATH]に交わりがあるということは，
のいずれかである．
[MATH]の場合，[MATH]であると仮定する．
区間[MATH]では
となるので，[MATH]である．
一方，区間[MATH]では，[MATH]，[MATH]となる[MATH]，[MATH]が存在する．
従って，
となり，区間[MATH]は
を満たさず，[MATH]の場合クラス[MATH]を形成しないので[MATH]と[MATH]に交わりはない．
[MATH]の場合はクラスの階層の定義より，[MATH]が[MATH]の上位クラスである，または，等しいクラスである．
[MATH]も[MATH]と同様に証明できる．
また，[MATH]の場合はクラスの階層の定義より，[MATH]が[MATH]の上位クラスであるか等しいクラスであり，[MATH]の場合は，[MATH]が[MATH]の上位クラスである，または，等しいクラスである．
以上より，2つのクラスに交わりがある場合は，一方がもう一方の上位クラス，または，下位クラスとなる．
[性質5] Suffix Arrayにおいて，すべてのsuffixはクラスによって階層構造を形成する．
証明
[MATH]より，最上位クラスは，すべてのsuffixを含むクラスである．
また，性質4よりあるクラスが他のクラスの部分クラスでない限り交わることはない．
このとき，部分クラスでは上位クラスよりその区間が短くなる．
以上のことから，すべての文字列の出現場所は文字列クラスによって階層構造を形成する．
[性質6]任意の区間[MATH]について，[MATH]を含む区間でクラスを形成する区間がある．
区間[MATH]において[MATH]，[MATH]なので，[MATH]となり，区間[MATH]は1つのsuffixからなる最下位クラスを形成する．
証明性質5より，Suffix Arrayのすべてのsuffixはクラスによって階層構造を形成する．
[記号]任意の区間[MATH]について，それを含むクラスを形成する区間のうち，もっとも下位のものを[MATH]から定まるクラスとし，[MATH]と記述する．
任意の区間について，それを含むもっとも下位のクラスが一意に定まることは，計算量を押さえたアルゴリズムを構成するときに必要な性質である．
[MATH]は，後述する頻度を計数するところで使用する．
すべてのクラスについて，それに属する文字列のドキュメント頻度を単純な方法で求めるとすると，通常の計算機では実用上問題がある．
クラスの大きさが高々[MATH]であったとしても，[MATH]，[MATH]，[MATH]のように条件を満たす集合を作って，その大きさを計測すると，各[MATH]の処理に[MATH]時間かかり，[MATH]が[MATH]個あれば，全体では[MATH]時間必要となる．
これは，コーパスの大きさから考えて，通常の計算機では実行できない処理となる．
文字列の出現頻度であれば，クラス階層に従って頻度の合計を求めることができる．
すなわち，下位のクラスの文字列頻度を合計して，上位の文字列頻度とすることができる．
言い換えれば，長い文字列の頻度から，短い文字列の頻度をもとめることができる．
しかし，ドキュメント頻度は，直接寄せ集めることができない．
たとえば，図[REF_chofuku_df]のようなコーパスについて考える．
文字列abcは6回出現し，それが出現するドキュメントの数が4個である．
また，文字列abxは7回出現し，それが出現するドキュメントの数が5個である．
このとき文字列abに続く文字のパターンがabcとabxの2つだけであったとすると，suffixの構造は図[REF_chofuku_df]に示されたような構造になる．
この状況で，abの出現回数は6+7回である．
しかし，この状況で，abが出現するドキュメントの数は9個とはいえない．
abcとabxが両方出現するドキュメントを2個と数えることが間違いだからである．
[CITE]で示されるように，単純なドキュメント頻度の計数であれば，重複して数えているところを差し引くという方法があるが，ドキュメントを計測する条件が，その文字列が2回以上出現するドキュメント数であった場合，クラスの上下によるドキュメント頻度の変化はさらに複雑になり，重複を差し引くという方法は使用できない．
[htbp]
\epsfxsize=12cm \epsfbox{chofuku_df.eps}
重複条件付きドキュメント頻度の計測行う準備として，この論文で新しく使用する「文字列の出現場所ごとの重複条件」を定義する．
重複条件付きドキュメント頻度の計測のために，クラス階層で寄せ集められる数を定義し，その数の関数として重複条件付きドキュメント頻度を求めることを行う．
ここで使用する頻度を定義するために，文字列の出現場所の重複度と重複条件を使用する．
すべての文字列の出現場所は，Suffix Array内の配列の番号で順序づけることができる．
この順序をsuffix順と定義し，これを利用して文字列の出現場所の重複条件と重複度を定義する．
[定義]ある文字列[MATH]の出現場所の重複度が[MATH]であるとは，suffix順でその出現場所以下の場所で，かつ同一のドキュメントに属する文字列[MATH]の出現場所が[MATH]個あることとする．
図[REF_chofuku]に重複度の例を示す．
suffix順でabx(suffix[3])以下の場所にあるのは，abc(suffix[0])とabd(suffix[1])，abe(suffix[2])，abx(suffix[3])である．
ここで，文字列abxについてdocument#1での文字列abの重複度[MATH]を求めると，ドキュメント中に文字列abc，abd，abxが出現するので，[MATH]である．
[htbp]
\epsfxsize=10cm \epsfbox{chofuku.eps}
[性質7]文字列[MATH]がドキュメント[MATH]に[MATH]個出現するとき，[MATH]個の出現場所について，すべて重複度を求め，それをsuffix順に並べると[MATH]となる．
[記号][MATH]を文字列としたとき，重複条件付き文字列頻度[MATH]と重複条件付きドキュメント文字列頻度[MATH]と書く．
[定義][MATH]はコーパス中で，重複度が[MATH]以上の文字列[MATH]の出現数とする．
[定義][MATH]はドキュメント[MATH]中で，重複度が[MATH]以上の文字列[MATH]の出現数とする．
[性質8]
文字列[MATH]の属するクラスを[MATH]とする．
重複度は，場所と文字列に関係するので注意が必要であるが，suffix順で順番をつけるので，[MATH]が定まれば，それぞれの要素についての重複度が一意に定まる．
したがって，[MATH]は[MATH]と同様に[MATH]と[MATH]の関数となる．
ドキュメント頻度と重複条件付き文字列頻度には下の単純な関係がある．
[定理文字列頻度とドキュメント頻度の関係]
証明
[MATH]のとき，[MATH]について，
[MATH]のとき[MATH], [MATH], [MATH],以下0が続くので，[MATH]について，
[MATH]であるので，
あるテキストにおいて，[MATH]と[MATH]を実際に求めた例を図[REF_df_cf]に示す．
図[REF_df_cf]の3つのドキュメントで，文字列abについて[MATH]，[MATH]を求める．
まず，[MATH]を計算する．
[MATH]，[MATH]である，ドキュメント#1，#3は，重複度[MATH]となる文字列abが存在しないため，[MATH]の数え上げに関係しない．
ドキュメント#2では，[MATH]であるので重複度[MATH]となる文字列abが一つだけ([MATH])存在する．
したがって，[MATH]．
同様に，[MATH]は，[MATH]，[MATH]となり，ドキュメント#1，#2によってそれぞれ1と2がカウントアップされるので，[MATH]となる．
他も同様である．
この様に[MATH]が求められたので，定理「文字列頻度とドキュメント頻度の関係」を用いることで，[MATH]を計算できる．
[htbp]
\epsfxsize=10cm \epsfbox{df_cf.eps}
[性質9]あるクラス[MATH]があったとき，その要素[MATH]については任意の[MATH]について，
証明[MATH]，[MATH]なので，
ここでは重複度を判定するためのデータ構造であるpreviousリンク(文献[DF1])について説明する．
previousリンクはそれぞれのsuffixについて，同じドキュメントに属し，かつsuffix順で前にある最も近いsuffixの順位を記録しておく．
もしそのような場所がなければ，-1をpreviousリンクとする．
このデータ構造はコーパスの大きさに比例した大きさのメモリ領域である．
文字列[MATH]のある出現重複度が[MATH]以上であることの判定は，その出現場所からpreviousリンクを[MATH]回たどれるかどうかと，たどれる場合，その文字列がまだ出現しているかを計測することで判定できる(図[REF_chofuku_struct])．
[htbp]
\epsfxsize=12cm \epsfbox{chofuku_struct.eps}
このデータ構造を作るには，ドキュメント数と同数の整数配列を用意して，それぞれの文字列の出現ごとに，ドキュメントの番号を求め，その配列からpreviousリンクの場所の情報を求めると同時に，その表を現在の場所に更新すればよい．
previousリンクを作成するプログラムは以下のような構造になる．
このデータ構造を作成するには，ドキュメント数と同じメモリ領域を用意し，コーパス全体を一度スキャンすることになる．
/* id_max:ドキュメント数，size:コーパスの文字数*/ for(i=0;i<id_max;i++) { last_suffixes[i] = -1; } for(i=0;i<size;i++) { suffix[i].
previous_suffix = last_suffixes[suffix[i].
id]; last_suffixes[suffix[i].
id] = i; }
重複度判定は，このpreviousリンクを[MATH]回たどることができ，かつその文字列が同じドキュメントにあるかどうかで判定できる．
(注)実際のプログラムでは，計算量を押さえるため，単純に重複度を判定せず，この重複度の判定と別の処理を同時に行っている．
クラスを検出するアルゴリズムの概略は以下のように行う．
Suffix Arrayをsuffix順が小さいものから見て行く．
クラスの開始場所を見つける．
クラスの終了場所を探す．
クラスは階層構造になっているため，そのクラスの終了場所が見つかる前に，他のクラスの開始場所が見つかることがある．
この場合は，スタックにその開始場所をプッシュする．
クラスの終了場所が見つかれば，報告しスタックを回復する．
上記のアルゴリズムでクラスを求めていったとき，求めるクラスの先頭が発見できていて，まだ，その終りが発見できていないクラスを計算中のクラスと呼ぶことにする．
アルゴリズムでは，スタック中のクラスを現在計算中のクラスとする．
[MATH]はコーパスの文字列と同じ大きさの配列で，Suffix Arrayで次のsuffixと文字列が一致している長さである．
この文字列はドキュメントの長さを越えることはなく，したがって，計算量のオーダを増やすことはない．
文字列のクラスは，[MATH]の増減にしたがっている．
[MATH]が増加したときは，現在計算中のクラスを計算終了していないクラスとして登録し，新しいクラスが開始したものとして処理する．
[MATH]が減少しているときは次の2つのケースがある．
現在のクラスは終了するが，実は現在のクラスと同じsuffixの場所から始まったクラスが，現在のクラス以外にもある場合．
現在のクラスを終了し，スタックトップのクラスの処理を継続しなければならない場合．
2番目のケースで，スタックトップの計算途中のクラスの処理を継続するときには，このクラスがすぐに終了しているかどうかの検査から処理を継続する．
クラスの発見をするには[MATH]ごとに，クラス終了判定の操作を行うことになる．
2番目のケースでは，計算途中のクラスの数だけ繰り返しが起きるのだが，その繰り返しの数を合計してもクラスの最大数を越えることはない．
したがって，クラスの最大数と[MATH]の個数からこの操作は[MATH]で完了できる．
現在計算中のクラスについて，以下の性質が成り立つ．
[性質10]現在計算中のsuffixから始まり，ドキュメントの区切りまでの文字列を属するクラス毎に分類すると，そのクラスは現在計算中のクラスとなる．
重複度[MATH]が与えられていたとき，すべての文字列[MATH]に対して重複度が[MATH]以上である[MATH]を求めることを考える．
重複度は文字列と場所の関数であるが，同一クラスに属する文字列の重複度が異なることはない．
また，同一クラスに属する文字列について，[MATH]は等しい．
そこでクラスの数だけのカウンタを用意し，各suffixについて処理を行なうことでも計数できる．
これを単純な方法とよぶ．
この方法はメモリ領域[MATH]であるが，計算時間が問題となる．
計数の方法は，ある場所について，そこから始まるクラスの集合を求め，すべてのクラスに対してカウンタを用意し，クラス毎に重複度が[MATH]以上であるかを判定して，カウンタに1を加えるというものである．
この方法を単純に行うと，一つのsuffixに関連するクラスが多数になり得るため，[MATH]以下の計算量では収まらない場合がある．
具体的には同じ文字が長く連続するようなデータがこのケースになる．
重複条件付き文字列頻度の計数を単純な方法で行うと，一つのsuffixに対し，それが含まれるクラスをすべて求め，そのクラスのすべてに対してカウンタの更新を行わなければならない．
しかし，以下の性質を利用することですべてのクラスに対しカウンタを更新することを避けられる．
[性質11]ある場所が与えられたとき，そのsuffixの先頭の文字列に対応するクラスの集合が求められるが，そのクラスには一意の階層関係がある．
[性質12]ある場所が与えられたとき，そこのsuffixの先頭の文字列に対応するクラスのうち，あるクラスの文字列について重複度が[MATH]であったとすると，そのクラスより上位のクラスの重複度は[MATH]以上である．
この２つの性質のため，カウンタの加算を一つのsuffixと一つの重複度[MATH]にに対して一つにすることができる．
つまり，あるsuffixで重複度[MATH]以上となるクラスのうち，最下位のクラスのカウンタだけを加算しておき，下位クラスの計数が終了したときに，上位のクラスのカウンタにその計数値を加算していくことで，すべてのクラスの計数値を得ることができる．
あるクラスの始まりは[MATH]が増加したことで発見できる．
このとき，現在計測している重複条件付き文字列頻度の情報はほかのクラスの情報と同様にスタックに待避させ，重複条件付き文字列頻度は0に初期化して新たに計数する．
ある場所で，重複度が[MATH]より大きいクラスのなかで最も下位のクラスを特定する操作は，重複度判定と融合することができる．
重複度の判定はpreviousリンクを[MATH]回たどった場所[MATH]と，現在の場所[MATH]の区間が一つのドキュメントに含まれるかどうかで行うので，逆にその区間を含むクラスの集合を求めておき，その中で[MATH]を求めることができる．
この操作は，さらにクラスの検出と同時に行うことができる．
これは，「ある場所で，重複度が[MATH]より大きい[MATH]」を定める区間[MATH]が，現在の場所[MATH]を終りに持つため，検出の途中では計算未終了のクラスとなっていることを利用する．
具体的には，まず，previousリンクを[MATH]回たどったところにある文字列の出現を求める．
次に，その出現場所と最初の出現場所を含む文字列から，共通かつ計算中の[MATH]を特定する．
そのクラスの重複条件付き文字列頻度を加算する．
あるクラスの終了は[MATH]が減少することで発見できる．
このとき，上位クラスへ計数の値を伝える処理をする．
下位クラスの計数が終了したときに上位クラスのカウンタに，その計数値を加算することで，結果的にすべてのクラスに加算するのと同じ値を得ることができる．
サンプルとして処理するデータは以下のファイルである．
一行が一つのドキュメントになっている．
abcabcabc abcd abcde bcde
第一段階では，Suffix Arrayを作成し，commonをもとめ，Previous Linkを作成する．
例に対しては以下のようなデータが作成される．
先頭から，
suffixの番号
suffixが属するドキュメントの番号
同じドキュメントに属しているsuffixで，直前に現れたものの番号
直後のsuffixと「先頭から一致している文字列」の長さ
そのsuffixの文字
である．
0 0 -1 0: 1 1 -1 0: 2 2 -1 0: 3 3 -1 0: 4 0 0 3:abc 5 0 4 6:abcabc 6 0 5 3:abcabcabc 7 1 1 4:abcd 8 2 2 0:abcde 9 0 6 2:bc 10 0 9 5:bcabc 11 0 10 2:bcabcabc 12 1 7 3:bcd 13 2 8 4:bcde 14 3 3 0:bcde 15 0 11 1:c 16 0 15 4:cabc 17 0 16 1:cabcabc 18 1 12 2:cd 19 2 13 3:cde 20 3 14 0:cde 21 1 18 1:d 22 2 19 2:de 23 3 20 0:de 24 2 22 1:e 25 3 23 0:e
本文で説明した方法で，[MATH]が2より大きなクラスを求める．
これを，クラスの先頭の場所を第1キー，長さを第2キーにしてソートし，同時に，重複条件付き文字列頻度から，文書頻度に変換する．
その結果は，以下のようになる．
この例では，[MATH]が2より大きなクラスは全部で14個ある．
クラスごとに，対応する区間，次に長さ，それぞれのクラスに対する統計値とクラスを代表する文字列となっている．
クラスを代表する文字列とは，そのクラスのなかで最長の文字列である．
この中には，区間の大きさが1のクラスは含まれていない．
この情報の中にはクラスに含まれる最短の文字列が何であるかという情報が含まれていない．
そのような文字列は，クラスを代表する文字列と先頭から比較していき，最も長く一致するものの中で最も上位のクラスの情報を取り出すことで対処している．
クラスのソートで，区間の先頭を第1キーにすることでほぼ辞書順に並ぶ．
区間の先頭が同じ場合には，長さが短いほうが優先されることで，結果としてクラスの代表する文字列は辞書順に並ぶ．
total=14 Class[ 4, 8] L=3 tf=5 df1=3 df2=1 df3=1 df4=0 S="abc" Class[ 5, 6] L=6 tf=2 df1=1 df2=1 df3=0 df4=0 S="abcabc" Class[ 7, 8] L=4 tf=2 df1=2 df2=0 df3=0 df4=0 S="abcd" Class[ 9, 14] L=2 tf=6 df1=4 df2=1 df3=1 df4=0 S="bc" Class[ 10, 11] L=5 tf=2 df1=1 df2=1 df3=0 df4=0 S="bcabc" Class[ 12, 14] L=3 tf=3 df1=3 df2=0 df3=0 df4=0 S="bcd" Class[ 13, 14] L=4 tf=2 df1=2 df2=0 df3=0 df4=0 S="bcde" Class[ 15, 20] L=1 tf=6 df1=4 df2=1 df3=1 df4=0 S="c" Class[ 16, 17] L=4 tf=2 df1=1 df2=1 df3=0 df4=0 S="cabc" Class[ 18, 20] L=2 tf=3 df1=3 df2=0 df3=0 df4=0 S="cd" Class[ 19, 20] L=3 tf=2 df1=2 df2=0 df3=0 df4=0 S="cde" Class[ 21, 23] L=1 tf=3 df1=3 df2=0 df3=0 df4=0 S="d" Class[ 22, 23] L=2 tf=2 df1=2 df2=0 df3=0 df4=0 S="de" Class[ 24, 25] L=1 tf=2 df1=2 df2=0 df3=0 df4=0 S="e"
与えられた任意の文字列に対して，上記の表を二分探索することで[MATH]を求めることができる．
二分探索であり，表の大きさは[MATH]であるので，この処理は[MATH]で終了する．
abc -- Class[4,8]に該当（代表文字列）5 3 1 1 0 abc abcabc -- Class[5,6]に該当（代表文字列）2 1 1 0 0 abcabc abcd -- Class[7,8]に該当（代表文字列）2 2 0 0 0 abcd abca -- Class[5,6]に該当（代表文字列でない）2 1 1 0 0 abca abcab -- Class[5,6]に該当（代表文字列でない）2 1 1 0 0 abcab abcabc -- Class[5,6]に該当（代表文字列）2 1 1 0 0 abcabc abcabca --表になく，コーパスに存在する1 1 0 0 0 abcabca abcabcab --表になく，コーパスに存在する1 1 0 0 0 abcabcab abcabcabc --表になく，コーパスに存在する1 1 0 0 0 abcabcabc abcabcabca --表になく，コーパスに存在しない0 0 0 0 0 abcabcabca
実行時間の計測は，どのようなドキュメントを用いても良いが，ここでは，技術用語のアブストラクトの集合を使用した．
そこからアブストラクトの本文だけを抜き出し，一行を一つのドキュメントに整形したものである．
332,918文書，69,312,280文字，130,993,215バイトのコーパスである．
測定には，Athlon MP 1.2Mhz，3G Byteメモリのシステムを使用した．
最初の比較対象のシステムは，一番単純な方法で計測した場合である．
文字列と重複度[MATH]が与えられたときに，[MATH]のドキュメント頻度をは，コーパスの先頭から順番に見るという方針で求めるものである．
具体的には，以下のようなプログラムで求める．
これば，クラス分けもクラスの階層構造も利用しないシステムとなっている．
このシステムは定義が単純であるため速度の比較だけでなく，プログラムの動作の正答を用意し，提案するシステムが正しく動作していることの確認にも使用した．
このシステムをlinearと呼ぶことにする．
/* s1の先頭がs2で始まっているかどうかを検査する関数*/ static int string_sub(char *s1, char *s2) { while(*s2) { if(*s1 != *s2) { return 0; } s1++; s2++; } return *s1; }
/*改行までの間に，文字列がk回出現するかどうか調べ，出現した回数をカウントする回数．
*/ int dfn(int k, char *s) { int i; /* string position */ int t; /* term frequency in a document */ int n; /* document frequency */ n = 0; t = 0; for(i=0;i<size;i++) { if(string_sub(&text[i], s)) t++; if(text[i]=='\n') { if(t>=k) n++; t = 0; } } return n; }
ベースラインシステムは，クラス分けを使用しているが，表を作成するときにクラスの階層構造を使用しないシステムである．
クラスの検出のあと，下のCのプログラムを使って，[MATH]から[MATH]までを同時にもとめて表にする．
このシステムをbaseと呼ぶことにする．
/*重複条件付きドキュメント頻度を一斉に求める関数結果は，staticな配列に保存する．
*/ static int dfn[MAX_C]; static void count_dfn(char *s, int len) { int i; /* string position */ int t; /* term frequency in a document */ int n; /* document frequency */ int k; n = 0; t = 0; for(k=0;k<MAX_C;k++) { dfn[k]=0; }; for(i=0;i<size;i++) { if(strncmp(&text[i], s, len)==0) t++; if(text[i]=='\n') { for(k=0;k<MAX_C;k++) { if(t>k) dfn[k]++; } t = 0; } } }
提案するシステムはこの論文で記述した方法を用いたものであり，クラスの表を作成し，表の数値を計数するときに，クラスの階層の性質を使用したものである．
このシステムをclassと呼ぶことにする．
実験は，10個のドキュメントのなかに含まれる文字列頻度が3をこえるすべての文字列について，[MATH]，[MATH]，[MATH]，[MATH]，[MATH]，[MATH]，[MATH]を求めることを行った．
コーパスの文字数[MATH]による効果を測定するために，使用するコーパスを，先頭から，316ドキュメント，1000ドキュメント，3162ドキュメント，10000ドキュメント，31623ドキュメント，100000ドキュメント，332918ドキュメントと変化させた実行時間を計測した．
実行時間は，前処理の時間と，重複条件付きのドキュメント頻度を求める時間とに分けて計測した．
表[REF_実行時間]にlinear，base，classの実行時間を示す．
表[REF_実行時間]の中の時間は，処理装置の使用時間を秒で示したものである．
また，すべてのプログラムが同一の頻度を出力することも確認した．
重複条件付きドキュメント頻度の分析対象とした文字列は，10ドキュメント，4156バイト，2190文字の部分文字列で，統計的に安定な頻度が3を越える文字列である．
この文字列の数は，コーパスが大きくなるにつれ増加するが，その増加は緩やかである．
linearシステムは，前処理は必要なく，前処理の時間はテキストを読む時間だけである．
この計測ではファイル処理の時間は除外しているので，前処理の時間は0.0となる．
linearシステムは直ちに結果を出力し始めるがコーパスのドキュメント数が増加することに比例して一つあたりの分析時間が大きくなっていく．
10個のドキュメントの分析という小さな問題であっても，実用的に使用できるのは，ドキュメントの数が１万程度までである．
baseシステムは，分析時間は高速になるが，前処理に[MATH]の時間がかかることが観測される．
実用的に使用できるのは，ドキュメントの数が数千個程度までである．
提案するシステム(class)の実行時間は，実データにおいて，前処理[MATH]となっている．
そして，分析時間を分析対象の文字数で割ることで求められる1文字列あたりの時間は，最大でも0.036ミリ秒であり，1000ドキュメントより大きなコーパスにおいて，[MATH]となっている．
332,918ドキュメントの前処理の時間は1223.4と[MATH]に比べて大きい．
ほかに比べて増加しているのは，実験に使用したコンピュータの実装メモリに近いプロセスの大きさになったためだと考えられる．
以上，クラス分けによる表の作成と，クラスの階層構造を利用することによって，はじめて10万を越えるドキュメント数に対して分析ができるようになったことがわかる．
プログラムで使用するメモリの量を示すために，実行しているプロセスの大きさを計測する．
これを表[REF_プロセス]に示す．
計測では分析する重複度の上限は5に設定している．
表[REF_プロセス]より，提案するシステムのメモリ負荷は，[MATH]となっていることがわかる．
そして，表の作成に，1クラスあたり100バイト，表の検索に，1クラスあたり50バイト使用していることがわかる．
表の検索のプログラムは，クラス分けの表とSuffix Arrayを保持しており，プロセスの大きさの主要な部分は，その大きさである．
表を作成するには，クラス検出のためのデータ構造や，重複度判定のためのデータ構造などがあり，分析処理よりもメモリを多く必要とする．
任意の文字列について，前処理の後に[MATH]で重複条件付きドキュメント頻度の分析を行うことは，文字列の統計処理の基本技術であり，ここで述べた単語の境界の分析以外にも応用範囲がある．
日本語，中国語などの情報検索では２文字の文字列に対して，ドキュメント頻度を計測して，2文字に対して情報検索の重みを計算することが行われている．
[MATH]は，Adaptationと呼ばれる量で，ドキュメントの確率という空間において，ドキュメントにある文字列が出現するということを条件としたとき，そのドキュメントに2回文字列が出現する確率の推定値である．
文献[CITE]は英語において，その確率が統計的に単語の性質を識別できることを示している．
この量を使って検索対象の文字列を区分けすると検索精度が向上するという報告[CITE]がある．
あらかじめ表を作成するのが難しいため，この報告の処理対象は2文字に限られていたが，ここで述べた方法を使って，任意の長さの文字列から検索に効果のある文字列を選びだし，情報検索の性能を向上させるのは有望な応用の一つだと考えられる．
文献[CITE]は，自然言語で書かれたドキュメントを分析対象として，辞書を使わず，重複条件付きドキュメント頻度からキーワードを抽出していたが，これは「あるドキュメントに繰り返し現れる文字列」を効果的に取り出すシステムと解釈できる．
これを遺伝子情報に適用して，「遺伝子に繰り返し現れるDNA配列」を検出するのは有望な応用の一つと考えられる．
遺伝子の長さを考えると，ここで示した方法をつかってはじめて，遺伝子のドキュメント頻度の分析ができるようになると考えられる．
文献[CITE]は，文字列の頻度を分析して，プログラム中にまれにしか現れない文字列を検出し，それがプログラムの欠損の判定に効果があることを示している．
このツールにおいて，使用しているのは文字列の総出現頻度だけであるが，重複条件付きドキュメント頻度はプログラム中の構造がより精密に判定できる情報源である．
あらたな情報が提供されれば，このようなツールの検出性能が向上することが期待できる．
