構文木をデータベース化する手法として，XML文書を関係データベースを用いてデータベース化する吉川らの手法を適用した[CITE]．
吉川らの手法は，クエリとしてXPathを用い，XML文書を関係データベースに格納する．
XPathとは，W3Cにより勧告されたXML文書中の特定の構文を表現する記述方法である．
XML文書を検索する場合，クエリであるXPathをSQL文に変換し，クエリを含むXML文書を検索する．
吉川らの手法の大きな特徴は，検索が高速である点である．
その理由は，XML文書の木構造の各節点を出現位置という2つの数字で表現し，その大小関係により，節点の親子関係や兄弟関係を表現する点にある．
本手法では，構文木の構造をXML文書の構文構造に対応させ，データベース化を行った．
構文木をデータベースに格納するにあたり，構文木中の各節点対して，出現位置と呼ばれる節点間の関係を計算するための2つの数字を与える．
出現位置は，(left_position，right_position)の対で表現され，次のアルゴリズムにより決定する．
葉
左端からN番目の葉に対する出現位置は，(N, N)という整数値の対を与える．
葉以外の節点
変数positionを1以下の微小値[MATH]で初期化する．
根から深さ優先探索で辿り，節点を辿るときに[MATH]をpositionに加算し，葉を辿るきに葉のleft_positionまたはright_positionの値を代入する．
節点を最初に通過するとき変数positionの値をleft_positionとして，最後に通過するときにright_positionとして決定する．
ただし，[MATH]は，木の最大の深さの逆数よりも小さい値でなければならない．
このアルゴリズムで決定した出現位置の例を\figurename[REF_fig:tree-yoshikawa]に示す．
また，このように各節点に出現位置を与えることで，\figurename[REF_fig:yoshikawa-hougan]のように節点間の関係を出現位置の大小関係で表現することができる．
前節で計算した出現位置とともに各節点の情報を関係データベースに格納する．
データベースは，Node Table，Document Table，Label Tableの3つのテーブルにより構成される．
テーブルの例をそれぞれ表[REF_tbl:node]，[REF_tbl:doc]，[REF_tbl:label]に示す．
Node Tableは，構文木を構成する各節点に関する情報を格納する．
各項目は，IDが節点固有の値，parentIDが節点の親のID，docIDが節点を含む構文木のID，labelIDが節点のラベルのID，nextSibIDが節点の右隣の兄弟のID，l_pos, r_posが節点の出現位置を表す．
Document Tableは，構文木が記述されているファイルに関する情報を格納する．
各項目は，docIDが構文木固有の値，fileが構文木が記述されているファイル名を表す．
Label Tableは，コーパスに含まれる記号，単語に関する情報を格納する．
各項目は，labelIDがラベル固有の値，labelがラベル名，frequencyがコーパスにおけるラベルの頻度を表す．

前節では，構文木付きコーパスを関係データベースに格納する方法について述べた．
本手法では，木構造をクエリとし，クエリを部分木として含む文を検索する．
まず，クエリの例を\figurename[REF_fig:query]に示す．
図中の``[MATH]''は，任意のラベルを意味する．
さらに，クエリを部分木として含むかどうかの判定方法として，完全一致と部分一致の二種類を用意した．
完全一致は，クエリの各節点の分岐数とコーパス内の対応する節点の分岐数が一致しなければならない．
一方，部分一致は，この分岐数が必ずしも一致する必要がない．
例えば，\figurename[REF_fig:query]において，完全一致で検索した場合，(a)の木は，各節点の分岐数，ラベルが一致するためにクエリと一致すると見なす．
一方，(b)の木は，分岐数が異なるため，クエリと一致すると見なさない．
しかし，部分一致で検索した場合，節点の分岐数は一致する必要がないため，両方の木がクエリと一致すると見なす．
本手法は，吉川らの手法と同様に検索を行うためにクエリである部分木を関係データベースのデータの操作，定義，検索などを行う言語SQLの文へ変換する．
そして，変換したSQL文により該当した構文木をデータベース内から検索し，クエリを部分木として含む構文木を得る．
クエリとそのクエリに対応するSQL文を\figurename[REF_fig:sql]に示す．
\figurename[REF_fig:sql]中のSQL文のwhere構文以降が各節点の条件式となっている．
システムは，条件を満たす節点をデータベース内を検索し，すべての条件を満たす節点をもつ構文木を出力する．
吉川らは，シュークスピアの戯曲をJon Bosakがタグ付けしたXML文書[CITE]を用いた評価実験により，検索手法が高速であることを示した[CITE]．
そこで，吉川の手法を構文木付きコーパスに適用し，予備実験を行った．
検索対象のコーパスとして，Penn Treebank Corpus（48,884文）[CITE]を用いた．
クエリは，Penn Treebank Corpusからランダムに4文を抽出した．
そして，4文から節点数が2から20の抽出可能なすべての部分木をクエリとして，部分一致により検索を行った．
その結果を\tablename[REF_tbl:yobi]，\figurename[REF_fig:yobi]に示す．
実験結果より，クエリの節点数が7から12の間は，高速に検索を行っているが，節点数が7以下，12以上の場合，検索時間が非常に増加している．
クエリの節点数が7以下の場合，クエリに一致する文が非常に多いために検索に時間を要とすると考えられる．
一方，クエリの節点数が12以上の場合は，クエリと一致する文かどうかの判定，つまりSQL文の条件判定に検索時間を要していると考えられる．
検索条件が多ければ，条件判定を行う処理が多くなり検索に時間を要する．
吉川らが評価実験を行ったXML文書は，DTD (Document Type Definition)により，節点のラベルや構造があらかじめ定義されている．
構文木付きコーパスにおいては，文脈自由文法がDTDに相当する．
XML文書は，少ないDTDの規則で簡潔な構造を定義している場合が多く，文書間での大きな構造の違いは少ない．
そのため，SQL文の条件は多くなりにくい．
一方，構文木付きコーパスは，数千の規則を用いて文法を定義し，文によって様々な木構造が付与されている．
そのため，XML文書よりもSQL文の条件が多くなる可能性が高く，検索時間が増加するケースが多くなることが予想できる．
関係データベースの検索速度は，関係データベースシステムの種類，格納するデータ，検索に要するSQL文に依存する．
関係データベースを構築する際，技術者が格納するデータをみて関係データベースシステムを選んだり，生成するSQL文の条件部分の優先度などの調整を経験的に行い，検索の効率化をはかることが多い．
クエリの節点数が多くなると変換したSQL文の条件部分が多くなり，条件を満たすデータの検出時間がかかる．
そのため，検索時間が大幅にかかるようになる．
このような場合，人手により条件の記述順序の変更などにより，チューニングを行う．
しかし，構文付きコーパスは，言語や対象文書の違いなど様々なコーパスが存在する．
コーパスそれぞれを人手でチューニングすることは困難である．
そのため，自動的に検索速度をチューニングする手法が必要である．
予備実験の結果から，クエリの節点数が7から12の間は，高速に検索が可能であることがわかった．
例えば，節点数16のクエリの平均検索時間は，0.56秒である．
それに対して，節点数8のクエリの平均時間は，0.09秒である．
もし，節点数16のクエリを節点数8のクエリ2つに分割し検索できれば，検索を高速化することが可能である．
本手法では，クエリをSQL一文で検索するのではなく，複数のSQL文に分割し，SQL一文に要する検索時間を短くすることで高速化を行う．
また，単一のSQL文により効率よく絞り込みが行うことができるように，コーパス内のラベルの頻度をもとにクエリの分割方法を決定する．
クエリの節点数が多い場合には，クエリを複数のクエリに分割し，漸進的に検索を行う手法を提案する．
本論文では，分割されたクエリを検索単位，効率的に検索可能なクエリの節点数の最大値を最大検索単位節点数と定義する．
コーパスが与えられたとき，コーパスから最大検索単位節点数を計算し，ノード数が多いクエリは最大検索単位節点数をもとに分割して，漸進的に検索を行う．
まず，コーパスから，節点数2から31のクエリ（部分木）各50個をランダムに抽出する．
そして，各節点数ごとに平均検索時間を算出する．
そのデータから，以下の2つの条件を満たす最大値[MATH]を最大検索単位ノード数とする．
節点数[MATH]から[MATH]の間のクエリの平均検索時間が[MATH]以下
節点数[MATH]から[MATH]の間のクエリの平均検索時間が[MATH]以上
[MATH]と[MATH]は，最大検索単位節点数を決定する際のパラメータである．
[MATH]は，正の整数，[MATH]は，秒数である．
例えば，[MATH]を3，[MATH]を0.5（秒）をした場合，\figurename[REF_fig:decograph]の予備実験結果では，節点数13，14，15において平均検索時間が[MATH]を下回り，節点数16，17，18において平均検索時間が[MATH]を上回っている．
このとき，最大検索単位節点数は，15となる．
前節で，コーパスに最適化された検索単位の節点数を決定する手法について述べた．
しかし，クエリの分割方法，分割されたクエリの検索順序によって，検索時間は大きく変わる．
もし，最初に検索する検索単位の出力数が少なければ，次に絞り込む検索範囲が狭まり，検索を効率よく行うことができる．
つまり，絞り込みが早く行われるように分割や順序を決定することが望ましい．
コーパス中の節点や文脈自由規則の頻度をもとにクエリの検索単位への分割，検索単位の検索順序を決定する．
クエリの分割アルゴリズムを以下に示す．
検索単位の検索順序は，分割された順である．
\hangafter=1\hangindent=\StepW Step 1　クエリに含まれる節点のラベルのコーパス内での出現頻度を計算する．
\hangafter=1\hangindent=\StepW Step 2　クエリ内の最小頻度の節点を検索単位[MATH]とする．
\hangafter=1\hangindent=\StepW Step 3　[MATH] \hangafter=1\hangindent=\StepW Step 3　検索単位[MATH]に含まれる節点に近接する最小頻度のラベルの節点で初期化する．
\hangafter=1\hangindent=\StepW Step 4　検索単位[MATH]に含まれる節点を持ち，検索単位[MATH]に加えても最大検索単位節点数を越えない部分木があれば，根の頻度が最小である部分木の節点を検索単位[MATH]へ追加する．
\hangafter=1\hangindent=\StepW Step 5　もし，Step 4において，部分木を加えられたのであれば，Step 4へ．
そうでなければ，Step 6へ．
\hangafter=1\hangindent=\StepW Step 6　[MATH]．
クエリをすべて分割したならば，Step 7へ．
そうでなければ，Step 3へ．
\hangafter=1\hangindent=\StepW Step 7　各検索単位をSQL文へ変換．
クエリ分割方法を例を用いて説明する．
クエリとして，\figurename[REF_fig:divide]の(1)が与えられ，最大検索単位節点数が5であると仮定する．
まず，クエリに含まれる節点のラベルの出現頻度を計算する．
その中で，最も出現頻度が低い``join''（出現頻度50）を検索単位[MATH]に加える．
次に，節点(``join'')を含む部分木の中で，最も出現頻度が低い``VP''を根とする部分木（出現頻度179,161）の節点を加えることを考える．
しかし，この部分木の節点を加えると最大検索単位節点数を越えるため[MATH]には加えない．
（\figurename[REF_fig:divide]の(2)）次に，新たな検索単位[MATH]を[MATH]に含まれる節点と隣接する節点のうち最小頻度である節点(``VP'')初期化する．
そして，``VP''を含む部分木を[MATH]に加えることを考える．
``VP''を根とする部分木の節点を加えた場合，[MATH]の節点は，``VP'', ``NP'', ``PP-CLR'', ``NP-TMP''の4つとなり，最大検索単位節点数を越えない．
そのため，これらの節点を[MATH]に追加する．
さらに，[MATH]に``VP''を根とする部分木の節点を加えることを試みるが最大検索単位節点数を越えるために加えられない．
（\figurename[REF_fig:divide]の(3)）そして，新たな検索単位[MATH]を構築を始める．
最終的に，\figurename[REF_fig:divide]の(4)のように，クエリは3つの検索単位[MATH]，[MATH], [MATH]に分割される．
そして，それぞれの検索単位をSQL文へ変換し，検索を行う．
そして，最初に決定した検索単位[MATH]により検索を行い，その結果に対して検索単位[MATH]により絞り込みを行う．
絞り込みは，検索単位の初期化に利用した隣接する節点を次の検索単位のSQL文内の条件式として追加する．
つまり，直前に利用したSQL文で次の検索単位に隣接する節点のIDを獲得し，その条件を次の検索単位のSQL文の条件として加える．
例では，[MATH]に対応するSQL文の節点``n4''に関する条件式，[MATH]に対応するSQL文の節点``n3''に関する条件式が追加される条件式である．
（\figurename[REF_fig:divide]の(5)）
