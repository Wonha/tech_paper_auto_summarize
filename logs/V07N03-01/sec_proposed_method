本章では，本論文で示す手法の基となるGLR法[CITE]について簡単に述べる．
GLR法では，次に示す項の集合によって解析系の状態というものが定義される．
そして，解析系がLR構文解析表に従ってある状態から他の状態へと遷移することで解析が進められる．
項とは，文法規則に解析経過を示すドット記号`・'を付加したものである．
ドット記号は文法規則の右辺に付加され，その左側のカテゴリは既に解析済みであり，その右隣りのカテゴリがその後の解析の対象となることを示す．
[MATH]は項の一例であるが，これは「現時点までにカテゴリnpの解析が終了し，次にカテゴリvpの解析を開始する．
」ということを示す．
状態を構成する項の集合は，与えられたCFGに文法規則[MATH]を加えて得られる文法から，次に示す関数CLOSUREおよびGOTOによって求められる．
ここで，[MATH]は開始記号を表す．
関数CLOSUREは，与えられた項の集合[MATH]から，次の手順で[MATH]の閉包CLOSURE([MATH])を求める．
与えられた項の集合[MATH]に含まれる，すべての項をその閉包CLOSURE([MATH])に加える．
項[MATH]がCLOSURE([MATH])に含まれ，文法規則[MATH]が存在するとき，項[MATH]がCLOSURE([MATH])に含まれていなければ，これをCLOSURE([MATH])に加える．
加えるべき項がなくなるまで，これを繰り返す．
ここで，[MATH]，[MATH]は非終端カテゴリを，[MATH]，[MATH]，[MATH]は非終端カテゴリおよび品詞からなるカテゴリ列を表す．
関数GOTOは，与えられた項の集合[MATH]から，文法カテゴリ[MATH]に対する新たな項の集合GOTO([MATH]，[MATH])を求める．
得られるGOTO([MATH]，[MATH])は，[MATH]に含まれる項[MATH]に対する項[MATH]をすべて集めたものの閉包である．
ここで，[MATH]は非終端カテゴリを，[MATH]，[MATH]は非終端カテゴリおよび品詞からなるカテゴリ列を表す．
状態を構成する項の集合を求める手順は次の通りである．
項の集合族(つまり，集合の集合)を[MATH]とし，その初期値を[MATH]CLOSURE[MATH]とする．
[MATH]に含まれる各項の集合[MATH]および各文法カテゴリ[MATH]に対して，GOTO([MATH]，[MATH])を求める．
これが空でなく，かつ[MATH]に含まれていなければ，これを[MATH]に加える．
加えるべき項の集合がなくなるまで，これを繰り返す．
これによって得られた[MATH]に含まれる項の集合[MATH]が状態[MATH]を構成する．
GLR法での解析系の動作例を次に示す．
ここでは図[REF_fig:cfg]に示すCFGを用いる．
このCFGからは図[REF_fig:states]に示す各状態が構成される．
例文として``A child smiles.''を使用する．
なお，aの品詞はdet，childはn，smilesはviとする．
解析系は状態0から解析を開始し，先読み情報とLR構文解析表に従って解析を進めていく．
まずaを先読し，その品詞であるdetを先読み情報として得る．
これによって解析系は状態3に遷移する．
次にchildを先読みし，その品詞であるnを得る．
これによって状態7に遷移する．
次にsmilesを先読みし，その品詞であるviを得る．
ここで文法規則[MATH]による還元をおこない，一時的に状態0に遷移したのち状態2に遷移する．
そして，先読み情報であるviに従って状態5に遷移する．
次に，文の終了を表す右端記号を先読みする．
ここで文法規則[MATH]による還元をおこない，一時的に状態2に遷移したのち状態4に遷移する．
さらに文法規則[MATH]による還元をおこない，一時的に状態0に遷移したのち状態1に遷移する．
ここで解析系は解析を終了する．
本論文で示す手法では，文法記述形式として今野らによるXGS[CITE]を用いる．
これは，GLR法で用いられるCFGそのままでは痕跡を扱えないためである．
XGSは，痕跡を容易に扱えるように，補強CFGの一つであるDCG[CITE]を拡張したものである．
XGSでは，次に示すスラッシュ記法を用いて痕跡を記述する．
スラッシュ記法では，スラッシュと呼ばれる記号`/'を使用して，非終端カテゴリの記述に痕跡の記述を追加する．
`relC/np'はスラッシュ記法を用いた記述の一例であるが，これは「非終端カテゴリrelCを根とする解析木が作られたとき，その根の下に痕跡を直接構成素として持つカテゴリnpが一つ存在する．
」という意味を持つ．
また，スラッシュ`/'の直後(右隣り)に記述されたカテゴリは，スラッシュカテゴリと呼ばれる．
`relC/np'の例では，カテゴリnpはスラッシュカテゴリである．
XGSでの文法記述例を図[REF_fig:xgs]に示す．
また，この文法を使用した場合の，例文``A child who has a toy smiles.''に対する解析木を図[REF_fig:tree]に示す．
[htbp]
[b]{10cm}
解析系は，文に含まれる痕跡を検出するために，痕跡となるカテゴリを保持しなければならない．
本論文で示す手法では，痕跡となるカテゴリの保持に，XGでのXリスト[CITE]と同じ手法を用いる．
つまり，痕跡となるカテゴリの保持にスタックを使用する．
ここでは，このスタックを便宜的にXリストと呼ぶことにする．
Xリストへのプッシュは次のようにおこなう．
文法規則中のスラッシュ記法を処理するときに，そのスラッシュカテゴリをXリストにプッシュする．
つまり，スラッシュ記法の直前(左隣り)にドット記号`・'のある項を含む状態に解析系が遷移するときに，そのスラッシュカテゴリをXリストにプッシュする．
例えば，図[REF_fig:xgs]の文法規則[MATH]では，relC/npの解析を開始するとき，つまり，項[MATH]を含む状態に解析系が遷移するときに，スラッシュカテゴリであるnpをXリストにプッシュする．
Xリストからのポップは，痕跡を検出したときにおこなう．
解析系は，Xリストの先頭にあるスラッシュカテゴリが痕跡として文中に存在すると判断したとき，そのスラッシュカテゴリをXリストからポップし，そのスラッシュカテゴリに対してLR構文解析表に定義されている動作に従って解析を続ける．
痕跡の検出は，文のすべての単語間に痕跡の存在を仮定することでおこなう．
解析が単語の境界に到達したときに，その時点でのXリストの先頭にあるスラッシュカテゴリに対して，LR構文解析表に動作が定義されているとき，その単語境界にそのスラッシュカテゴリが痕跡として存在すると判断する．
一方，LR構文解析表に動作定義がない場合やXリストが空である場合には，その単語境界には痕跡は存在しないと判断する．
自然言語の解析では，スラッシュカテゴリは，通常，非終端カテゴリである．
痕跡の検出において，Xリストの先頭にあるスラッシュカテゴリが非終端カテゴリである場合には，そのスラッシュカテゴリを構成する左隅の品詞を先読み情報とした還元を考慮しなければならない．
これを例を用いて次に説明する．
使用する文法は図[REF_fig:xgs]に示すものである．
この文法からは図[REF_fig:states2]に示す各状態が構成される．
例文として``A toy which a man gives a child moves.''を使用する．
ここで，aの品詞はdetであり，toy，man，childはn，whichはrelPron，givesはvt，movesはviとする．
childまで解析が終了したとき，解析系の状態は状態9であり，Xリストの先頭にあるスラッシュカテゴリは非終端カテゴリnpである．
ここでLR構文解析表を参照すると，状態9ではカテゴリnpに対する動作は定義されていない．
したがって，解析系はchildとmovesの単語境界には痕跡は存在しないと判断する．
しかし，実際にはカテゴリnpが痕跡として存在するので，この判断は正しくない．
この判断の誤りは，文法規則[MATH]による還元によって，aとchildから`a child'がまだ構成されていないことに起因する．
この還元は，Xリストの先頭にあるスラッシュカテゴリnpを構成する左隅の品詞であるdetを先読み情報としておこなわれるべきものである．
しかし，このスラッシュカテゴリnpは痕跡として存在するので，この品詞detが先読み情報として実際の文から得られることはない．
そのため，このままではこの還元はおこなわれない．
そこで，痕跡検出の手続きの一つとして，この還元をおこなう．
これによって，解析系は一時的に状態7に遷移したのち，状態10に遷移する．
ここでLR構文解析表を参照すると，カテゴリnpに対して状態12への遷移が定義されている．
これによって，解析系はchildとmovesの単語境界にカテゴリnpの痕跡が存在すると判断する．
これで痕跡が正しく検出されたことになる．
[htbp]
{
[t] I[MATH]:
{[S' [MATH] [MATH] s]
[s [MATH] [MATH] np vp]
[np [MATH] [MATH] det n]
[np [MATH] [MATH] np relC/np]}
I[MATH] = GOTO(I[MATH], s):
{[S' [MATH] s [MATH]]}
I[MATH] = GOTO(I[MATH], np)
= GOTO(I[MATH], np):
{[s [MATH] np [MATH] vp]
[np [MATH] np [MATH] relC/np]
[vp [MATH] [MATH] vi]
[vp [MATH] [MATH] vt np]
[vp [MATH] [MATH] vt np np]
[relC [MATH] [MATH] relPron s]}
I[MATH] = GOTO(I[MATH], det)
= GOTO(I[MATH], det)
= GOTO(I[MATH], det)
= GOTO(I[MATH], det):
{[np [MATH] det [MATH] n]}
[t] I[MATH] = GOTO(I[MATH], vp):
{[s [MATH] np vp [MATH]]}
I[MATH] = GOTO(I[MATH], relC/np)
= GOTO(I[MATH], relC/np)
= GOTO(I[MATH], relC/np):
{[np [MATH] np relC/np [MATH]]}
I[MATH] = GOTO(I[MATH], vi):
{[vp [MATH] vi [MATH]]}
I[MATH] = GOTO(I[MATH], vt):
{[vp [MATH] vt [MATH] np]
[vp [MATH] vt [MATH] np np]
[np [MATH] [MATH] det n]
[np [MATH] [MATH] np relC/np]}
I[MATH] = GOTO(I[MATH], relPron)
= GOTO(I[MATH], relPron)
= GOTO(I[MATH], relPron):
{[relC [MATH] relPron [MATH] s]
[s [MATH] [MATH] np vp]
[np [MATH] [MATH] det n]
[np [MATH] [MATH] np relC/np]}
[t] I[MATH] = GOTO(I[MATH], n):
{[np [MATH] det n [MATH]]}
I[MATH] = GOTO(I[MATH], np):
{[vp [MATH] vt np [MATH]]
[vp [MATH] vt np [MATH] np]
[np [MATH] np [MATH] relC/np]
[np [MATH] [MATH] det n]
[np [MATH] [MATH] np relC/np]
[relC [MATH] [MATH] relPron s]}
I[MATH] = GOTO(I[MATH], s):
{[relC [MATH] relPron s [MATH]]}
I[MATH] = GOTO(I[MATH], np):
{[vp [MATH] vt np np [MATH]]
[np [MATH] np [MATH] relC/np]
[relC [MATH] [MATH] relPron s]}
}
痕跡検出において，文のすべての単語間に痕跡の存在を仮定する理由を次に示す．
痕跡処理をおこなわずに痕跡を含む文を解析すると，通常，痕跡が存在する位置でその解析は失敗する．
そこで，痕跡処理において，解析が失敗する位置に痕跡が存在すると仮定して痕跡の検出をおこなうものとする．
そうすると，``A child whom a man gives a toy smiles.''などの文では，``A child whom a man gives a toy t smiles.''と解析されてしまい，正しく``A child whom a man gives t a toy smiles.''とは解析されない(tが痕跡を表す)．
このため，文のすべての単語間に痕跡の存在を仮定し痕跡の検出をおこなう．
痕跡が存在するか否かの判断は，LR構文解析表を参照することで即座におこなわれる．
このため，純粋なボトムアップ法での場合のような無駄な処理はおこなわれない．
また逆に，文のすべての単語間に痕跡の存在を仮定して痕跡の検出をおこなうと，``A toy which a man gives a child moves.''などの文では，``A toy which a man gives t a child moves.''と解析されてしまい，正しく``A toy which a man gives a child t moves.''とは解析されない(tが痕跡を表す)．
そこで，痕跡が存在すると判断される場合には，解析過程を分岐させ横型探索によって，痕跡は存在しないものとした解析も同時におこなう．
XGSで記述された文法に対して，通常のGLR法での方法で，状態を構成する項の集合を求めると，次の(1)〜(3)に示す問題が生じる．
ここで，説明上の都合により，slash項と芯という用語を導入する．
slash項とは，スラッシュ記法の直前(左隣り)にドット記号`・'のある項のことである．
図[REF_fig:states2]の項の集合I[MATH]に含まれる項[MATH]は，slash項の一例である．
また，slash項のうち，スラッシュ記法が右辺の左端に存在するものを左隅slash項と呼ぶことにする．
芯とは，閉包を求めるときに関数CLOSUREに与えた項の集合に含まれる項のことである．
図[REF_fig:states2]の項の集合I[MATH]では，項[MATH]と[MATH]が芯である．
状態が芯としてslash項とそうでない項を含む場合，そのslash項ではない項の閉包として得られた項に基づく解析においても，その状態に遷移するときにXリストにプッシュしたスラッシュカテゴリが参照されてしまい，誤った痕跡の検出が引き起される．
状態が芯として複数のslash項を含む場合，その状態に遷移するときにXリストにプッシュすべきスラッシュカテゴリが複数存在してしまう．
状態が左隅slash項を含む場合，その左隅slash項の閉包として得られた項以外の項に基づく解析においても，その状態に遷移するときにXリストにプッシュしたスラッシュカテゴリが参照されてしまい，誤った痕跡の検出が引き起される．
次に，これらの問題についてより具体的に述べるとともに，その解決方法を示す．
図[REF_fig:states2]の状態2(I[MATH])には，(1)に示した問題がある．
状態2に遷移するときにXリストにプッシュされたスラッシュカテゴリnpは，カテゴリrelCの解析においてのみ参照されるべきものである．
しかし，このスラッシュカテゴリnpは，Xリスト上に存在する限り，カテゴリvpの解析，つまり，I[MATH]のうちCLOSURE({[MATH]})に含まれる項に基づく解析においても参照されてしまう．
その結果，誤った痕跡の検出がおこなわれる．
非文である``A child has.''を用いて，次により具体的に述べる．
ここで，aの品詞はdet，childはn，hasはvtとする．
childまで解析が終了したとき，解析系の状態は状態9であり，Xリストは空である．
解析系は，次にhasを先読みし，その品詞であるvtを先読み情報として得る．
ここで，文法規則[MATH]による還元をおこない，一時的に状態0に遷移したのち状態2に遷移する．
このとき，Xリストにスラッシュカテゴリnpをプッシュする．
そして，先読み情報であるvtに従って状態7に遷移する．
ここで，Xリストの先頭にあるスラッシュカテゴリnpに対してLR構文解析表に動作が定義されているため，誤りであるにも関わらず，解析系はhasの直後(右隣り)にこのスラッシュカテゴリnpが痕跡として存在すると判断する．
そして，このスラッシュカテゴリnpをXリストからポップし，カテゴリnpに対してLR構文解析表に定義されている動作に従って状態10に遷移する．
この後，解析系は(状態2)[MATH]状態4[MATH](状態0)[MATH]状態1と遷移し，この非文が正しいものであるかのように解析を終了する．
この問題は，状態から芯であるslash項の閉包を取り出し，それによって新たな状態を構成することで解決できる．
図[REF_fig:states2]の状態2の場合，CLOSURE({[MATH]})を取り出し，これによって新たな状態を構成する．
この状態分割によって，図[REF_fig:states2]に示した状態を構成する項の集合は，図[REF_fig:states3]に示すものとなる．
図[REF_fig:states3]の状態2は図[REF_fig:states3]では，状態21と状態22へと分割される．
そして，解析系は状態22に遷移するときにのみ，スラッシュカテゴリnpをXリストにプッシュする．
これによって，上述の誤った痕跡の検出を防ぐことができる．
[htbp]
{
[t] I[MATH]:
{[S' [MATH] [MATH] s]
[s [MATH] [MATH] np vp]
[np [MATH] [MATH] det n]
[np [MATH] [MATH] np relC/np]}
I[MATH] = GOTO(I[MATH], s):
{[S' [MATH] s [MATH]]}
I[MATH] = GOTO(I[MATH], np)
= GOTO(I[MATH], np):
{[s [MATH] np [MATH] vp]
[vp [MATH] [MATH] vi]
[vp [MATH] [MATH] vt np]
[vp [MATH] [MATH] vt np np]}
I[MATH] = GOTO(I[MATH], np)
= GOTO(I[MATH], np)
= GOTO(I[MATH], np)
= GOTO(I[MATH], np):
{[np [MATH] np [MATH] relC/np]
[relC [MATH] [MATH] relPron s]}
[t] I[MATH] = GOTO(I[MATH], det)
= GOTO(I[MATH], det)
= GOTO(I[MATH], det)
= GOTO(I[MATH], det):
{[np [MATH] det [MATH] n]}
I[MATH] = GOTO(I[MATH], vp):
{[s [MATH] np vp [MATH]]}
I[MATH] = GOTO(I[MATH], relC/np):
{[np [MATH] np relC/np [MATH]]}
I[MATH] = GOTO(I[MATH], vi):
{[vp [MATH] vi [MATH]]}
I[MATH] = GOTO(I[MATH], vt):
{[vp [MATH] vt [MATH] np]
[vp [MATH] vt [MATH] np np]
[np [MATH] [MATH] det n]
[np [MATH] [MATH] np relC/np]}
[t] I[MATH] = GOTO(I[MATH], relPron):
{[relC [MATH] relPron [MATH] s]
[s [MATH] [MATH] np vp]
[np [MATH] [MATH] det n]
[np [MATH] [MATH] np relC/np]}
I[MATH] = GOTO(I[MATH], n):
{[np [MATH] det n [MATH]]}
I[MATH] = GOTO(I[MATH], np):
{[vp [MATH] vt np [MATH]]
[vp [MATH] vt np [MATH] np]
[np [MATH] [MATH] det n]
[np [MATH] [MATH] np relC/np]}
I[MATH] = GOTO(I[MATH], s):
{[relC [MATH] relPron s [MATH]]}
I[MATH] = GOTO(I[MATH], np):
{[vp [MATH] vt np np [MATH]]}
}
このように状態を分割しても問題が生じないのは，それぞれの芯の閉包を独立したものとして扱うことが可能なためである．
また，このような状態分割は，状態遷移における非決定性をもたらす．
例えば，図[REF_fig:states3]では状態0からのカテゴリnpによる遷移先として，状態21と状態22が存在する．
これらの非決定性に対して，解析系は解析過程を分岐させ横型探索をおこなう．
また，この状態分割の手法は(2)に示した問題に対しても有効である．
状態が芯として[MATH]や[MATH]などのslash項を含む場合，この状態に遷移するときにXリストにプッシュすべきスラッシュカテゴリとしてCやFなどが存在してしまう．
ここで，A，B，D，Eは非終端カテゴリ，[MATH]，[MATH]，[MATH]，[MATH]は非終端カテゴリおよび品詞からなるカテゴリ列，C，Fは非終端カテゴリあるいは品詞とする．
そこで，CLOSURE({[MATH]})やCLOSURE({[MATH]})などをそれぞれ取り出し，これらによって新たな状態をそれぞれ構成する．
そして，これらの新たに構成された状態に遷移するときにのみ，対応するスラッシュカテゴリをXリストにプッシュする．
このように，状態分割の手法によって，状態遷移においてXリストにプッシュすべきスラッシュカテゴリを一つにすることができる．
次に，(3)に示した問題について例を用いて述べる．
通常のGLR法での方法によって，図[REF_fig:xgs2]に示す文法から，状態を構成する項の集合の一つとして図[REF_fig:states4]に示すI[MATH]が得られる．
この状態x(I[MATH])には，左隅slash項[MATH]が含まれ，(3)に示した問題がある．
この状態xに遷移するときにXリストにプッシュされたスラッシュカテゴリnpは，カテゴリsの解析，つまり，CLOSURE({[relC [MATH] [MATH] s/np]})に含まれる項に基づく解析においてのみ参照されるべきものである．
しかし，このスラッシュカテゴリnpは，Xリスト上に存在する限り，CLOSURE({[relC [MATH] [MATH] s/np]})には含まれない，[s [MATH] np [MATH] vp]などの項に基づく解析においても参照されてしまう．
その結果，誤った痕跡の検出がおこなわれる．
先に述べたような状態分割の手法によって，この問題を解決することは難しい．
これは，左隅slash項の閉包とそれ以外の項とを独立したものとして扱えないためである．
図[REF_fig:states4]のI[MATH]では，項[MATH]に基づく解析には，CLOSURE({[relC [MATH] [MATH] s/np]})に含まれる項に基づく解析が含まれる．
このため，これらを独立したものとして扱うことはできない．
状態xからCLOSURE({[relC [MATH] [MATH] s/np]})を取り出し，状態の分割を敢えておこなうなら，状態xは図[REF_fig:states5]に示す状態x1と状態x2に分割される．
実際にこのような状態の分割をおこなった場合には，解析系はこれらの状態の間の依存関係を扱わなければならない．
例えば，状態x2においてカテゴリrelCが構成された場合には，解析系は依存関係に従って一時的に状態x1に遷移し，そこからカテゴリrelCによる遷移をおこなわなければならない．
次に，少し複雑な依存関係をともなう状態の分割をおこなった場合について述べる．
ある状態y(I[MATH]=CLOSURE({[MATH]}))が，y1(I[MATH]=CLOSURE({[MATH]})[MATH]I[MATH])，y2(I[MATH]=CLOSURE({[MATH]})[MATH]I[MATH])，y3(I[MATH]=CLOSURE({[MATH]}))の三つの状態に分割されるとする．
また，C \deriv D [MATH]，E \deriv G [MATH]とする．
ここで，A，C，D，E，G，Hは非終端カテゴリ，B，F，Jは非終端カテゴリあるいは品詞，[MATH]，[MATH]，[MATH]，[MATH]，[MATH]，[MATH]は非終端カテゴリおよび品詞からなるカテゴリ列，`\deriv'は0回以上の導出を表す．
これらの状態の関係を図[REF_fig:depend]に示す．
状態y1と状態y2は依存関係にあり，また，状態y2と状態y3も同様に依存関係にある．
解析系が状態y3に遷移するときには，スラッシュカテゴリであるJをXリストにプッシュすることになるが，これに加えてFもプッシュしなければならない．
これは，状態y3での解析が状態y2での解析の一部を構成するため，状態y2でのスラッシュカテゴリであるFが状態y3での解析においても参照可能でなければならないからである．
このように，依存関係をともなう状態分割をおこなった場合には，解析系の構成が複雑なものになってしまう．
[htbp]
[b]
{
[t] I[MATH]: {[s [MATH] np [MATH] vp]
[np [MATH] np [MATH] relC]
[vp [MATH] [MATH] vi]
[vp [MATH] [MATH] vt np]
[vp [MATH] [MATH] vt np np]}
I[MATH]: {[relC [MATH] [MATH] s/np]
[s [MATH] [MATH] np vp]
[np [MATH] [MATH] det n]
[np [MATH] [MATH] np relC]}
}
[b]{6cm}
また，状態に左隅slash項が再帰的に含まれる場合には，次に示す問題がある．
通常のGLR法での方法によって，図[REF_fig:xgs3]に示す文法から，状態を構成する項の集合の一つとして図[REF_fig:states6]に示すI[MATH]が得られる．
この状態z(I[MATH])には，左隅slash項[MATH]が再帰的に含まれている．
状態zからCLOSURE({[名詞句[MATH] [MATH]連体修飾節/後置詞句名詞句]})を取り出し状態の分割をおこなうと，状態zは図[REF_fig:states7]に示す状態z1と状態z2に分割される．
状態z1には，CLOSURE({[名詞句[MATH] [MATH]連体修飾節/後置詞句名詞句]})にも含まれる項[MATH]と[MATH]が含まれているが，これらは項[MATH]から導かれたものである．
状態z2では，左隅slash項[MATH]が再帰的に含まれているため，この項に基づく連体修飾節の解析が再帰的におこなわれ得る．
この再帰的な解析では，その再帰の数だけスラッシュカテゴリである後置詞句を必要とする．
しかし，どれだけ再帰的に解析がおこなわれるかを事前に知ることはできない．
このため，状態z2への遷移において，どれだけの数の後置詞句をスラッシュカテゴリとしてXリストにプッシュすべきかを決定できない．
このため，状態に左隅slash項が再帰的に含まれる場合には，状態分割の手法による対処は難しい．
[htbp]
このように，状態分割の手法は(3)に示した問題に対して有効でない．
そこで，文法規則の置き換えによる解決方法を次に示す．
左隅slash項は，右辺の左端にスラッシュ記法が存在する文法規則から生じる．
したがって，そのような文法規則が存在しなければ，左隅slash項が現れることはない．
そして，(3)に示した問題が起ることもない．
そこで，文法に対する前処理として，右辺の左端にスラッシュ記法が存在する文法規則に対して，図[REF_fig:replace]に示す置き換えをおこない，スラッシュ記法を擬似的に右辺の左端から移動させる．
これによって，左隅slash項が現れることはなくなり，(3)に示した問題は(1)あるいは(2)に示した問題に帰着される．
そして，先に述べたように，これらの問題は状態分割の手法によって解決される．
ここで，A，Bは非終端カテゴリ，Cは非終端カテゴリあるいは品詞，[MATH]は非終端カテゴリあるいは品詞からなるカテゴリ列を表す．
また，dummyはスラッシュ記法を擬似的に移動させるためだけに導入された非終端カテゴリであり，[MATH]は空文字列を表す．
図[REF_fig:xgs3]に示す文法では，前処理をおこなうと図[REF_fig:xgs4]に示すものとなる．
slash項[MATH]を含む状態において，Bが構成されたときに解析系がおこなう状態遷移には，二通りのものが考えられる．
ここで，A，Bは非終端カテゴリ，Cは非終端カテゴリあるいは品詞，[MATH]，[MATH]は非終端カテゴリおよび品詞からなるカテゴリ列を表す．
その一つは，B/Cによる状態遷移である．
解析系は，この状態に遷移するときにXリストにプッシュしたスラッシュカテゴリCが痕跡検出によって既にポップされているとき，B/Cによる状態遷移をおこなう．
もう一つは，単なるBによる状態遷移である．
この状態遷移は，Xリストの内容とは無関係である．
解析系は，LR構文解析表にBによる状態遷移が定義されているとき，これをおこなう．
したがって，B/Cによる状態遷移と単なるBによる状態遷移をともにおこなう必要がある場合には，解析系は解析過程を分岐させ横型探索をおこなう．
痕跡処理では，ロスの複合名詞句制約などのいわゆる「島制約」への対処が求められる．
次に，ロスの複合名詞句制約について述べ，その後，それへの対処方法を示す．
ロスの複合名詞句制約は，埋め込み文中の痕跡の位置に関する統語的な制約である．
ロスの複合名詞句制約によれば，名詞句は文や名詞句の構造を二度越えて移動することはできない[CITE]．
この制約に違反する例を図[REF_fig:np_const]に示す．
図[REF_fig:np_const]では，名詞句`a toy'がhasの直後(右隣り)から，`t[MATH] has t[MATH]'，そして，`the man knows the child who t[MATH] has t[MATH]'の二つの埋め込み文を越えて文頭に移動したために，ロスの複合名詞句制約に違反する．
[htbp]
XGSでは，ロスの複合名詞句制約を表現するために，open([MATH])，close([MATH])と呼ばれる記法が導入されている．
この記法には，「`[MATH]'と`[MATH]'の外側の構成素と，`[MATH]'と`[MATH]'で囲まれたカテゴリの中の痕跡とは対応付けることはできない」という意味が与えられている．
この記法の使用例を図[REF_fig:xgs5]に示す．
図[REF_fig:xgs5]に示す文法では，関係節を表すrelCが`[MATH]'と`[MATH]'で囲まれているため，関係節内の痕跡がその外側の構成素と対応付けられることはない．
これによって，関係節が多重に存在する文の解析において，ロスの複合名詞句制約が満たされることになる．
本論文で示す手法では，open([MATH])，close([MATH])を次のように解析系に組み込む．
文法規則中の`[MATH]'と`[MATH]'で囲まれたカテゴリを処理するときに，Xリストを一時的に空にする．
つまり，`[MATH]'と`[MATH]'で囲まれたカテゴリの直前(左隣り)にドット記号`・'のある項を含む状態に遷移するときに，Xリストを一時的に空にする．
そして，そのカテゴリの解析が終了したときに，Xリストの内容を元に戻す．
このようなXリストの操作によって，open([MATH])，close([MATH])は解析系に組み込まれる．
ここで，説明上の都合により，enclosed項という用語を導入する．
enclosed項とは，`[MATH]'と`[MATH]'で囲まれたカテゴリの直前(左隣り)にドット記号`・'のある項のことである．
また，enclosed項のうち，`[MATH]'と`[MATH]'で囲まれたカテゴリが右辺の左端に存在するものを左隅enclosed項と呼ぶことにする．
通常のGLR法での方法によって，図[REF_fig:xgs5]に示す文法から，状態を構成する項の集合の一つとして図[REF_fig:states8]に示すI[MATH]が得られる．
この状態s(I[MATH])には，enclosed項であり，かつslash項である[MATH]が含まれている．
したがって，解析系はこの状態sに遷移するときには，まず一時的にXリストを空にし，その後，スラッシュカテゴリであるnpをXリストにプッシュする．
また，解析系は状態sからrelC/npによる状態遷移をおこなうときには，Xリストの内容をこの状態sに遷移する前のものに復元する．
open([MATH])，close([MATH])を実現するXリスト操作による影響は，`[MATH]'と`[MATH]'で囲まれたカテゴリの解析，つまり，enclosed項の閉包に含まれる項に基づく解析に限定されなければならない．
そうでなければ，検出されるべき痕跡が検出されない．
open([MATH])，close([MATH])を用いて記述された文法に対して，通常のGLR法での方法で，状態を構成する項の集合を求めると，次の(1)，(2)に示す問題が生じる．
状態が芯としてenclosed項とそうでない項を含む場合，そのenclosed項ではない項の閉包として得られた項に基づく解析に対しても，その状態に遷移するときにおこなわれたXリスト操作が影響し，痕跡が検出されなくなる．
状態が左隅enclosed項を含む場合，その左隅enclosed項の閉包として得られた項以外の項に基づく解析に対しても，その状態に遷移するときにおこなわれたXリスト操作が影響し，痕跡が検出されなくなる．
これらの問題は，5章で論じた問題と類似している．
(1)に示す問題は，状態から芯であるenclosed項の閉包を取り出し，それによって新たな状態を構成することで解決できる．
また，(2)に示す問題は，文法に対する前処理として，右辺の左端に`[MATH]'と`[MATH]'で囲まれたカテゴリが存在する文法規則に対して，図[REF_fig:replace]に示すものと同様な置き換えをおこない，`[MATH]'と`[MATH]'で囲まれたカテゴリを擬似的に右辺の左端から移動させることで解決できる．
本論文で示す手法を用いてパーザを構成した例を次に示す．
DCGに対するGLRパーザとして論理型言語Prolog上に効率よく実装されたSGLR[CITE]を拡張することでパーザを構成した．
本論文では，このパーザをSGLR-plusと呼ぶことにする．
SGLR-plusを使用して，``A child who has a toy smiles.''という文を解析した様子を図[REF_fig:sglr_plus]に示す．
[htbp]
{11cm} {
| ?- run.
input: a child who has a toy smiles words: [a,child,who,has,a,toy,smiles] length: 7
--- result 1/1 ---
|- sentence |- sen_dec |- subj | |- noun_p | |- noun_p | | |- art -- < a > | | |- n -- < child > | |- relC/noun_p | |- relPron -- < who > | |- sen_dec | |- subj | | |- noun_p -- < t > | |- pred_do | |- verb_p | |- verb | |- vt -- < has > | |- obj | |- noun_p | |- art -- < a > | |- n -- < toy > |- pred_do |- verb_p |- verb |- vi -- < smiles >
argument info: []
the number of results: 1 run time: 10 msec
yes
}
SGLR-plus(痕跡処理あり)とSGLR(痕跡処理なし)を使用していくつかの文を解析した結果を次に示す．
今回の解析では，それぞれ平叙文を概ね網羅する文法を使用した．
また，SGLRは痕跡処理を持たないため，図[REF_fig:cfg2]と同様に，痕跡を含むカテゴリに対して，その痕跡に対応する構成素が欠けた文法規則を用意した．
ただし，これらの解析では補強項での統語的制約のチェックはおこなわなかった．
SGLR-plus，SGLRのそれぞれを使用した場合での文法規則数，解析系の状態数，項の総数を表[REF_tab:1]に示す．
SGLR-plusを使用した場合には，痕跡処理がおこなわれるため，SGLRを使用した場合と比較して3割ほど文法規則が減少している．
次に示す英文を解析の対象とした．
それぞれの英文に対する，解析に要した時間，得られた解析木の数，失敗した数を表[REF_tab:2]に示す．
The kids were skipping about in the park.
The coffee has slopped over into the saucer.
The trouble is that she does not like it.
I want to go to France.
They scattered gravel on the road.
He told me that he liked baseball.
I cannot allow you to behave like that.
The child who has a toy smiles.
Jane has an uncle who is very kind.
The book which I bought yesterday is very interesting.
I want a man who understands English.
The book which the man who had a bag which looked heavy bought is difficult.
SGLR-plus，SGLRのそれぞれを使用した場合の解析時間を比較すると，SGLR-plusを使用した場合により多くの時間を要す傾向がある．
一般に文法規則の増加は，非決定性の増加などによる処理量の増加を引き起す．
今回の比較では，痕跡に関連する処理量がこれを上回ったため，この傾向が生じたと考える．
この傾向は，痕跡を含まない(1)〜(7)の文の解析にも見られる．
これは，痕跡処理を解析系に組み込むためにおこなった状態分割に関連して，非決定性が増加したためであると考える．
SGLR-plusを使用した解析ではより多くの時間を要す傾向があるとは言え，対象とした文のうち，(12)以外のものの解析はおよそ数ミリ秒で終了している．
(12)の文は複数の痕跡を含むため，SGLR-plusを使用した解析では，痕跡処理に関連する非決定性が増加するとともに失敗の数も増加する．
この様子を表[REF_tab:3]に示す．
しかし，SGLRを使用した場合と比較すると，失敗の数ほど解析時間に差は生じていない．
これは，誤りがLR構文解析表から即座に判定されるためであると考える．
{
[htbp]
}
本章では，本論文で示す手法の基となるGLR法[CITE]について簡単に述べる．
GLR法では，次に示す項の集合によって解析系の状態というものが定義される．
そして，解析系がLR構文解析表に従ってある状態から他の状態へと遷移することで解析が進められる．
項とは，文法規則に解析経過を示すドット記号`・'を付加したものである．
ドット記号は文法規則の右辺に付加され，その左側のカテゴリは既に解析済みであり，その右隣りのカテゴリがその後の解析の対象となることを示す．
[MATH]は項の一例であるが，これは「現時点までにカテゴリnpの解析が終了し，次にカテゴリvpの解析を開始する．
」ということを示す．
状態を構成する項の集合は，与えられたCFGに文法規則[MATH]を加えて得られる文法から，次に示す関数CLOSUREおよびGOTOによって求められる．
ここで，[MATH]は開始記号を表す．
関数CLOSUREは，与えられた項の集合[MATH]から，次の手順で[MATH]の閉包CLOSURE([MATH])を求める．
与えられた項の集合[MATH]に含まれる，すべての項をその閉包CLOSURE([MATH])に加える．
項[MATH]がCLOSURE([MATH])に含まれ，文法規則[MATH]が存在するとき，項[MATH]がCLOSURE([MATH])に含まれていなければ，これをCLOSURE([MATH])に加える．
加えるべき項がなくなるまで，これを繰り返す．
ここで，[MATH]，[MATH]は非終端カテゴリを，[MATH]，[MATH]，[MATH]は非終端カテゴリおよび品詞からなるカテゴリ列を表す．
関数GOTOは，与えられた項の集合[MATH]から，文法カテゴリ[MATH]に対する新たな項の集合GOTO([MATH]，[MATH])を求める．
得られるGOTO([MATH]，[MATH])は，[MATH]に含まれる項[MATH]に対する項[MATH]をすべて集めたものの閉包である．
ここで，[MATH]は非終端カテゴリを，[MATH]，[MATH]は非終端カテゴリおよび品詞からなるカテゴリ列を表す．
状態を構成する項の集合を求める手順は次の通りである．
項の集合族(つまり，集合の集合)を[MATH]とし，その初期値を[MATH]CLOSURE[MATH]とする．
[MATH]に含まれる各項の集合[MATH]および各文法カテゴリ[MATH]に対して，GOTO([MATH]，[MATH])を求める．
これが空でなく，かつ[MATH]に含まれていなければ，これを[MATH]に加える．
加えるべき項の集合がなくなるまで，これを繰り返す．
これによって得られた[MATH]に含まれる項の集合[MATH]が状態[MATH]を構成する．
GLR法での解析系の動作例を次に示す．
ここでは図[REF_fig:cfg]に示すCFGを用いる．
このCFGからは図[REF_fig:states]に示す各状態が構成される．
例文として``A child smiles.''を使用する．
なお，aの品詞はdet，childはn，smilesはviとする．
解析系は状態0から解析を開始し，先読み情報とLR構文解析表に従って解析を進めていく．
まずaを先読し，その品詞であるdetを先読み情報として得る．
これによって解析系は状態3に遷移する．
次にchildを先読みし，その品詞であるnを得る．
これによって状態7に遷移する．
次にsmilesを先読みし，その品詞であるviを得る．
ここで文法規則[MATH]による還元をおこない，一時的に状態0に遷移したのち状態2に遷移する．
そして，先読み情報であるviに従って状態5に遷移する．
次に，文の終了を表す右端記号を先読みする．
ここで文法規則[MATH]による還元をおこない，一時的に状態2に遷移したのち状態4に遷移する．
さらに文法規則[MATH]による還元をおこない，一時的に状態0に遷移したのち状態1に遷移する．
ここで解析系は解析を終了する．
本論文で示す手法では，文法記述形式として今野らによるXGS[CITE]を用いる．
これは，GLR法で用いられるCFGそのままでは痕跡を扱えないためである．
XGSは，痕跡を容易に扱えるように，補強CFGの一つであるDCG[CITE]を拡張したものである．
XGSでは，次に示すスラッシュ記法を用いて痕跡を記述する．
スラッシュ記法では，スラッシュと呼ばれる記号`/'を使用して，非終端カテゴリの記述に痕跡の記述を追加する．
`relC/np'はスラッシュ記法を用いた記述の一例であるが，これは「非終端カテゴリrelCを根とする解析木が作られたとき，その根の下に痕跡を直接構成素として持つカテゴリnpが一つ存在する．
」という意味を持つ．
また，スラッシュ`/'の直後(右隣り)に記述されたカテゴリは，スラッシュカテゴリと呼ばれる．
`relC/np'の例では，カテゴリnpはスラッシュカテゴリである．
XGSでの文法記述例を図[REF_fig:xgs]に示す．
また，この文法を使用した場合の，例文``A child who has a toy smiles.''に対する解析木を図[REF_fig:tree]に示す．
[htbp]
[b]{10cm}
解析系は，文に含まれる痕跡を検出するために，痕跡となるカテゴリを保持しなければならない．
本論文で示す手法では，痕跡となるカテゴリの保持に，XGでのXリスト[CITE]と同じ手法を用いる．
つまり，痕跡となるカテゴリの保持にスタックを使用する．
ここでは，このスタックを便宜的にXリストと呼ぶことにする．
Xリストへのプッシュは次のようにおこなう．
文法規則中のスラッシュ記法を処理するときに，そのスラッシュカテゴリをXリストにプッシュする．
つまり，スラッシュ記法の直前(左隣り)にドット記号`・'のある項を含む状態に解析系が遷移するときに，そのスラッシュカテゴリをXリストにプッシュする．
例えば，図[REF_fig:xgs]の文法規則[MATH]では，relC/npの解析を開始するとき，つまり，項[MATH]を含む状態に解析系が遷移するときに，スラッシュカテゴリであるnpをXリストにプッシュする．
Xリストからのポップは，痕跡を検出したときにおこなう．
解析系は，Xリストの先頭にあるスラッシュカテゴリが痕跡として文中に存在すると判断したとき，そのスラッシュカテゴリをXリストからポップし，そのスラッシュカテゴリに対してLR構文解析表に定義されている動作に従って解析を続ける．
痕跡の検出は，文のすべての単語間に痕跡の存在を仮定することでおこなう．
解析が単語の境界に到達したときに，その時点でのXリストの先頭にあるスラッシュカテゴリに対して，LR構文解析表に動作が定義されているとき，その単語境界にそのスラッシュカテゴリが痕跡として存在すると判断する．
一方，LR構文解析表に動作定義がない場合やXリストが空である場合には，その単語境界には痕跡は存在しないと判断する．
自然言語の解析では，スラッシュカテゴリは，通常，非終端カテゴリである．
痕跡の検出において，Xリストの先頭にあるスラッシュカテゴリが非終端カテゴリである場合には，そのスラッシュカテゴリを構成する左隅の品詞を先読み情報とした還元を考慮しなければならない．
これを例を用いて次に説明する．
使用する文法は図[REF_fig:xgs]に示すものである．
この文法からは図[REF_fig:states2]に示す各状態が構成される．
例文として``A toy which a man gives a child moves.''を使用する．
ここで，aの品詞はdetであり，toy，man，childはn，whichはrelPron，givesはvt，movesはviとする．
childまで解析が終了したとき，解析系の状態は状態9であり，Xリストの先頭にあるスラッシュカテゴリは非終端カテゴリnpである．
ここでLR構文解析表を参照すると，状態9ではカテゴリnpに対する動作は定義されていない．
したがって，解析系はchildとmovesの単語境界には痕跡は存在しないと判断する．
しかし，実際にはカテゴリnpが痕跡として存在するので，この判断は正しくない．
この判断の誤りは，文法規則[MATH]による還元によって，aとchildから`a child'がまだ構成されていないことに起因する．
この還元は，Xリストの先頭にあるスラッシュカテゴリnpを構成する左隅の品詞であるdetを先読み情報としておこなわれるべきものである．
しかし，このスラッシュカテゴリnpは痕跡として存在するので，この品詞detが先読み情報として実際の文から得られることはない．
そのため，このままではこの還元はおこなわれない．
そこで，痕跡検出の手続きの一つとして，この還元をおこなう．
これによって，解析系は一時的に状態7に遷移したのち，状態10に遷移する．
ここでLR構文解析表を参照すると，カテゴリnpに対して状態12への遷移が定義されている．
これによって，解析系はchildとmovesの単語境界にカテゴリnpの痕跡が存在すると判断する．
これで痕跡が正しく検出されたことになる．
[htbp]
{
[t] I[MATH]:
{[S' [MATH] [MATH] s]
[s [MATH] [MATH] np vp]
[np [MATH] [MATH] det n]
[np [MATH] [MATH] np relC/np]}
I[MATH] = GOTO(I[MATH], s):
{[S' [MATH] s [MATH]]}
I[MATH] = GOTO(I[MATH], np)
= GOTO(I[MATH], np):
{[s [MATH] np [MATH] vp]
[np [MATH] np [MATH] relC/np]
[vp [MATH] [MATH] vi]
[vp [MATH] [MATH] vt np]
[vp [MATH] [MATH] vt np np]
[relC [MATH] [MATH] relPron s]}
I[MATH] = GOTO(I[MATH], det)
= GOTO(I[MATH], det)
= GOTO(I[MATH], det)
= GOTO(I[MATH], det):
{[np [MATH] det [MATH] n]}
[t] I[MATH] = GOTO(I[MATH], vp):
{[s [MATH] np vp [MATH]]}
I[MATH] = GOTO(I[MATH], relC/np)
= GOTO(I[MATH], relC/np)
= GOTO(I[MATH], relC/np):
{[np [MATH] np relC/np [MATH]]}
I[MATH] = GOTO(I[MATH], vi):
{[vp [MATH] vi [MATH]]}
I[MATH] = GOTO(I[MATH], vt):
{[vp [MATH] vt [MATH] np]
[vp [MATH] vt [MATH] np np]
[np [MATH] [MATH] det n]
[np [MATH] [MATH] np relC/np]}
I[MATH] = GOTO(I[MATH], relPron)
= GOTO(I[MATH], relPron)
= GOTO(I[MATH], relPron):
{[relC [MATH] relPron [MATH] s]
[s [MATH] [MATH] np vp]
[np [MATH] [MATH] det n]
[np [MATH] [MATH] np relC/np]}
[t] I[MATH] = GOTO(I[MATH], n):
{[np [MATH] det n [MATH]]}
I[MATH] = GOTO(I[MATH], np):
{[vp [MATH] vt np [MATH]]
[vp [MATH] vt np [MATH] np]
[np [MATH] np [MATH] relC/np]
[np [MATH] [MATH] det n]
[np [MATH] [MATH] np relC/np]
[relC [MATH] [MATH] relPron s]}
I[MATH] = GOTO(I[MATH], s):
{[relC [MATH] relPron s [MATH]]}
I[MATH] = GOTO(I[MATH], np):
{[vp [MATH] vt np np [MATH]]
[np [MATH] np [MATH] relC/np]
[relC [MATH] [MATH] relPron s]}
}
痕跡検出において，文のすべての単語間に痕跡の存在を仮定する理由を次に示す．
痕跡処理をおこなわずに痕跡を含む文を解析すると，通常，痕跡が存在する位置でその解析は失敗する．
そこで，痕跡処理において，解析が失敗する位置に痕跡が存在すると仮定して痕跡の検出をおこなうものとする．
そうすると，``A child whom a man gives a toy smiles.''などの文では，``A child whom a man gives a toy t smiles.''と解析されてしまい，正しく``A child whom a man gives t a toy smiles.''とは解析されない(tが痕跡を表す)．
このため，文のすべての単語間に痕跡の存在を仮定し痕跡の検出をおこなう．
痕跡が存在するか否かの判断は，LR構文解析表を参照することで即座におこなわれる．
このため，純粋なボトムアップ法での場合のような無駄な処理はおこなわれない．
また逆に，文のすべての単語間に痕跡の存在を仮定して痕跡の検出をおこなうと，``A toy which a man gives a child moves.''などの文では，``A toy which a man gives t a child moves.''と解析されてしまい，正しく``A toy which a man gives a child t moves.''とは解析されない(tが痕跡を表す)．
そこで，痕跡が存在すると判断される場合には，解析過程を分岐させ横型探索によって，痕跡は存在しないものとした解析も同時におこなう．
XGSで記述された文法に対して，通常のGLR法での方法で，状態を構成する項の集合を求めると，次の(1)〜(3)に示す問題が生じる．
ここで，説明上の都合により，slash項と芯という用語を導入する．
slash項とは，スラッシュ記法の直前(左隣り)にドット記号`・'のある項のことである．
図[REF_fig:states2]の項の集合I[MATH]に含まれる項[MATH]は，slash項の一例である．
また，slash項のうち，スラッシュ記法が右辺の左端に存在するものを左隅slash項と呼ぶことにする．
芯とは，閉包を求めるときに関数CLOSUREに与えた項の集合に含まれる項のことである．
図[REF_fig:states2]の項の集合I[MATH]では，項[MATH]と[MATH]が芯である．
状態が芯としてslash項とそうでない項を含む場合，そのslash項ではない項の閉包として得られた項に基づく解析においても，その状態に遷移するときにXリストにプッシュしたスラッシュカテゴリが参照されてしまい，誤った痕跡の検出が引き起される．
状態が芯として複数のslash項を含む場合，その状態に遷移するときにXリストにプッシュすべきスラッシュカテゴリが複数存在してしまう．
状態が左隅slash項を含む場合，その左隅slash項の閉包として得られた項以外の項に基づく解析においても，その状態に遷移するときにXリストにプッシュしたスラッシュカテゴリが参照されてしまい，誤った痕跡の検出が引き起される．
次に，これらの問題についてより具体的に述べるとともに，その解決方法を示す．
図[REF_fig:states2]の状態2(I[MATH])には，(1)に示した問題がある．
状態2に遷移するときにXリストにプッシュされたスラッシュカテゴリnpは，カテゴリrelCの解析においてのみ参照されるべきものである．
しかし，このスラッシュカテゴリnpは，Xリスト上に存在する限り，カテゴリvpの解析，つまり，I[MATH]のうちCLOSURE({[MATH]})に含まれる項に基づく解析においても参照されてしまう．
その結果，誤った痕跡の検出がおこなわれる．
非文である``A child has.''を用いて，次により具体的に述べる．
ここで，aの品詞はdet，childはn，hasはvtとする．
childまで解析が終了したとき，解析系の状態は状態9であり，Xリストは空である．
解析系は，次にhasを先読みし，その品詞であるvtを先読み情報として得る．
ここで，文法規則[MATH]による還元をおこない，一時的に状態0に遷移したのち状態2に遷移する．
このとき，Xリストにスラッシュカテゴリnpをプッシュする．
そして，先読み情報であるvtに従って状態7に遷移する．
ここで，Xリストの先頭にあるスラッシュカテゴリnpに対してLR構文解析表に動作が定義されているため，誤りであるにも関わらず，解析系はhasの直後(右隣り)にこのスラッシュカテゴリnpが痕跡として存在すると判断する．
そして，このスラッシュカテゴリnpをXリストからポップし，カテゴリnpに対してLR構文解析表に定義されている動作に従って状態10に遷移する．
この後，解析系は(状態2)[MATH]状態4[MATH](状態0)[MATH]状態1と遷移し，この非文が正しいものであるかのように解析を終了する．
この問題は，状態から芯であるslash項の閉包を取り出し，それによって新たな状態を構成することで解決できる．
図[REF_fig:states2]の状態2の場合，CLOSURE({[MATH]})を取り出し，これによって新たな状態を構成する．
この状態分割によって，図[REF_fig:states2]に示した状態を構成する項の集合は，図[REF_fig:states3]に示すものとなる．
図[REF_fig:states3]の状態2は図[REF_fig:states3]では，状態21と状態22へと分割される．
そして，解析系は状態22に遷移するときにのみ，スラッシュカテゴリnpをXリストにプッシュする．
これによって，上述の誤った痕跡の検出を防ぐことができる．
[htbp]
{
[t] I[MATH]:
{[S' [MATH] [MATH] s]
[s [MATH] [MATH] np vp]
[np [MATH] [MATH] det n]
[np [MATH] [MATH] np relC/np]}
I[MATH] = GOTO(I[MATH], s):
{[S' [MATH] s [MATH]]}
I[MATH] = GOTO(I[MATH], np)
= GOTO(I[MATH], np):
{[s [MATH] np [MATH] vp]
[vp [MATH] [MATH] vi]
[vp [MATH] [MATH] vt np]
[vp [MATH] [MATH] vt np np]}
I[MATH] = GOTO(I[MATH], np)
= GOTO(I[MATH], np)
= GOTO(I[MATH], np)
= GOTO(I[MATH], np):
{[np [MATH] np [MATH] relC/np]
[relC [MATH] [MATH] relPron s]}
[t] I[MATH] = GOTO(I[MATH], det)
= GOTO(I[MATH], det)
= GOTO(I[MATH], det)
= GOTO(I[MATH], det):
{[np [MATH] det [MATH] n]}
I[MATH] = GOTO(I[MATH], vp):
{[s [MATH] np vp [MATH]]}
I[MATH] = GOTO(I[MATH], relC/np):
{[np [MATH] np relC/np [MATH]]}
I[MATH] = GOTO(I[MATH], vi):
{[vp [MATH] vi [MATH]]}
I[MATH] = GOTO(I[MATH], vt):
{[vp [MATH] vt [MATH] np]
[vp [MATH] vt [MATH] np np]
[np [MATH] [MATH] det n]
[np [MATH] [MATH] np relC/np]}
[t] I[MATH] = GOTO(I[MATH], relPron):
{[relC [MATH] relPron [MATH] s]
[s [MATH] [MATH] np vp]
[np [MATH] [MATH] det n]
[np [MATH] [MATH] np relC/np]}
I[MATH] = GOTO(I[MATH], n):
{[np [MATH] det n [MATH]]}
I[MATH] = GOTO(I[MATH], np):
{[vp [MATH] vt np [MATH]]
[vp [MATH] vt np [MATH] np]
[np [MATH] [MATH] det n]
[np [MATH] [MATH] np relC/np]}
I[MATH] = GOTO(I[MATH], s):
{[relC [MATH] relPron s [MATH]]}
I[MATH] = GOTO(I[MATH], np):
{[vp [MATH] vt np np [MATH]]}
}
このように状態を分割しても問題が生じないのは，それぞれの芯の閉包を独立したものとして扱うことが可能なためである．
また，このような状態分割は，状態遷移における非決定性をもたらす．
例えば，図[REF_fig:states3]では状態0からのカテゴリnpによる遷移先として，状態21と状態22が存在する．
これらの非決定性に対して，解析系は解析過程を分岐させ横型探索をおこなう．
また，この状態分割の手法は(2)に示した問題に対しても有効である．
状態が芯として[MATH]や[MATH]などのslash項を含む場合，この状態に遷移するときにXリストにプッシュすべきスラッシュカテゴリとしてCやFなどが存在してしまう．
ここで，A，B，D，Eは非終端カテゴリ，[MATH]，[MATH]，[MATH]，[MATH]は非終端カテゴリおよび品詞からなるカテゴリ列，C，Fは非終端カテゴリあるいは品詞とする．
そこで，CLOSURE({[MATH]})やCLOSURE({[MATH]})などをそれぞれ取り出し，これらによって新たな状態をそれぞれ構成する．
そして，これらの新たに構成された状態に遷移するときにのみ，対応するスラッシュカテゴリをXリストにプッシュする．
このように，状態分割の手法によって，状態遷移においてXリストにプッシュすべきスラッシュカテゴリを一つにすることができる．
次に，(3)に示した問題について例を用いて述べる．
通常のGLR法での方法によって，図[REF_fig:xgs2]に示す文法から，状態を構成する項の集合の一つとして図[REF_fig:states4]に示すI[MATH]が得られる．
この状態x(I[MATH])には，左隅slash項[MATH]が含まれ，(3)に示した問題がある．
この状態xに遷移するときにXリストにプッシュされたスラッシュカテゴリnpは，カテゴリsの解析，つまり，CLOSURE({[relC [MATH] [MATH] s/np]})に含まれる項に基づく解析においてのみ参照されるべきものである．
しかし，このスラッシュカテゴリnpは，Xリスト上に存在する限り，CLOSURE({[relC [MATH] [MATH] s/np]})には含まれない，[s [MATH] np [MATH] vp]などの項に基づく解析においても参照されてしまう．
その結果，誤った痕跡の検出がおこなわれる．
先に述べたような状態分割の手法によって，この問題を解決することは難しい．
これは，左隅slash項の閉包とそれ以外の項とを独立したものとして扱えないためである．
図[REF_fig:states4]のI[MATH]では，項[MATH]に基づく解析には，CLOSURE({[relC [MATH] [MATH] s/np]})に含まれる項に基づく解析が含まれる．
このため，これらを独立したものとして扱うことはできない．
状態xからCLOSURE({[relC [MATH] [MATH] s/np]})を取り出し，状態の分割を敢えておこなうなら，状態xは図[REF_fig:states5]に示す状態x1と状態x2に分割される．
実際にこのような状態の分割をおこなった場合には，解析系はこれらの状態の間の依存関係を扱わなければならない．
例えば，状態x2においてカテゴリrelCが構成された場合には，解析系は依存関係に従って一時的に状態x1に遷移し，そこからカテゴリrelCによる遷移をおこなわなければならない．
次に，少し複雑な依存関係をともなう状態の分割をおこなった場合について述べる．
ある状態y(I[MATH]=CLOSURE({[MATH]}))が，y1(I[MATH]=CLOSURE({[MATH]})[MATH]I[MATH])，y2(I[MATH]=CLOSURE({[MATH]})[MATH]I[MATH])，y3(I[MATH]=CLOSURE({[MATH]}))の三つの状態に分割されるとする．
また，C \deriv D [MATH]，E \deriv G [MATH]とする．
ここで，A，C，D，E，G，Hは非終端カテゴリ，B，F，Jは非終端カテゴリあるいは品詞，[MATH]，[MATH]，[MATH]，[MATH]，[MATH]，[MATH]は非終端カテゴリおよび品詞からなるカテゴリ列，`\deriv'は0回以上の導出を表す．
これらの状態の関係を図[REF_fig:depend]に示す．
状態y1と状態y2は依存関係にあり，また，状態y2と状態y3も同様に依存関係にある．
解析系が状態y3に遷移するときには，スラッシュカテゴリであるJをXリストにプッシュすることになるが，これに加えてFもプッシュしなければならない．
これは，状態y3での解析が状態y2での解析の一部を構成するため，状態y2でのスラッシュカテゴリであるFが状態y3での解析においても参照可能でなければならないからである．
このように，依存関係をともなう状態分割をおこなった場合には，解析系の構成が複雑なものになってしまう．
[htbp]
[b]
{
[t] I[MATH]: {[s [MATH] np [MATH] vp]
[np [MATH] np [MATH] relC]
[vp [MATH] [MATH] vi]
[vp [MATH] [MATH] vt np]
[vp [MATH] [MATH] vt np np]}
I[MATH]: {[relC [MATH] [MATH] s/np]
[s [MATH] [MATH] np vp]
[np [MATH] [MATH] det n]
[np [MATH] [MATH] np relC]}
}
[b]{6cm}
また，状態に左隅slash項が再帰的に含まれる場合には，次に示す問題がある．
通常のGLR法での方法によって，図[REF_fig:xgs3]に示す文法から，状態を構成する項の集合の一つとして図[REF_fig:states6]に示すI[MATH]が得られる．
この状態z(I[MATH])には，左隅slash項[MATH]が再帰的に含まれている．
状態zからCLOSURE({[名詞句[MATH] [MATH]連体修飾節/後置詞句名詞句]})を取り出し状態の分割をおこなうと，状態zは図[REF_fig:states7]に示す状態z1と状態z2に分割される．
状態z1には，CLOSURE({[名詞句[MATH] [MATH]連体修飾節/後置詞句名詞句]})にも含まれる項[MATH]と[MATH]が含まれているが，これらは項[MATH]から導かれたものである．
状態z2では，左隅slash項[MATH]が再帰的に含まれているため，この項に基づく連体修飾節の解析が再帰的におこなわれ得る．
この再帰的な解析では，その再帰の数だけスラッシュカテゴリである後置詞句を必要とする．
しかし，どれだけ再帰的に解析がおこなわれるかを事前に知ることはできない．
このため，状態z2への遷移において，どれだけの数の後置詞句をスラッシュカテゴリとしてXリストにプッシュすべきかを決定できない．
このため，状態に左隅slash項が再帰的に含まれる場合には，状態分割の手法による対処は難しい．
[htbp]
このように，状態分割の手法は(3)に示した問題に対して有効でない．
そこで，文法規則の置き換えによる解決方法を次に示す．
左隅slash項は，右辺の左端にスラッシュ記法が存在する文法規則から生じる．
したがって，そのような文法規則が存在しなければ，左隅slash項が現れることはない．
そして，(3)に示した問題が起ることもない．
そこで，文法に対する前処理として，右辺の左端にスラッシュ記法が存在する文法規則に対して，図[REF_fig:replace]に示す置き換えをおこない，スラッシュ記法を擬似的に右辺の左端から移動させる．
これによって，左隅slash項が現れることはなくなり，(3)に示した問題は(1)あるいは(2)に示した問題に帰着される．
そして，先に述べたように，これらの問題は状態分割の手法によって解決される．
ここで，A，Bは非終端カテゴリ，Cは非終端カテゴリあるいは品詞，[MATH]は非終端カテゴリあるいは品詞からなるカテゴリ列を表す．
また，dummyはスラッシュ記法を擬似的に移動させるためだけに導入された非終端カテゴリであり，[MATH]は空文字列を表す．
図[REF_fig:xgs3]に示す文法では，前処理をおこなうと図[REF_fig:xgs4]に示すものとなる．
slash項[MATH]を含む状態において，Bが構成されたときに解析系がおこなう状態遷移には，二通りのものが考えられる．
ここで，A，Bは非終端カテゴリ，Cは非終端カテゴリあるいは品詞，[MATH]，[MATH]は非終端カテゴリおよび品詞からなるカテゴリ列を表す．
その一つは，B/Cによる状態遷移である．
解析系は，この状態に遷移するときにXリストにプッシュしたスラッシュカテゴリCが痕跡検出によって既にポップされているとき，B/Cによる状態遷移をおこなう．
もう一つは，単なるBによる状態遷移である．
この状態遷移は，Xリストの内容とは無関係である．
解析系は，LR構文解析表にBによる状態遷移が定義されているとき，これをおこなう．
したがって，B/Cによる状態遷移と単なるBによる状態遷移をともにおこなう必要がある場合には，解析系は解析過程を分岐させ横型探索をおこなう．
痕跡処理では，ロスの複合名詞句制約などのいわゆる「島制約」への対処が求められる．
次に，ロスの複合名詞句制約について述べ，その後，それへの対処方法を示す．
ロスの複合名詞句制約は，埋め込み文中の痕跡の位置に関する統語的な制約である．
ロスの複合名詞句制約によれば，名詞句は文や名詞句の構造を二度越えて移動することはできない[CITE]．
この制約に違反する例を図[REF_fig:np_const]に示す．
図[REF_fig:np_const]では，名詞句`a toy'がhasの直後(右隣り)から，`t[MATH] has t[MATH]'，そして，`the man knows the child who t[MATH] has t[MATH]'の二つの埋め込み文を越えて文頭に移動したために，ロスの複合名詞句制約に違反する．
[htbp]
XGSでは，ロスの複合名詞句制約を表現するために，open([MATH])，close([MATH])と呼ばれる記法が導入されている．
この記法には，「`[MATH]'と`[MATH]'の外側の構成素と，`[MATH]'と`[MATH]'で囲まれたカテゴリの中の痕跡とは対応付けることはできない」という意味が与えられている．
この記法の使用例を図[REF_fig:xgs5]に示す．
図[REF_fig:xgs5]に示す文法では，関係節を表すrelCが`[MATH]'と`[MATH]'で囲まれているため，関係節内の痕跡がその外側の構成素と対応付けられることはない．
これによって，関係節が多重に存在する文の解析において，ロスの複合名詞句制約が満たされることになる．
本論文で示す手法では，open([MATH])，close([MATH])を次のように解析系に組み込む．
文法規則中の`[MATH]'と`[MATH]'で囲まれたカテゴリを処理するときに，Xリストを一時的に空にする．
つまり，`[MATH]'と`[MATH]'で囲まれたカテゴリの直前(左隣り)にドット記号`・'のある項を含む状態に遷移するときに，Xリストを一時的に空にする．
そして，そのカテゴリの解析が終了したときに，Xリストの内容を元に戻す．
このようなXリストの操作によって，open([MATH])，close([MATH])は解析系に組み込まれる．
ここで，説明上の都合により，enclosed項という用語を導入する．
enclosed項とは，`[MATH]'と`[MATH]'で囲まれたカテゴリの直前(左隣り)にドット記号`・'のある項のことである．
また，enclosed項のうち，`[MATH]'と`[MATH]'で囲まれたカテゴリが右辺の左端に存在するものを左隅enclosed項と呼ぶことにする．
通常のGLR法での方法によって，図[REF_fig:xgs5]に示す文法から，状態を構成する項の集合の一つとして図[REF_fig:states8]に示すI[MATH]が得られる．
この状態s(I[MATH])には，enclosed項であり，かつslash項である[MATH]が含まれている．
したがって，解析系はこの状態sに遷移するときには，まず一時的にXリストを空にし，その後，スラッシュカテゴリであるnpをXリストにプッシュする．
また，解析系は状態sからrelC/npによる状態遷移をおこなうときには，Xリストの内容をこの状態sに遷移する前のものに復元する．
open([MATH])，close([MATH])を実現するXリスト操作による影響は，`[MATH]'と`[MATH]'で囲まれたカテゴリの解析，つまり，enclosed項の閉包に含まれる項に基づく解析に限定されなければならない．
そうでなければ，検出されるべき痕跡が検出されない．
open([MATH])，close([MATH])を用いて記述された文法に対して，通常のGLR法での方法で，状態を構成する項の集合を求めると，次の(1)，(2)に示す問題が生じる．
状態が芯としてenclosed項とそうでない項を含む場合，そのenclosed項ではない項の閉包として得られた項に基づく解析に対しても，その状態に遷移するときにおこなわれたXリスト操作が影響し，痕跡が検出されなくなる．
状態が左隅enclosed項を含む場合，その左隅enclosed項の閉包として得られた項以外の項に基づく解析に対しても，その状態に遷移するときにおこなわれたXリスト操作が影響し，痕跡が検出されなくなる．
これらの問題は，5章で論じた問題と類似している．
(1)に示す問題は，状態から芯であるenclosed項の閉包を取り出し，それによって新たな状態を構成することで解決できる．
また，(2)に示す問題は，文法に対する前処理として，右辺の左端に`[MATH]'と`[MATH]'で囲まれたカテゴリが存在する文法規則に対して，図[REF_fig:replace]に示すものと同様な置き換えをおこない，`[MATH]'と`[MATH]'で囲まれたカテゴリを擬似的に右辺の左端から移動させることで解決できる．
本論文で示す手法を用いてパーザを構成した例を次に示す．
DCGに対するGLRパーザとして論理型言語Prolog上に効率よく実装されたSGLR[CITE]を拡張することでパーザを構成した．
本論文では，このパーザをSGLR-plusと呼ぶことにする．
SGLR-plusを使用して，``A child who has a toy smiles.''という文を解析した様子を図[REF_fig:sglr_plus]に示す．
[htbp]
{11cm} {
| ?- run.
input: a child who has a toy smiles words: [a,child,who,has,a,toy,smiles] length: 7
--- result 1/1 ---
|- sentence |- sen_dec |- subj | |- noun_p | |- noun_p | | |- art -- < a > | | |- n -- < child > | |- relC/noun_p | |- relPron -- < who > | |- sen_dec | |- subj | | |- noun_p -- < t > | |- pred_do | |- verb_p | |- verb | |- vt -- < has > | |- obj | |- noun_p | |- art -- < a > | |- n -- < toy > |- pred_do |- verb_p |- verb |- vi -- < smiles >
argument info: []
the number of results: 1 run time: 10 msec
yes
}
SGLR-plus(痕跡処理あり)とSGLR(痕跡処理なし)を使用していくつかの文を解析した結果を次に示す．
今回の解析では，それぞれ平叙文を概ね網羅する文法を使用した．
また，SGLRは痕跡処理を持たないため，図[REF_fig:cfg2]と同様に，痕跡を含むカテゴリに対して，その痕跡に対応する構成素が欠けた文法規則を用意した．
ただし，これらの解析では補強項での統語的制約のチェックはおこなわなかった．
SGLR-plus，SGLRのそれぞれを使用した場合での文法規則数，解析系の状態数，項の総数を表[REF_tab:1]に示す．
SGLR-plusを使用した場合には，痕跡処理がおこなわれるため，SGLRを使用した場合と比較して3割ほど文法規則が減少している．
次に示す英文を解析の対象とした．
それぞれの英文に対する，解析に要した時間，得られた解析木の数，失敗した数を表[REF_tab:2]に示す．
The kids were skipping about in the park.
The coffee has slopped over into the saucer.
The trouble is that she does not like it.
I want to go to France.
They scattered gravel on the road.
He told me that he liked baseball.
I cannot allow you to behave like that.
The child who has a toy smiles.
Jane has an uncle who is very kind.
The book which I bought yesterday is very interesting.
I want a man who understands English.
The book which the man who had a bag which looked heavy bought is difficult.
SGLR-plus，SGLRのそれぞれを使用した場合の解析時間を比較すると，SGLR-plusを使用した場合により多くの時間を要す傾向がある．
一般に文法規則の増加は，非決定性の増加などによる処理量の増加を引き起す．
今回の比較では，痕跡に関連する処理量がこれを上回ったため，この傾向が生じたと考える．
この傾向は，痕跡を含まない(1)〜(7)の文の解析にも見られる．
これは，痕跡処理を解析系に組み込むためにおこなった状態分割に関連して，非決定性が増加したためであると考える．
SGLR-plusを使用した解析ではより多くの時間を要す傾向があるとは言え，対象とした文のうち，(12)以外のものの解析はおよそ数ミリ秒で終了している．
(12)の文は複数の痕跡を含むため，SGLR-plusを使用した解析では，痕跡処理に関連する非決定性が増加するとともに失敗の数も増加する．
この様子を表[REF_tab:3]に示す．
しかし，SGLRを使用した場合と比較すると，失敗の数ほど解析時間に差は生じていない．
これは，誤りがLR構文解析表から即座に判定されるためであると考える．
{
[htbp]
}
