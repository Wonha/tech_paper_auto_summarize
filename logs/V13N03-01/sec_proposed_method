用例ベース翻訳の基本的な原則はできるだけ大きなサイズの用例を用いて翻訳文を生成することである．
これを確率的に定式化するためには，大きな用例を用いた翻訳結果が大きな翻訳確率を持たなくてはならない．
本章では，これを実現するための基本アイデアを述べる．
まず，提案手法は入力文を可能なかぎりの部分木の組合せに分解する：
ここで，[MATH]は入力文の分解のパターン，[MATH]は[MATH]の集合である．
次に，[MATH]は入力文を[MATH]個の部分木に分解しているとする:
ここで，[MATH]は入力文の部分木である．
例えば，図[REF_f_prob.eps]左の入力文の場合，[MATH]の4通りの部分木の組合せで表現できる．
この例では，[MATH]は入力文を3つの部分木[MATH], [MATH]，[MATH]に分解している.
また，[MATH]，[MATH]は，入力文を2つの部分木に分解している．
また，[MATH]のように，文そのものも分解パターンとして取り扱う．
次に，各部分木[MATH]それぞれについて,もっとも翻訳確率[MATH](この確率の計算方法は次節にて述べる)の高い用例を選び，それらの積を翻訳文の翻訳確率[MATH]とする:
ここで，[MATH]を[MATH]の翻訳とみなし，[MATH]と表記する.
最後に，もっとも高い翻訳確率を持つ分解パターン（[MATH]）を以下の式によって探索し，最終的な翻訳を[MATH]とする：
簡単に言うと，提案手法は，入力文のある単位をどう翻訳するかと，どういう単位で翻訳するかという2つ問題を解いている．
前者は，最も確率の高い用例を選択することで解決しており，基本的な統計的翻訳と同様の考え方である．
後者は，入力文の分解パターンを選択することで解決している．
ここで重要なことは，本モデルの枠組みでは，大きな用例を用いた翻訳文が優先されることである．
この理由は，大きな用例は安定した翻訳先を持つ傾向にあるため，高い翻訳確率を持ち，当然，その積である翻訳文の確率[MATH]も自然と高くなるからである．
例えば，日本語``かける''は，翻訳の際には大きな曖昧性があり，``bet'',``run''や``play''など様々な英語表現が考えられる．
ここで，もし，[MATH]のように，入力文を小さな部分木に分解した場合は，適切な訳である[MATH]の翻訳確率は低く，適切な翻訳は行われない．
一方，[MATH]では，より大きな表現``CDをかける''を用いた用例を探索している．
この用例の英語表現としては，ほとんどが``play''となり，用例の翻訳確率は高くなる．
その結果，用例群の翻訳確率の積である[MATH]も高くなり，この結果が翻訳として採用される．
また，図[REF_f_prob.eps]の[MATH]のように，大きすぎる単位で検索した場合は，コーパス中に存在せず，確率が定義されない場合がある．
本節では，用例の翻訳確率の推定方法を述べる．
まず，英語部分木[MATH]と日本語部分木[MATH]からなる用例があるとする．
この翻訳確率[MATH]は，アライメントされたコーパス中での対応[MATH]の出現頻度を直接数えて求める:
ここで，[MATH]は，アライメントされたコーパスにおける対応[MATH]の出現頻度，[MATH]は日本語部分木([MATH])の出現頻度である．
ただし，この頻度の計算にあたっては，次節に述べるコンテキストの情報を利用した拡張が可能である．
用例の選択にあたって重要な手がかりは入力文と用例の一致するサイズであり，それは，2.1節で提案された翻訳確率の枠組みで実現されている．
しかし，用例のサイズに加えて，入力文と用例のコンテキストの類似も重要な手がかりである．
提案するモデルは，このようなコンテキストの類似を取り込む拡張を自然に行うことができる．
まず，提案手法を説明する前に，用例と入力文のコンテキストを定義する．
図[REF_f_cs.eps]に示されるように，用例の原言語側が[MATH]という3つの句と接続しているとする．
これらとそれと対応する入力文の[MATH]をコンテキストと考える．
そして，用例と入力文のコンテキストの類似度を次の式で定める:
ここで，[MATH]は用例Aの日本語側で翻訳に使う部分の周辺の句，[MATH]は[MATH]と対応する入力文の句，[MATH]は[MATH]の集合，[MATH]はシソーラス[CITE]を用いて計算する[MATH]と[MATH]の類似度(max=1)であり，以下の式で定義される:
ここで，[MATH]と[MATH]は，それぞれ[MATH]と[MATH]のシソーラス上での深さ，[MATH]は，[MATH]と[MATH]の共通するパスの深さである．
提案手法のポイントは，高い類似度を持つ用例は，同じく高い類似度を持つ用例のみを用いて翻訳確率を計算する点である．
すなわち，式5によって，ある用例の翻訳確率を計算する際には，[MATH]以上の類似度を持つ用例だけを集計して翻訳確率を計算し，[MATH]未満の類似度の用例は，用例の翻訳確率の計算には用いない．
この操作を用例のフィルタリングと呼ぶ．
このフィルタリングの操作は，用例のサイズごとに翻訳確率を計算する手法を，類似度にまで拡大したものであり，自然な拡張であるといえる．
この拡張の結果，高い[MATH]を持つ用例は，それよりも低い[MATH]を持つ用例の影響を受けず，多くの場合，高い翻訳確率を持つことになる．
例えば，``レコードをかける''がコーパスに存在しない（しかし，``レコード''と``かける''それぞれ単独では出現している）場合に，表[REF_tc0]の用例群を用いて翻訳することを考える．
前節までの手法では，このように，大きなサイズで一致するものがない場合，``かける''単独で翻訳確率を計算することになり，``bet''など不適切な訳語が選ばれる可能性がある．
本節の提案手法では，用例``CDをかける''と入力文``レコードをかける''の[MATH]が0.8であるとすると，同じく0.8以上の[MATH]を持つ用例だけを用いて翻訳確率を計算する．
この場合，用例の数は3つだけとなるとが，その英語表現は安定しており，[MATH], [MATH]となる.
このように類似したコンテキストを持つ用例の翻訳確率は自然と高くなる傾向をもつ．
また，この枠組では，類似度がもっとも高い用例が一つしかない場合，その翻訳確率は最大の1となる．
これは，より大きな用例が利用可能であった場合に，その大きな用例よりも，類似している小さな用例を優先しているかのように見える．
この問題は次のように解決されている．
まず，提案手法は用例を構築する際に，大きな用例を分解した一部分も独立した用例として扱い，データベースに蓄える(3.1節ステップ3)．
よって，ある大きな用例が利用できる状態で，それよりも小さい，もっとも類似した用例が一つしかない場合における，その一つしかない用例とは，大きな用例の一部分から作られた用例となる．
というのは，大きな用例が利用可能であるならば，その分解から得られた用例は，その周辺が入力文と同一であり，最大の類似度とるためである．
よって，この場合，大きな用例ともっとも類似している用例のどちらを採用すると考えても，作られる翻訳は同じとなる．
提案するシステムは，次の2つのモジュールから構成される：
アライメント・モジュール：コーパスから用例を構築するモジュール，
翻訳モジュール：翻訳を行うモジュール．
ステップ1：対訳文の依存構造への変換
まず，対訳文を日本語パーサKNP [CITE]と英語パーサnl-parser[CITE]によって統語解析する．
日本語の句の単位は，KNPの出力する文節とし，KNPの出力する依存構造をそのまま以降の処理に用いる．
英語パーサは句構造を出力するので，句構造中の主辞を決定して，出力結果を依存構造に変換する．
この際，主辞の決定には人手で作成した規則を用い，句の単位はbase-NP，base-VPとした．
ステップ2：アライメント
次に，翻訳辞書を用いたアライメントを行い，両言語の句の対応関係を得る．
これには，[CITE]の手法をそのまま用いた．
この手法は，辞書を使用するが，後述する実験では次の辞書を用いた：EDR電子化辞書，EDICT,英辞郎.
これらの辞書はのべ二百万項目を持つ．
このステップの結果，システムは，図[REF_f_te_c6_te.eps]左のようなアライメントされた対訳文を得る．
ステップ3：用例データベースの構築
最後に，アライメントされた対訳文（図[REF_f_te_c6_te.eps]左）から，用例データベースを構築する．
この際，システムは，あらゆる対応の組み合わせを生成し，その周辺の句（これはコンテキストの類似度を計算する際に用いる）とともにデータベースに登録する（図[REF_f_te_c6_te.eps]右）．
ステップ1：入力文の解析
まず，入力文を日本語パーサKNP[CITE]を用いて統語解析する．
ステップ2：用例の選択
入力文のあらゆる可能な部分木の組み合わせに分解し（前章の図[REF_f_prob.eps]の左），それらの部分木それぞれについて，用例データベース中を検索し，前章の手法にて，その翻訳確率を計算する．
そして，最も翻訳確率の高くなる用例の組み合わせを採用する．
ステップ3：翻訳文の生成
前ステップで採用された用例群を結合し，出力文の依存構造にまとめ上げる．
この操作は次の2つの規則によって行われる．
用例内部の依存構造は，出力文にそのまま用いる．
例えば，2つの翻訳用例（TE1，TE2）を結合して翻訳文を生成する場合を考える（図[REF_f_d1.eps]）．
ここで，TE1に含まれる2つの句([MATH],[MATH])の依存関係（太線で描かれている）は，そのまま翻訳文に用いられる．
用例間の依存関係は，その用例が対応する入力文句の依存構造と同じ親子関係とする．
例えば，図[REF_f_d1.eps]のTE1とTE2の間の依存関係について考える．
TE2は入力文の[MATH]と対応しており，[MATH]は[MATH]と親子関係にある．
よって，翻訳文側でも，[MATH]と対応する[MATH]は，[MATH]と対応する[MATH]と親子関係にあるものと考え，点線で描かれている依存関係を得る．
最後に，出力文の依存構造の語順を決定する．
これは，先の依存構造の場合と同様に，用例の内部の語順は保存し，用例のつなぎ目の語順は，単語[MATH]-gram言語モデルにて優先される語順を採用する．
用例ベース翻訳の基本的な原則はできるだけ大きなサイズの用例を用いて翻訳文を生成することである．
これを確率的に定式化するためには，大きな用例を用いた翻訳結果が大きな翻訳確率を持たなくてはならない．
本章では，これを実現するための基本アイデアを述べる．
まず，提案手法は入力文を可能なかぎりの部分木の組合せに分解する：
ここで，[MATH]は入力文の分解のパターン，[MATH]は[MATH]の集合である．
次に，[MATH]は入力文を[MATH]個の部分木に分解しているとする:
ここで，[MATH]は入力文の部分木である．
例えば，図[REF_f_prob.eps]左の入力文の場合，[MATH]の4通りの部分木の組合せで表現できる．
この例では，[MATH]は入力文を3つの部分木[MATH], [MATH]，[MATH]に分解している.
また，[MATH]，[MATH]は，入力文を2つの部分木に分解している．
また，[MATH]のように，文そのものも分解パターンとして取り扱う．
次に，各部分木[MATH]それぞれについて,もっとも翻訳確率[MATH](この確率の計算方法は次節にて述べる)の高い用例を選び，それらの積を翻訳文の翻訳確率[MATH]とする:
ここで，[MATH]を[MATH]の翻訳とみなし，[MATH]と表記する.
最後に，もっとも高い翻訳確率を持つ分解パターン（[MATH]）を以下の式によって探索し，最終的な翻訳を[MATH]とする：
簡単に言うと，提案手法は，入力文のある単位をどう翻訳するかと，どういう単位で翻訳するかという2つ問題を解いている．
前者は，最も確率の高い用例を選択することで解決しており，基本的な統計的翻訳と同様の考え方である．
後者は，入力文の分解パターンを選択することで解決している．
ここで重要なことは，本モデルの枠組みでは，大きな用例を用いた翻訳文が優先されることである．
この理由は，大きな用例は安定した翻訳先を持つ傾向にあるため，高い翻訳確率を持ち，当然，その積である翻訳文の確率[MATH]も自然と高くなるからである．
例えば，日本語``かける''は，翻訳の際には大きな曖昧性があり，``bet'',``run''や``play''など様々な英語表現が考えられる．
ここで，もし，[MATH]のように，入力文を小さな部分木に分解した場合は，適切な訳である[MATH]の翻訳確率は低く，適切な翻訳は行われない．
一方，[MATH]では，より大きな表現``CDをかける''を用いた用例を探索している．
この用例の英語表現としては，ほとんどが``play''となり，用例の翻訳確率は高くなる．
その結果，用例群の翻訳確率の積である[MATH]も高くなり，この結果が翻訳として採用される．
また，図[REF_f_prob.eps]の[MATH]のように，大きすぎる単位で検索した場合は，コーパス中に存在せず，確率が定義されない場合がある．
本節では，用例の翻訳確率の推定方法を述べる．
まず，英語部分木[MATH]と日本語部分木[MATH]からなる用例があるとする．
この翻訳確率[MATH]は，アライメントされたコーパス中での対応[MATH]の出現頻度を直接数えて求める:
ここで，[MATH]は，アライメントされたコーパスにおける対応[MATH]の出現頻度，[MATH]は日本語部分木([MATH])の出現頻度である．
ただし，この頻度の計算にあたっては，次節に述べるコンテキストの情報を利用した拡張が可能である．
用例の選択にあたって重要な手がかりは入力文と用例の一致するサイズであり，それは，2.1節で提案された翻訳確率の枠組みで実現されている．
しかし，用例のサイズに加えて，入力文と用例のコンテキストの類似も重要な手がかりである．
提案するモデルは，このようなコンテキストの類似を取り込む拡張を自然に行うことができる．
まず，提案手法を説明する前に，用例と入力文のコンテキストを定義する．
図[REF_f_cs.eps]に示されるように，用例の原言語側が[MATH]という3つの句と接続しているとする．
これらとそれと対応する入力文の[MATH]をコンテキストと考える．
そして，用例と入力文のコンテキストの類似度を次の式で定める:
ここで，[MATH]は用例Aの日本語側で翻訳に使う部分の周辺の句，[MATH]は[MATH]と対応する入力文の句，[MATH]は[MATH]の集合，[MATH]はシソーラス[CITE]を用いて計算する[MATH]と[MATH]の類似度(max=1)であり，以下の式で定義される:
ここで，[MATH]と[MATH]は，それぞれ[MATH]と[MATH]のシソーラス上での深さ，[MATH]は，[MATH]と[MATH]の共通するパスの深さである．
提案手法のポイントは，高い類似度を持つ用例は，同じく高い類似度を持つ用例のみを用いて翻訳確率を計算する点である．
すなわち，式5によって，ある用例の翻訳確率を計算する際には，[MATH]以上の類似度を持つ用例だけを集計して翻訳確率を計算し，[MATH]未満の類似度の用例は，用例の翻訳確率の計算には用いない．
この操作を用例のフィルタリングと呼ぶ．
このフィルタリングの操作は，用例のサイズごとに翻訳確率を計算する手法を，類似度にまで拡大したものであり，自然な拡張であるといえる．
この拡張の結果，高い[MATH]を持つ用例は，それよりも低い[MATH]を持つ用例の影響を受けず，多くの場合，高い翻訳確率を持つことになる．
例えば，``レコードをかける''がコーパスに存在しない（しかし，``レコード''と``かける''それぞれ単独では出現している）場合に，表[REF_tc0]の用例群を用いて翻訳することを考える．
前節までの手法では，このように，大きなサイズで一致するものがない場合，``かける''単独で翻訳確率を計算することになり，``bet''など不適切な訳語が選ばれる可能性がある．
本節の提案手法では，用例``CDをかける''と入力文``レコードをかける''の[MATH]が0.8であるとすると，同じく0.8以上の[MATH]を持つ用例だけを用いて翻訳確率を計算する．
この場合，用例の数は3つだけとなるとが，その英語表現は安定しており，[MATH], [MATH]となる.
このように類似したコンテキストを持つ用例の翻訳確率は自然と高くなる傾向をもつ．
また，この枠組では，類似度がもっとも高い用例が一つしかない場合，その翻訳確率は最大の1となる．
これは，より大きな用例が利用可能であった場合に，その大きな用例よりも，類似している小さな用例を優先しているかのように見える．
この問題は次のように解決されている．
まず，提案手法は用例を構築する際に，大きな用例を分解した一部分も独立した用例として扱い，データベースに蓄える(3.1節ステップ3)．
よって，ある大きな用例が利用できる状態で，それよりも小さい，もっとも類似した用例が一つしかない場合における，その一つしかない用例とは，大きな用例の一部分から作られた用例となる．
というのは，大きな用例が利用可能であるならば，その分解から得られた用例は，その周辺が入力文と同一であり，最大の類似度とるためである．
よって，この場合，大きな用例ともっとも類似している用例のどちらを採用すると考えても，作られる翻訳は同じとなる．
提案するシステムは，次の2つのモジュールから構成される：
アライメント・モジュール：コーパスから用例を構築するモジュール，
翻訳モジュール：翻訳を行うモジュール．
ステップ1：対訳文の依存構造への変換
まず，対訳文を日本語パーサKNP [CITE]と英語パーサnl-parser[CITE]によって統語解析する．
日本語の句の単位は，KNPの出力する文節とし，KNPの出力する依存構造をそのまま以降の処理に用いる．
英語パーサは句構造を出力するので，句構造中の主辞を決定して，出力結果を依存構造に変換する．
この際，主辞の決定には人手で作成した規則を用い，句の単位はbase-NP，base-VPとした．
ステップ2：アライメント
次に，翻訳辞書を用いたアライメントを行い，両言語の句の対応関係を得る．
これには，[CITE]の手法をそのまま用いた．
この手法は，辞書を使用するが，後述する実験では次の辞書を用いた：EDR電子化辞書，EDICT,英辞郎.
これらの辞書はのべ二百万項目を持つ．
このステップの結果，システムは，図[REF_f_te_c6_te.eps]左のようなアライメントされた対訳文を得る．
ステップ3：用例データベースの構築
最後に，アライメントされた対訳文（図[REF_f_te_c6_te.eps]左）から，用例データベースを構築する．
この際，システムは，あらゆる対応の組み合わせを生成し，その周辺の句（これはコンテキストの類似度を計算する際に用いる）とともにデータベースに登録する（図[REF_f_te_c6_te.eps]右）．
ステップ1：入力文の解析
まず，入力文を日本語パーサKNP[CITE]を用いて統語解析する．
ステップ2：用例の選択
入力文のあらゆる可能な部分木の組み合わせに分解し（前章の図[REF_f_prob.eps]の左），それらの部分木それぞれについて，用例データベース中を検索し，前章の手法にて，その翻訳確率を計算する．
そして，最も翻訳確率の高くなる用例の組み合わせを採用する．
ステップ3：翻訳文の生成
前ステップで採用された用例群を結合し，出力文の依存構造にまとめ上げる．
この操作は次の2つの規則によって行われる．
用例内部の依存構造は，出力文にそのまま用いる．
例えば，2つの翻訳用例（TE1，TE2）を結合して翻訳文を生成する場合を考える（図[REF_f_d1.eps]）．
ここで，TE1に含まれる2つの句([MATH],[MATH])の依存関係（太線で描かれている）は，そのまま翻訳文に用いられる．
用例間の依存関係は，その用例が対応する入力文句の依存構造と同じ親子関係とする．
例えば，図[REF_f_d1.eps]のTE1とTE2の間の依存関係について考える．
TE2は入力文の[MATH]と対応しており，[MATH]は[MATH]と親子関係にある．
よって，翻訳文側でも，[MATH]と対応する[MATH]は，[MATH]と対応する[MATH]と親子関係にあるものと考え，点線で描かれている依存関係を得る．
最後に，出力文の依存構造の語順を決定する．
これは，先の依存構造の場合と同様に，用例の内部の語順は保存し，用例のつなぎ目の語順は，単語[MATH]-gram言語モデルにて優先される語順を採用する．
