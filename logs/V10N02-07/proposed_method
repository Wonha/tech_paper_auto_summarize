情報検索において，[MATH]個の索引語を予め決めておけば，文書は[MATH]次元の索引語ベクトルとして表現できる（ここでは列ベクトルとして考える）．
検索対象の文書群が[MATH]個ある場合，各文書[MATH]に対する[MATH]次元の索引語ベクトルが[MATH]個並ぶので，[MATH]の索引語文書行列[MATH]ができる．
[MATH]の行列[MATH]の特異値分解とは，行列[MATH]を以下のような行列[MATH]，[MATH]，[MATH]の積に分解することである．
ここで，[MATH]は[MATH]の直交行列，[MATH]は[MATH]の直交行列である．
また[MATH]は[MATH]の行列であり，[MATH]とすると，対角線上に[MATH]個の要素[MATH]（ただし[MATH]）が並んだ行列である．
それ以外の[MATH]の要素は0である．
行列[MATH]の特異値分解を行ったとき，[MATH]は[MATH]の列ベクトルが張る空間の正規直交基底となっている．
そして[MATH]内の列ベクトルは左側にあるものほど基底としての重要度が高い．
そこで，[MATH]の最初の[MATH]個の列ベクトルを使って，索引語ベクトルを表すことにする．
具体的には索引語ベクトルを[MATH]の最初の[MATH]個の列ベクトルに射影させればよい．
つまり，[MATH]の最初の[MATH]個の列ベクトルで作成される[MATH]の行列を[MATH]とおくと，索引語ベクトル[MATH]は[MATH]によって[MATH]次元のベクトルで表現できることになる．
実際の検索では，[MATH]次元の索引語ベクトルで表現されていたクエリ[MATH]も[MATH]によって[MATH]次元のベクトルで表現し，[MATH]と[MATH]の距離によって，[MATH]と[MATH]の距離を測ればよい．
例えば，[MATH]と[MATH]の距離[MATH]は以下のように測ることができる[CITE]．
以上より，情報検索にLSIを利用するためには，索引語文書行列[MATH]の特異値分解から得られる行列[MATH]が求まれば良いことがわかる．
行列[MATH]の特異値分解を行うツールがSVDPACKCである．
SVDPACKCはフリーで配布されており，以下のURLから入手できる．
http://www.netlib.org/svdpack/svdpackc.tgz
SVDPACKCには特異値分解を行うC言語のプログラムが8つ入っている．
この中で最も計算速度が優れているのはlas2と名付けられているランチョス法[CITE]を使ったプログラムである．
単に特異値分解の結果だけを得たいのであればlas2を利用すれば良く，他のプログラムをコンパイルする必要はない．
ここではlas2だけをコンパイルする．
las2.cをコンパイルする前に，las2.cの中でコメントアウトされているマクロ定数UNIX_CREATを有効にしておく．
/* #define UNIX_CREAT */→#define UNIX_CREAT
これによってlas2による特異値分解の結果がファイルに保存される．
次に，las2.hのマクロ定数LMTNW，NMAX，NZMAXの値を適当に調整する．
これらは取り得るメモリの最大サイズ，行列の最大サイズ，行列中の非ゼロ要素の最大個数を定義したものであり，どの程度の大きさの行列を扱えるかを示している．
扱う問題や利用する計算機にもよるだろうが，本論文での実験では予め与えられている値の10倍の数に変更した．
実行時に行列のサイズに関するエラーが出た場合は，これらの値を設定し直してコンパイルする．
またlas2.cの中ではrandom関数を自前で用意しているために，stdlib.hで定義されているrandom関数と競合する場合がある．
ここではlas2.c中のstdlib.hをincludeしないことにした．
#include <stdlib.h>→/* #include <stdlib.h> */
コンパイルはmakefileのコンパイラの指定（CC）を利用するコンパイラに合わせて，以下を実行する．
ここではLinuxのgccで問題なくコンパイルできた．
make  las2
またマニュアルには，CRAY Y-MP，IBM RS/6000-550，DEC 5000-100，HP 9000-750，SPARCstation 2及びMachintosh II/fxでSVDPACKCが動作することが記載されている．
またWindows2000上のBorland C++ Compiler 5.5を利用してもlas2.cをコンパイルできた．
更にWindows2000上のcygwin + gcc環境でもコンパイルできた．
特別なライブラリは使われていないので，多くの環境でコンパイル可能と思われる．
las2は内部で２つのファイルを読む込む．
１つは特異値分解を行いたい対象の行列が記述されたファイルmatrixであり，もう１つはパラメータを記述したファイルlap2である．
この２つのファイルを適切に用意することで，las2を実行することができる．
配布キットでは，サンプルの行列がbelladit.Zという名前の圧縮されたファイルとして提供されている．
このファイルから，例えば以下のコマンドにより，matrixファイルを作り，las2を試してみる．
lap2はこのサンプル用にキット内に用意されている．
zcat belladit.Z > matrix
実行は以下のように単にコマンド名だけを入力する．
.
/las2
結果はlav2とlao2というファイルに保存される．
lav2には特異値分解したときの式[REF_siki1]における[MATH]や[MATH]の配列が保存される．
ただし，バイナリファイルなので直接見ることはできない．
lao2には特異値分解したときの式[REF_siki1]の[MATH]，つまり特異値の列とその他の情報（行列の大きさや実行時間等）が保存される．
これはテキストファイルなので中身を確認できる．
特異値分解の対象となる行列[MATH]は，ハーウェル・ボーイング形式（Harwell-Boeing format）と呼ばれる列方向の圧縮形式を用いてファイルmatrixに記述する．
これによりスパース行列を少ない記述量で簡単に表現することができる．
最初に注意として，行列[MATH]の大きさを[MATH]とした場合，SVDPACKCでは[MATH]を仮定している．
そのために，実際に特異値分解したい行列[MATH]の列数の方が行数よりも大きい場合は，行列[MATH]の転置行列[MATH]に対して特異値分解を行う必要がある．
この場合，式[REF_siki2]の[MATH]は[MATH]と置き換えなければならないこともある．
ここでは，matrixの記述形式の説明として，以下のような行列[MATH]を考える．
この行列に対して，１列目から順に非ゼロ要素を取り出し，以下のような表を作る．
次にこの表から位置の行の部分だけを取り出す．
次に各列の最初の非ゼロ要素のデータ番号を列ポインタに記述する．
例えば，1列目であれば，最初の非ゼロ要素は(1,1)の1.0であり，これに対するデータ番号は1である．
次に2列目であれば，最初の要素は(2,2)の2.1であり，これに対するデータ番号は3である．
これを各列，順に記述したものが列ポインタである．
つまり列ポインタの要素数は配列[MATH]の列数となる．
ハーウェル・ボーイング形式とは，行列に対して，このような表を作り，列ポインタ，行位置，値を記述した形式である．
これはスパース行列を圧縮した表現となる．
matrixでは4行目以降に，列ポインタ，行位置，値が記述されている．
列ポインタについては最後の非ゼロ要素のデータ番号に１を足したものが付け加えられることに注意する．
先の例では以下のようになる．
{|c|} \hline
{134mm}
1 3 7 9 11 1 6 2 3 4 5 5 6 2 7 1.0 1.0 2.1 1.0 0.8 0.8 1.0 2.2 0.5 1.0
\hline
matrixの最初の4行は行列に関するその他の情報が記述されている．
3行目以外意味はない．
1行目はデータの名前であり，サンプルファイルのbelladit.Zを参考に適当につければよい．
2行目，4行目も意味はなく，belladit.Zの通りに記述すれば良い．
3行目は以下のように5つのデータを空白で区切って記述すればよい．
{|c|} \hline
{134mm}
rra 7 4 10 0
\hline
この行の1列目（rra），5列目（0）はこの通り記述すれば良い．
2列目（7）は行列[MATH]の行数，3列目（4）は列数，4列目（10）は非ゼロ要素の総数を記述する．
結果，先の例において，matrixは以下のようになる．
{|c|} \hline
{134mm}
Jikken Data jikken Transposed rra 7 4 10 0 (10i8) (10i8) (8f10.3) (8f10.3) 1 3 7 9 11 1 6 2 3 4 5 5 6 2 7 1.0 1.0 2.1 1.0 0.8 0.8 1.0 2.2 0.5 1.0
\hline
lap2ファイルはlas2で使われるパラメータが1行で記述されている．
例えば，配布キットに入っているlap2ファイルの中身は以下のような1行のファイルであり，8個のデータが空白で区切られて入っている．
{|c|} \hline
{134mm}
'belladit' 44 10 -1.0e-30 1.0e-30 TRUE 1.0e-6 0
\hline
1列目（'belladit'）はmatrixファイルの1行目に記述したデータの名前である．
matrixとlap2とのデータ名の一致は検査していないので，実質意味はない．
適当な名前をつければ良い．
4列目（-1.0e-30），5列目（1.0e-30），6列目（1.0e-6）の数値は，繰り返しの収束条件にあたるものであり，特に変更する必要はない．
7列目（TRUE）は特異値分解の結果の[MATH]や[MATH]の行列をファイルに保存するかどうかの指定であり，TRUEにしておけば保存される．
8列目に意味はない．
実際は何も書かなくてもよい．
問題は2列目（44）と3列目（10）の整数値である．
結論から述べれば，どちらも行列[MATH]の列数[MATH]を設定すればよい．
今，2列目の整数値をlanmax，3列目の整数値をmaxprsとおく．
lanmaxはlas2のアルゴリズムであるランチョス法の最大の繰り返し回数を意味する．
一方，maxprsの意味はやや不明確である．
マニュアルには，所望の[MATH]や[MATH]の次元数と記載されているが，例えば， maxprs = 20と設定したからといって，必ずしも[MATH]や[MATH]の次元数が20になって出力されるわけではなく，10であったり，25であったりする．
このような違いはlanmaxの数値とも関連しており，依存関係は複雑である．
しかしlas2内部では，[MATH]や[MATH]を最大の次元数に設定して計算しており，最後の出力の部分で指定した次元数を考慮して出力させている．
そのためmaxprsの値は実行時間等に影響はなく，現実的には得られる最大の次元数を出力させ，その結果から所望の次元数を得た方が取り扱いが簡単である．
las2による特異値分解の結果はlav2とlao2というファイルに保存される．
lao2はテキストファイルであり，内容の確認は容易である．
重要部分はファイルの下方に記載されている固有値の列である．
この部分を適当に切り取って利用すればよい．
また，lao2では，固有値は値の小さい順に出力されていることに注意すべきである．
固有値は大きい方が重要な意味を持つため，ファイルの下方に書かれた特異値ほど重要である．
lav2はバイナリファイルであり，las2のソースをみて出力形式を確認すれば，特異値分解結果の[MATH]や[MATH]を得ることが可能である．
結局，lav2をテキストファイルの形式に変換する何らかのプログラムを自作する必要がある．
ただし，そのようなプログラムを作成するのであれば，las2のソースを直接変更して，テキストファイルの形式で出力させた方が簡単である．
例えば，las2.cの334行目で[MATH]が出力されているので，以下のように変更する．
{|c|} \hline
[H]{134mm}
変更前write(fp_out2, (char *)&xv1[ida], size1);
変更後
long kk; /*この変数をはじめの方で作っておく*/
.
..
/* write(fp_out2, (char *)&xv1[ida], size1); */ for(kk = 0;kk < nrow;kk++) fprintf(fp_out2," fprintf(fp_out2,"EOV\n"); /*ベクトルの終りの記号も入れる*/
\hline
これでlav2 に[MATH]の中身がテキスト形式で出力される．
ファイル名も変更したいときは，148行目の以下の部分を書き換える．
out2 = "lav2";
またlas2.cの756行目で[MATH]が出力されているので，以下のように変更する．
{|c|} \hline
[H]{134mm}
変更前for (i = 0; i < n; i++) xv1[id++] = w1[i];
変更後
FILE *fp_out3; /*他と合わせるためにlas2.hに書いておく．
大域変数となる．
*/ .
..
fp_out3 = fopen("V-matrix", "w"); /*行列Vのファイル名はV-matrixとする．
main中でfopenで開いておく*/ .
..
/* for (i = 0; i < n; i++) xv1[id++] = w1[i]; */ for (i = 0; i < n; i++) { xv1[id++] = w1[i]; fprintf(fp_out3," } fprintf(fp_out3,"EOV\n"); /*ベクトルの終りの記号も入れる*/
\hline
以上のようにして，テキストファイルの形式で[MATH]や[MATH]を得ることができる．
これらのファイルは，[MATH]や[MATH]の列ベクトルが，順に出力されている形になるが，その順序はlao2の固有値の順序に対応している．
つまり，固有値の大きな順に[MATH]個の列ベクトルを取り出すときには，下方にあるベクトルから順に[MATH]個取り出さなければならないことに注意する．
ここでは情報検索以外へのLSIの応用として語義判別問題を取り上げる．
SENSEVAL2の日本語辞書タスクで課題として出された動詞50単語を実験の対象とする．
単語[MATH]は[MATH]個の語義を持つとし，各語義を[MATH]  ([MATH])で表す．
単語[MATH]の語義判別問題とは，テキストに単語[MATH]が現れたときに，その文脈上での単語[MATH]の語義[MATH]を判定する問題である．
文脈を[MATH]個の素性のベクトル[MATH]で表現した場合，この語義判別問題は分類問題となり，帰納学習の手法により解決できる．
ここでは最近傍法（Nearest Neighbor法，以下NN法と略す）[CITE]を用いる．
NN法は与えられた素性ベクトルと最も距離が近い訓練事例中の素性ベクトルを選び，そのクラスを出力とする手法である．
今，単語[MATH]の訓練データの事例数を[MATH]とし，各事例を[MATH]の素性ベクトル[MATH]（[MATH]）で表す．
すると訓練データ全体の集合は[MATH]の行列[MATH]として表せる．
実際の語義判別は，単語[MATH]の現れた文脈を素性ベクトル[MATH]で表し，以下の式で求められる訓練事例[MATH]のクラスを返すことで行える．
ここでのNN法は，[MATH]を単純なコサイン尺度で計算することにする．
また行列[MATH]を特異値分解し，式[REF_siki2]を利用して[MATH]を定義したものをLSI法と呼ぶことにする．
ここでは語義判別の手がかりとなる属性として以下のものを設定した．
e1直前の単語e2直後の単語e3前方の内容語２つまでe4後方の内容語２つまでe5 e3の分類語彙表の番号e6 e5の分類語彙表の番号
例えば，語義判別対象の単語を「出す」として，以下の文を考える（形態素解析され各単語は原型に戻されているとする）．
短い/コメント/を/出す/に/とどまる/た/。
この場合，「出す」の直前，直後の単語は「を」と「に」なので， `e1=を'，`e2=に'となる．
次に，「出す」の前方の内容語は「短い」と「コメント」なので， `e3=短い'，`e3=コメント'の２つが作られる．
またここでは句読点も内容語に設定しているので，「出す」の後方の内容語は「とどまる」「。
」となり， `e4=とどまる'，`e4=。
'が作られる．
次に「短い」の分類語彙表[CITE]の番号を調べると，3.1920_1である．
ここでは分類語彙表の4桁目と5桁目までの数値をとることにした．
つまり`e3=短い'に対しては，`e5=3192' と `e5=31920' が作られる．
「コメント」は分類語彙表には記載されていないので， `e3=コメント'に対してはe5に関する素性は作られない．
次は「とどまる」の分類語彙表を調べるはずだが，ここでは平仮名だけで構成される単語の場合，分類語彙表の番号を調べないことにしている．
これは平仮名だけで構成される単語は多義性が高く，無意味な素性が増えるので，その問題を避けたためである．
もしも分類語彙表上で多義になっていた場合には，それぞれの番号に対して並列にすべての素性を作成する．
結果として，上記の例文に対しては以下の8つの素性が得られる．
e1=を，e2=に，e3=短い，e3=コメント，e4=とどまる，e4=。
，e5=3192，e5=31920，
上記の例のようにして，「出す」に対するすべての訓練事例の素性を集め，各素性に1番から順に番号をつける．
例えば，本論文の実験では「出す」に対しては978種類の素性があり，上記例の素性には表[REF_sosei-jigen]のように番号が振られた．
以上より，上記例文に対する素性ベクトルは第21次元目，第60次元目，第134次元目，第302次元目，第379次元目，第406次元目，第789次元目，第790次元目の各要素が1であり，その他の要素がすべて0の978次元のベクトルとなる．
LSI法を利用した場合，NN法と比較して，必ずしも精度が向上するわけではなく，逆に精度が悪化する場合もある．
そのため単純にすべての単語に対して，LSI法を用いることはできない．
そこで交差検定を行い，次元圧縮の効果が確認できる単語のみLSI法を用いることにする．
このようにNN法とLSI法を融合した手法をLSI+NN法と呼ぶことにする．
ここでの交差検定では訓練データを4分割し，3つを訓練データ，1つをテストデータとする．
組合わせを変えて，合計4通りの実験を行う．
各実験では，NN法とLSI法のテストデータに対する正解率を測る．
また特異値分解を使って圧縮する次元数は75とした．
ただし行列[MATH]のランク数が75以下の場合は，行列[MATH]のランク数にした．
付録の表[REF_jigen-com1]にlas2の結果をまとめている．
そこではSENSEVAL2の日本語辞書タスクの動詞50単語の各単語に対する行列[MATH]の大きさ，非ゼロ要素の密度，圧縮した次元数，次元圧縮に要したメモリと時間が記されている．
ただし，これらは4通りの実験での平均である．
また次元圧縮に要したメモリと時間はlas2の出力ファイルlao2から得ている．
各単語に対して，4通りの実験の平均をとった結果が表[REF_kousakekka]である．
特異値分解を利用することで正解率が向上したものは，表[REF_kousakekka]で〇印のつけた以下の14単語である．
これらに対してLSI法を用いることにする．
iu, kawaru, kangaeru, kimaru, kuru, kuwaeru, susumu, chigau, nerau, fukumu, matomeru, mamoru, mitomeru, wakaru
実際は選出した14単語のみに対してLSI法を行えば良いが，交差検定の効果も示すために，すべての単語に対してLSI法を試みた．
圧縮する次元数は100に設定した．
ただし行列[MATH]のランク数が100以下の場合は，行列[MATH]のランク数にした．
付録の表[REF_jigen-com2]にlas2の結果をまとめている．
そこではSENSEVAL2の日本語辞書タスクの動詞50単語の各単語に対する行列[MATH]の大きさ，非ゼロ要素の密度，圧縮した次元数，次元圧縮に要したメモリと時間が記されている．
また次元圧縮に要したメモリと時間はlas2の出力ファイルlao2から得ている．
次にSENSEVAL2で配布されたテスト文を用いて正解率を測った結果が表[REF_result1]である．
スコアの算出は解答結果に部分点を与えるmixed-gained scoringという方式[CITE]を用いている．
わずかではあるが，LSI+NN法の方がNN法よりも精度が高かった．
また選択した14単語のうちLSI法を利用することで精度が上がった単語（選択が正しかった単語）は8単語，下がった単語（選択が誤った単語）は6単語である．
逆に選択しなかった36単語のうちNN法の方が精度が良かった単語（選択が正しかった単語）は31単語，LSI法の方が精度が良かった単語（選択が誤った単語）は5単語であった．
つまり，全体の50単語のうち選択が正しかった単語は39単語（78 %），選択が誤った単語は11単語（22 %）である．
単純にすべてNN法を選択した場合，選択が正しくなる単語は37単語（74 %），選択が誤る単語は13単語（26 %）であるため，交差検定の効果が確認できる．
また同様の素性を用いて，決定リスト（DLと略す），Naive Bayes（NBと略す）を用いた判別も行った．
結果を表[REF_result2]に示す．
ほとんどの単語で，決定リストやNaive BayesはNN法やLSI法よりも良い結果を出しているが，一部ではNN法やLSI法の方が良い値を出している．
単語によってはNN法をベースとした方が良い場合もあることを示している．
