近年,大量のコーパスが利用可能になったことを背景に,コーパスから得られた情報を用いて語義の曖昧性を解消する研究が多数行なわれている[CITE].
Yarowskyらは, Rogetのシソーラスカテゴリを利用し,統計手法を用いることでテキスト中に現れる多義語の曖昧性を解消する手法を提案した.
彼らの手法は,統計情報を用いてシソーラスカテゴリに出現する単語に重み付けを行なった後,その結果を利用して多義語の周辺語の重みの和から多義語がどのシソーラスカテゴリに属するかを決定するというものである.
この手法を12の多義語名詞に適用し実験を行なった結果,平均解消率92%という高い正解率が得られることが報告されている[CITE].
しかし, Yarowskyらのシソーラスを用いる問題として,データスパースネスの問題が指摘されている.
すなわち,シソーラスカテゴリに示されている語が抽象的な語で定義されているため,文書の種類によっては,その語が文書に出現しない場合がある[CITE].
また, Yarowskyらは彼らの手法が動詞の多義解消については名詞と同様の正解率が得られないことを指摘している.
丹羽らは,文脈を構成する単語をベクトルで表現し,文脈をそれらベクトルの和で表した.
任意の文脈Aにおける単語の意味は,多義の各意味を表す文脈例を各意味に応じてあらかじめ用意しておき,各々の例と文脈Aにおける単語の意味との類似度(内積)を計算し,その値が最も大きい文脈が示す意味であるとした.
この手法を名詞の多義判定に適用した結果,平均80%の正解率が得られている[CITE].
Brownらは対訳テキストを用い,一方の言語の語義の曖昧性を他方の語の情報を利用することで解消する手法を提案している[CITE].
彼らは実際に英仏機械翻訳システムにこの手法を適用し,検証を行なっている.
しかし彼らは問題点として, (1)多義語の持つ意味を予め高々2つに限定している.
(2)語が,ターゲット言語の2つの異なる訳に翻訳できないとき,語義の解消ができない.
(3)膨大な対訳テキストを必要とする,を挙げている.
ZernikやSchutzeらは,動詞の多義を判定するための情報として名詞と動詞の共起関係を利用している.
任意の動詞がどの意味を持つかは,動詞と共起する名詞の集合に応じて決定される.
しかし,名詞の集合を意味に応じて分割する処理は人手で行なっているため,語の分類は人間の言語的な直観に頼ることになってしまう.
本稿では, Yarowskyらがシソーラスカテゴリを利用しているのに対し,単一言語コーパスから抽出した動詞の語義情報を利用し,文中に含まれる多義語の曖昧性を解消する手法について述べる.
我々の手法は名詞の集合を意味に応じて人手により分割するZernikやSchutzeらの手法,と異なり,多義解消に必要な情報は,与えられた多義語を含む動詞グループに対し,クラスタリングアルゴリズムを適用することで自動的に得られるため,人間の介在を必要としない.
また, Brownらが多義語の持つ意味を予め高々2つに限定しているのに対し,本手法では,多義語を含む動詞グループに対し,クラスタリングアルゴリズムを適用するため, 2つ以上の意味を持つ語に対しても曖昧性の解消が可能である.
一般に,意味的に近い2つの動詞は同じ名詞と共起して現れる.
例えば, Wall Street Journalから抽出した例文(s1)[MATH](s2')において, (s1), (s1')に現れるtakeとbuyは共にstakeと共起して現れ,ほぼ同じ意味を持つ[CITE].
同様に(s2), (s2')に現れる[MATH]take[MATH]と[MATH]spend[MATH]は共に[MATH]time[MATH]と共起して現れ,両者は同じ意味を持つ.
従って多義語[MATH]take[MATH]がもつ複数の意味は,各意味に対応した動詞buy, spendと共起して現れる名詞stake, timeと特徴づけて考えることができる.
すなわち,多義語を含む文において,もし多義語と共起する名詞のうち少なくとも一つが多義語の意味を特徴づける名詞と同じ(あるいは名詞の集合に属する)ならば,文中の多義語の意味はその名詞と共起する動詞の意味に同定することができる.
我々は文中に現れる多義語の曖昧性を,その語と共起する名詞を用いることで解消した.
以下, 3.1節では仮想動詞について述べる.
3.2節では語の意味的な偏差を計算する手法について述べ, 3.3節では3.2節で述べた偏差の値を用いてクラスタリングを行なうためのアルゴリズムについて説明する.
多義語を含む動詞グループに対し,クラスタリングアルゴリズムを適用することで多義語の各意味を示す動詞(仮想動詞)と共起する名詞の集合が,動詞の個数分得られる.
3.4節では仮想動詞,及びそれと共起する名詞との相互情報量を求める手法について述べる.
仮想動詞と名詞の相互情報量は,文中に現れる名詞が複数の(名詞の)集合に含まれる場合にどの集合に含まれるかを一意に決定するために用いられる.
本手法では,多義を判定しながら意味的なクラスタリングを行なうことで多義語の曖昧性解消に必要な情報,すなわち,多義語の意味を特徴づける名詞の集合を抽出する.
そこで,表層上は一つの要素である多義語を,多義が持つ各意味がまとまった複数要素であると捉え,これを一つ一つの意味に対応させた要素(本稿ではこの要素を仮想動詞ベクトルと呼ぶ)に分解した上でクラスタを作成するという手法を用いた.
我々は,動詞をベクトルと捉え,動詞と共起する[MATH]個の名詞を軸とする[MATH]次元名詞空間上でこれを表した.
軸[MATH](1 [MATH] [MATH] [MATH] [MATH])における動詞ベクトルの長さは, [MATH]軸で示される名詞と動詞の相互情報量[CITE]の値を用いた.
仮に2つの動詞に多義性がなく,かつこの2つの動詞が意味的に近いとすると,これらの動詞はこの空間上で互いに距離が近いため,同一のクラスタに含まれることになる.
一方, (s1)と(s2)に現れるtakeは多義であるため,各意味を表す動詞ベクトルbuy, spendのいずれともクラスタを構成しなければならない.
そこで,ベクトルtakeを各軸に従って(この場合, stakeとtimeの2軸)分割することを考える.
ベクトルtakeをstakeとtimeの軸に従って分割した結果を図[REF_cluster1]に示す.
{
}
図[REF_cluster1]において,ベクトルtakeは, stakeとtimeの軸上でベクトルtake1とtake2に分割されている.
take1とtake2を仮想動詞ベクトルと呼ぶ.
図[REF_cluster1]は仮想動詞ベクトルを導入することで,各々意味的に近い要素を持つ2つのクラスタ{take1, buy}, {take2, spend}が得られることを示す.
クラスタリングアルゴリズムは動詞グループの意味的な偏差を比較し,偏差の少ない順にクラスタを生成する.
今[MATH]個から成る動詞グループをVG = {[MATH], [MATH], [MATH]}とすると, VGの偏差[MATH]は式([REF_22])で示される.
ただし, [MATH]は動詞と共起する名詞の個数とする.
([REF_22])の[MATH]  ( =  [MATH] )は, [MATH]軸での重心の値を示す.
また, [MATH] [MATH] [MATH]  ( =  [MATH] )は重心ベクトルの長さを示す.
([REF_22])の[MATH]は,
とする.
ここで, [MATH]は動詞[MATH](1 [MATH] [MATH] [MATH] [MATH])と名詞[MATH](1 [MATH] [MATH] [MATH] [MATH])の相互情報量の値を表し,式([REF_church_mu])で示される.
[MATH], [MATH]は, [MATH], [MATH]の頻度数[MATH], [MATH]をそれぞれコーパスに出現する語の総数[MATH]で正規化したものであり, [MATH]は[MATH]と[MATH]の共起頻度数[MATH]を[MATH]で正規化したものである.
また,式([REF_v])における[MATH]は閾値とする.
式([REF_22])の[MATH] [MATH] [MATH] + [MATH]は,動詞の偏差を示す値が動詞の個数に比例して増加することを防ぐために最小2乗法を用いて行なった正規化である.
式([REF_22])はその値が小さいほどより偏差が少ないことを示す.
クラスタリングアルゴリズムは, non-overlappingとoverlappingアルゴリズムに大別できる.
本手法はoverlappingクラスタリングアルゴリズムに含まれる.
Overlappingアルゴリズムの代表的なものとして[MATH] ([MATH] = 1,2,[MATH])手法がある[CITE].
本手法と[MATH]手法との違いは, [MATH]手法では要素が複数のクラスタに属すか否かは[MATH]の個数に依存して決まるのに対し,我々の手法は,複数のクラスタに属すか否かを判定する条件をアルゴリズムの中に導入している点が異なる.
我々の手法では,動詞ベクトルを分割して仮想動詞ベクトルを作成し, その仮想動詞ベクトルを含むクラスタの偏差を比較することで, 要素が複数のクラスタに属すか否か,すなわち多義であるかどうかの判定を行なっている.
例えば, takeがbuyとspendの意味を持つかどうかを判定するために,ベクトルtakeをstakeとtimeの軸に従い分割し,仮想動詞ベクトルtake1とtake2を作成する.
takeが多義であるか否かは, {take1, buy}, {take2, spend}及び, {take,buy,spend}のクラスタの偏差を比較することにより決定される.
今[MATH]と[MATH]を動詞とし, [MATH], [MATH], [MATH]を動詞,または仮想動詞とする.
また, [MATH] [MATH] [MATH] (1 [MATH] [MATH] [MATH] [MATH] [MATH] [MATH])かつ, [MATH] [MATH] [MATH]とする.
本手法では[MATH]が[MATH]と[MATH]で示される2つの意味を持つか否かを判定するために, ([REF_split])と([REF_lump])で示されるクラスタを作成し,それぞれの偏差を比較する.
ただし, ([REF_lump])の[MATH], [MATH], [MATH], [MATH], [MATH]は[MATH] [MATH] [MATH] (1 [MATH] [MATH] [MATH] [MATH] [MATH] [MATH])を満たすとする.
([REF_split])の[MATH]と[MATH]は[MATH]の仮想動詞を示す.
以下では, (4)で示されるクラスタを作成するために, [MATH], [MATH], [MATH]を入力とし,仮想動詞[MATH]と[MATH]を出力する関数[MATH],及び, (5)で示されるクラスタを作成する過程で仮想動詞[MATH], [MATH]が現れた場合にそれらをマージする関数[MATH]を定義する.
関数[MATH]は入力[MATH], [MATH], [MATH]に対し, [MATH]と[MATH]を出力する.
ただしベクトル[MATH]は, ([MATH], [MATH], [MATH])で示されるとする.
式(8), (9)において[MATH]と共起する[MATH]が, [MATH]と[MATH]の両方と共起する場合には, [MATH]と[MATH]は共に[MATH]  =  [MATH]とした.
また式(9)において[MATH]と共起する[MATH]が, [MATH]と[MATH]のいずれとも共起しない場合には, [MATH]の値は[MATH]の値とした.
これは, [MATH]が[MATH]と[MATH]の両方に含まれない場合, {[MATH], [MATH]}の偏差は常に, {[MATH], [MATH]}よりも小さくなる.
よって, [MATH]と[MATH]の偏差をできるだけ均等にするため, [MATH]の値は, [MATH]の値とした.
関数[MATH]は仮想動詞[MATH]と[MATH]を入力とし[MATH]を出力する.
実験では, ([REF_split])で示される二つのクラスタの偏差の値が共に([REF_lump])で示されるクラスタの偏差の値よりも小さい場合に動詞[MATH]は多義とみなした.
クラスタリングアルゴリズムの流れを図[REF_flow_algo]に示す.
図[REF_flow_algo]の`('はその上で示される関数の処理を示す.
{
}
図[REF_flow_algo]において,関数Make-Initial-Cluster-Setは,動詞グループVGを入力とし, VGの任意の動詞対の組合せに対し,意味的な偏差の値を計算し,任意の動詞対と偏差の値をその値が昇順になるように出力する.
この結果をICS(Initial Cluster Set)と呼ぶ.
CCS(Created Cluster Set)は作成されたクラスタの集合を示す.
関数Make-Temporary-Cluster-Setは[MATH]のどちらか一方の動詞を含むクラスタをCCSから抽出する.
その結果である[MATH]が関数Recognition-of-Polysemyに渡される.
関数Recognition-of-Polysemyは動詞が多義か否かを判定する関数である.
今[MATH]と[MATH]の両方に属する動詞を[MATH]とする.
[MATH]が多義であり[MATH](ただし[MATH]は[MATH]の要素とする)と[MATH] (ただし[MATH]は[MATH]の要素とする)の意味を持つか否かを判定するために, ([REF_split])と([REF_lump])で示されるクラスタが作成される.
具体的には関数([REF_sp])が[MATH], [MATH],と[MATH]に適用され[MATH]と[MATH]が作成される.
もし[MATH]と[MATH]が([REF_lump])で示されるクラスタを作成する過程で存在する場合,関数([REF_lu])が[MATH]と[MATH]に適用され, [MATH]が作成される.
この処理は新しく得られるクラスタ[MATH]がVGと等しくなるか,あるいはICSの要素がなくなるまで適用される.
多義語を含む動詞グループに対し,前節で述べたアルゴリズムを適用することで,多義語の各意味を示す動詞と共起する名詞の集合が動詞の個数分得られる.
{
}
表[REF_app_1]は,多義語takeを含む動詞グループ{take, obtain, spend, buy}に対し,クラスタリングアルゴリズムを適用した結果を示す.
クラスタリングの結果得られるこのテーブルをpvn (polysemous verb noun)テーブルと呼ぶ.
[MATH]は仮想動詞take1, take2, take3を示し,それぞれ, `buy', `spend', `obtain'を示す.
[MATH]は[MATH]以外の意味を示す仮想動詞`residue'を示す.
[MATH]は,仮想動詞[MATH]と共起する名詞を示し, [MATH]は仮想動詞[MATH]と共起する名詞を示す.
[MATH]と[MATH]はそれぞれ[MATH], [MATH]の頻度を示し, [MATH]と[MATH]はそれぞれ`take'と[MATH], `take'と[MATH]の共起頻度数を示す.
文中に現れる動詞の多義解消は基本的に名詞[MATH]及び[MATH]を用いて行なわれる.
すなわち,文中に現れる動詞と共起する名詞が表[REF_app_1]に示されているとき,文中の動詞は,その名詞と共起する仮想動詞の意味となる.
例えば, (s3)において, stakeは表[REF_app_1]に示されている.
従って(s3)のtakenの意味は, take1が示す意味である`buy'と判定される.
名詞の中には,例えば表[REF_app_1]の`lot'のように複数の集合に属する名詞が存在する.
この場合は,各仮想動詞と`lot'との相互情報量の中で大きい値を持つ仮想動詞の意味とした.
ただし,表[REF_app_1]の[MATH]及び[MATH]は, `take'と各名詞との相互情報量を示す.
そこで,仮想動詞[MATH]及び[MATH]と各名詞との相互情報量[MATH]及び[MATH]を以下のようにして求めた.
[MATH]  (1 [MATH] [MATH] [MATH] [MATH])を仮想動詞とし, [MATH]を[MATH]における各仮想動詞以外の意味を示す仮想動詞とする.
[MATH] [MATH]を[MATH]と共起する名詞の個数とし, [MATH] [MATH]を[MATH]と共起する[MATH]軸の名詞とする.
[MATH]の頻度[MATH]と[MATH]の頻度[MATH]は以下の式で示される.
式([REF_re_cal])と([REF_church_mu]),及び([REF_re_cal_oh])と([REF_church_mu])を用いて, [MATH]と[MATH]を求める.
表[REF_app_1]の[MATH]と[MATH]はそれぞれ仮想動詞[MATH]と名詞[MATH],仮想動詞[MATH]と名詞[MATH]との相互情報量を示す.
文中の多義語[MATH]の意味は, [MATH]のpvnテーブルを用いて以下のように決定される.
[MATH]の後方5語以内に出現する名詞を[MATH]とすると, [MATH]がpvnテーブルに存在する場合:
[MATH]が一つのみ存在する場合, [MATH]の意味は, [MATH]と共起する仮想動詞の意味とする.
[MATH]が二つ以上存在する場合, [MATH]の意味は, [MATH]と共起する仮想動詞のうち, [MATH]との相互情報量の値が最も高い仮想動詞の意味とする.
[MATH]がpvnテーブルに存在しない場合, [MATH]の値が最大になるような仮想動詞[MATH]を求める.
[MATH]の意味は, [MATH]の意味とする.
[MATH]は, [MATH]と[MATH]の意味的な関係を示す式であり,以下のように定義した.
式([REF_co])において, [MATH]は[MATH]と共起する名詞の集合を示す.
[MATH]は, [MATH]とpvnテーブルに登録されている名詞[MATH]との偏差を示す.
すなわち,式([REF_22])において[MATH]を2とし, [MATH]と[MATH]をそれぞれ, [MATH], [MATH]とする.
さらに式([REF_22])中の動詞と共起する名詞の個数を名詞[MATH]及び[MATH]と共起する動詞の個数に置き換えることにより[MATH]が得られる.
近年,大量のコーパスが利用可能になったことを背景に,コーパスから得られた情報を用いて語義の曖昧性を解消する研究が多数行なわれている[CITE].
Yarowskyらは, Rogetのシソーラスカテゴリを利用し,統計手法を用いることでテキスト中に現れる多義語の曖昧性を解消する手法を提案した.
彼らの手法は,統計情報を用いてシソーラスカテゴリに出現する単語に重み付けを行なった後,その結果を利用して多義語の周辺語の重みの和から多義語がどのシソーラスカテゴリに属するかを決定するというものである.
この手法を12の多義語名詞に適用し実験を行なった結果,平均解消率92%という高い正解率が得られることが報告されている[CITE].
しかし, Yarowskyらのシソーラスを用いる問題として,データスパースネスの問題が指摘されている.
すなわち,シソーラスカテゴリに示されている語が抽象的な語で定義されているため,文書の種類によっては,その語が文書に出現しない場合がある[CITE].
また, Yarowskyらは彼らの手法が動詞の多義解消については名詞と同様の正解率が得られないことを指摘している.
丹羽らは,文脈を構成する単語をベクトルで表現し,文脈をそれらベクトルの和で表した.
任意の文脈Aにおける単語の意味は,多義の各意味を表す文脈例を各意味に応じてあらかじめ用意しておき,各々の例と文脈Aにおける単語の意味との類似度(内積)を計算し,その値が最も大きい文脈が示す意味であるとした.
この手法を名詞の多義判定に適用した結果,平均80%の正解率が得られている[CITE].
Brownらは対訳テキストを用い,一方の言語の語義の曖昧性を他方の語の情報を利用することで解消する手法を提案している[CITE].
彼らは実際に英仏機械翻訳システムにこの手法を適用し,検証を行なっている.
しかし彼らは問題点として, (1)多義語の持つ意味を予め高々2つに限定している.
(2)語が,ターゲット言語の2つの異なる訳に翻訳できないとき,語義の解消ができない.
(3)膨大な対訳テキストを必要とする,を挙げている.
ZernikやSchutzeらは,動詞の多義を判定するための情報として名詞と動詞の共起関係を利用している.
任意の動詞がどの意味を持つかは,動詞と共起する名詞の集合に応じて決定される.
しかし,名詞の集合を意味に応じて分割する処理は人手で行なっているため,語の分類は人間の言語的な直観に頼ることになってしまう.
本稿では, Yarowskyらがシソーラスカテゴリを利用しているのに対し,単一言語コーパスから抽出した動詞の語義情報を利用し,文中に含まれる多義語の曖昧性を解消する手法について述べる.
我々の手法は名詞の集合を意味に応じて人手により分割するZernikやSchutzeらの手法,と異なり,多義解消に必要な情報は,与えられた多義語を含む動詞グループに対し,クラスタリングアルゴリズムを適用することで自動的に得られるため,人間の介在を必要としない.
また, Brownらが多義語の持つ意味を予め高々2つに限定しているのに対し,本手法では,多義語を含む動詞グループに対し,クラスタリングアルゴリズムを適用するため, 2つ以上の意味を持つ語に対しても曖昧性の解消が可能である.
一般に,意味的に近い2つの動詞は同じ名詞と共起して現れる.
例えば, Wall Street Journalから抽出した例文(s1)[MATH](s2')において, (s1), (s1')に現れるtakeとbuyは共にstakeと共起して現れ,ほぼ同じ意味を持つ[CITE].
同様に(s2), (s2')に現れる[MATH]take[MATH]と[MATH]spend[MATH]は共に[MATH]time[MATH]と共起して現れ,両者は同じ意味を持つ.
従って多義語[MATH]take[MATH]がもつ複数の意味は,各意味に対応した動詞buy, spendと共起して現れる名詞stake, timeと特徴づけて考えることができる.
すなわち,多義語を含む文において,もし多義語と共起する名詞のうち少なくとも一つが多義語の意味を特徴づける名詞と同じ(あるいは名詞の集合に属する)ならば,文中の多義語の意味はその名詞と共起する動詞の意味に同定することができる.
我々は文中に現れる多義語の曖昧性を,その語と共起する名詞を用いることで解消した.
以下, 3.1節では仮想動詞について述べる.
3.2節では語の意味的な偏差を計算する手法について述べ, 3.3節では3.2節で述べた偏差の値を用いてクラスタリングを行なうためのアルゴリズムについて説明する.
多義語を含む動詞グループに対し,クラスタリングアルゴリズムを適用することで多義語の各意味を示す動詞(仮想動詞)と共起する名詞の集合が,動詞の個数分得られる.
3.4節では仮想動詞,及びそれと共起する名詞との相互情報量を求める手法について述べる.
仮想動詞と名詞の相互情報量は,文中に現れる名詞が複数の(名詞の)集合に含まれる場合にどの集合に含まれるかを一意に決定するために用いられる.
本手法では,多義を判定しながら意味的なクラスタリングを行なうことで多義語の曖昧性解消に必要な情報,すなわち,多義語の意味を特徴づける名詞の集合を抽出する.
そこで,表層上は一つの要素である多義語を,多義が持つ各意味がまとまった複数要素であると捉え,これを一つ一つの意味に対応させた要素(本稿ではこの要素を仮想動詞ベクトルと呼ぶ)に分解した上でクラスタを作成するという手法を用いた.
我々は,動詞をベクトルと捉え,動詞と共起する[MATH]個の名詞を軸とする[MATH]次元名詞空間上でこれを表した.
軸[MATH](1 [MATH] [MATH] [MATH] [MATH])における動詞ベクトルの長さは, [MATH]軸で示される名詞と動詞の相互情報量[CITE]の値を用いた.
仮に2つの動詞に多義性がなく,かつこの2つの動詞が意味的に近いとすると,これらの動詞はこの空間上で互いに距離が近いため,同一のクラスタに含まれることになる.
一方, (s1)と(s2)に現れるtakeは多義であるため,各意味を表す動詞ベクトルbuy, spendのいずれともクラスタを構成しなければならない.
そこで,ベクトルtakeを各軸に従って(この場合, stakeとtimeの2軸)分割することを考える.
ベクトルtakeをstakeとtimeの軸に従って分割した結果を図[REF_cluster1]に示す.
{
}
図[REF_cluster1]において,ベクトルtakeは, stakeとtimeの軸上でベクトルtake1とtake2に分割されている.
take1とtake2を仮想動詞ベクトルと呼ぶ.
図[REF_cluster1]は仮想動詞ベクトルを導入することで,各々意味的に近い要素を持つ2つのクラスタ{take1, buy}, {take2, spend}が得られることを示す.
クラスタリングアルゴリズムは動詞グループの意味的な偏差を比較し,偏差の少ない順にクラスタを生成する.
今[MATH]個から成る動詞グループをVG = {[MATH], [MATH], [MATH]}とすると, VGの偏差[MATH]は式([REF_22])で示される.
ただし, [MATH]は動詞と共起する名詞の個数とする.
([REF_22])の[MATH]  ( =  [MATH] )は, [MATH]軸での重心の値を示す.
また, [MATH] [MATH] [MATH]  ( =  [MATH] )は重心ベクトルの長さを示す.
([REF_22])の[MATH]は,
とする.
ここで, [MATH]は動詞[MATH](1 [MATH] [MATH] [MATH] [MATH])と名詞[MATH](1 [MATH] [MATH] [MATH] [MATH])の相互情報量の値を表し,式([REF_church_mu])で示される.
[MATH], [MATH]は, [MATH], [MATH]の頻度数[MATH], [MATH]をそれぞれコーパスに出現する語の総数[MATH]で正規化したものであり, [MATH]は[MATH]と[MATH]の共起頻度数[MATH]を[MATH]で正規化したものである.
また,式([REF_v])における[MATH]は閾値とする.
式([REF_22])の[MATH] [MATH] [MATH] + [MATH]は,動詞の偏差を示す値が動詞の個数に比例して増加することを防ぐために最小2乗法を用いて行なった正規化である.
式([REF_22])はその値が小さいほどより偏差が少ないことを示す.
クラスタリングアルゴリズムは, non-overlappingとoverlappingアルゴリズムに大別できる.
本手法はoverlappingクラスタリングアルゴリズムに含まれる.
Overlappingアルゴリズムの代表的なものとして[MATH] ([MATH] = 1,2,[MATH])手法がある[CITE].
本手法と[MATH]手法との違いは, [MATH]手法では要素が複数のクラスタに属すか否かは[MATH]の個数に依存して決まるのに対し,我々の手法は,複数のクラスタに属すか否かを判定する条件をアルゴリズムの中に導入している点が異なる.
我々の手法では,動詞ベクトルを分割して仮想動詞ベクトルを作成し, その仮想動詞ベクトルを含むクラスタの偏差を比較することで, 要素が複数のクラスタに属すか否か,すなわち多義であるかどうかの判定を行なっている.
例えば, takeがbuyとspendの意味を持つかどうかを判定するために,ベクトルtakeをstakeとtimeの軸に従い分割し,仮想動詞ベクトルtake1とtake2を作成する.
takeが多義であるか否かは, {take1, buy}, {take2, spend}及び, {take,buy,spend}のクラスタの偏差を比較することにより決定される.
今[MATH]と[MATH]を動詞とし, [MATH], [MATH], [MATH]を動詞,または仮想動詞とする.
また, [MATH] [MATH] [MATH] (1 [MATH] [MATH] [MATH] [MATH] [MATH] [MATH])かつ, [MATH] [MATH] [MATH]とする.
本手法では[MATH]が[MATH]と[MATH]で示される2つの意味を持つか否かを判定するために, ([REF_split])と([REF_lump])で示されるクラスタを作成し,それぞれの偏差を比較する.
ただし, ([REF_lump])の[MATH], [MATH], [MATH], [MATH], [MATH]は[MATH] [MATH] [MATH] (1 [MATH] [MATH] [MATH] [MATH] [MATH] [MATH])を満たすとする.
([REF_split])の[MATH]と[MATH]は[MATH]の仮想動詞を示す.
以下では, (4)で示されるクラスタを作成するために, [MATH], [MATH], [MATH]を入力とし,仮想動詞[MATH]と[MATH]を出力する関数[MATH],及び, (5)で示されるクラスタを作成する過程で仮想動詞[MATH], [MATH]が現れた場合にそれらをマージする関数[MATH]を定義する.
関数[MATH]は入力[MATH], [MATH], [MATH]に対し, [MATH]と[MATH]を出力する.
ただしベクトル[MATH]は, ([MATH], [MATH], [MATH])で示されるとする.
式(8), (9)において[MATH]と共起する[MATH]が, [MATH]と[MATH]の両方と共起する場合には, [MATH]と[MATH]は共に[MATH]  =  [MATH]とした.
また式(9)において[MATH]と共起する[MATH]が, [MATH]と[MATH]のいずれとも共起しない場合には, [MATH]の値は[MATH]の値とした.
これは, [MATH]が[MATH]と[MATH]の両方に含まれない場合, {[MATH], [MATH]}の偏差は常に, {[MATH], [MATH]}よりも小さくなる.
よって, [MATH]と[MATH]の偏差をできるだけ均等にするため, [MATH]の値は, [MATH]の値とした.
関数[MATH]は仮想動詞[MATH]と[MATH]を入力とし[MATH]を出力する.
実験では, ([REF_split])で示される二つのクラスタの偏差の値が共に([REF_lump])で示されるクラスタの偏差の値よりも小さい場合に動詞[MATH]は多義とみなした.
クラスタリングアルゴリズムの流れを図[REF_flow_algo]に示す.
図[REF_flow_algo]の`('はその上で示される関数の処理を示す.
{
}
図[REF_flow_algo]において,関数Make-Initial-Cluster-Setは,動詞グループVGを入力とし, VGの任意の動詞対の組合せに対し,意味的な偏差の値を計算し,任意の動詞対と偏差の値をその値が昇順になるように出力する.
この結果をICS(Initial Cluster Set)と呼ぶ.
CCS(Created Cluster Set)は作成されたクラスタの集合を示す.
関数Make-Temporary-Cluster-Setは[MATH]のどちらか一方の動詞を含むクラスタをCCSから抽出する.
その結果である[MATH]が関数Recognition-of-Polysemyに渡される.
関数Recognition-of-Polysemyは動詞が多義か否かを判定する関数である.
今[MATH]と[MATH]の両方に属する動詞を[MATH]とする.
[MATH]が多義であり[MATH](ただし[MATH]は[MATH]の要素とする)と[MATH] (ただし[MATH]は[MATH]の要素とする)の意味を持つか否かを判定するために, ([REF_split])と([REF_lump])で示されるクラスタが作成される.
具体的には関数([REF_sp])が[MATH], [MATH],と[MATH]に適用され[MATH]と[MATH]が作成される.
もし[MATH]と[MATH]が([REF_lump])で示されるクラスタを作成する過程で存在する場合,関数([REF_lu])が[MATH]と[MATH]に適用され, [MATH]が作成される.
この処理は新しく得られるクラスタ[MATH]がVGと等しくなるか,あるいはICSの要素がなくなるまで適用される.
多義語を含む動詞グループに対し,前節で述べたアルゴリズムを適用することで,多義語の各意味を示す動詞と共起する名詞の集合が動詞の個数分得られる.
{
}
表[REF_app_1]は,多義語takeを含む動詞グループ{take, obtain, spend, buy}に対し,クラスタリングアルゴリズムを適用した結果を示す.
クラスタリングの結果得られるこのテーブルをpvn (polysemous verb noun)テーブルと呼ぶ.
[MATH]は仮想動詞take1, take2, take3を示し,それぞれ, `buy', `spend', `obtain'を示す.
[MATH]は[MATH]以外の意味を示す仮想動詞`residue'を示す.
[MATH]は,仮想動詞[MATH]と共起する名詞を示し, [MATH]は仮想動詞[MATH]と共起する名詞を示す.
[MATH]と[MATH]はそれぞれ[MATH], [MATH]の頻度を示し, [MATH]と[MATH]はそれぞれ`take'と[MATH], `take'と[MATH]の共起頻度数を示す.
文中に現れる動詞の多義解消は基本的に名詞[MATH]及び[MATH]を用いて行なわれる.
すなわち,文中に現れる動詞と共起する名詞が表[REF_app_1]に示されているとき,文中の動詞は,その名詞と共起する仮想動詞の意味となる.
例えば, (s3)において, stakeは表[REF_app_1]に示されている.
従って(s3)のtakenの意味は, take1が示す意味である`buy'と判定される.
名詞の中には,例えば表[REF_app_1]の`lot'のように複数の集合に属する名詞が存在する.
この場合は,各仮想動詞と`lot'との相互情報量の中で大きい値を持つ仮想動詞の意味とした.
ただし,表[REF_app_1]の[MATH]及び[MATH]は, `take'と各名詞との相互情報量を示す.
そこで,仮想動詞[MATH]及び[MATH]と各名詞との相互情報量[MATH]及び[MATH]を以下のようにして求めた.
[MATH]  (1 [MATH] [MATH] [MATH] [MATH])を仮想動詞とし, [MATH]を[MATH]における各仮想動詞以外の意味を示す仮想動詞とする.
[MATH] [MATH]を[MATH]と共起する名詞の個数とし, [MATH] [MATH]を[MATH]と共起する[MATH]軸の名詞とする.
[MATH]の頻度[MATH]と[MATH]の頻度[MATH]は以下の式で示される.
式([REF_re_cal])と([REF_church_mu]),及び([REF_re_cal_oh])と([REF_church_mu])を用いて, [MATH]と[MATH]を求める.
表[REF_app_1]の[MATH]と[MATH]はそれぞれ仮想動詞[MATH]と名詞[MATH],仮想動詞[MATH]と名詞[MATH]との相互情報量を示す.
文中の多義語[MATH]の意味は, [MATH]のpvnテーブルを用いて以下のように決定される.
[MATH]の後方5語以内に出現する名詞を[MATH]とすると, [MATH]がpvnテーブルに存在する場合:
[MATH]が一つのみ存在する場合, [MATH]の意味は, [MATH]と共起する仮想動詞の意味とする.
[MATH]が二つ以上存在する場合, [MATH]の意味は, [MATH]と共起する仮想動詞のうち, [MATH]との相互情報量の値が最も高い仮想動詞の意味とする.
[MATH]がpvnテーブルに存在しない場合, [MATH]の値が最大になるような仮想動詞[MATH]を求める.
[MATH]の意味は, [MATH]の意味とする.
[MATH]は, [MATH]と[MATH]の意味的な関係を示す式であり,以下のように定義した.
式([REF_co])において, [MATH]は[MATH]と共起する名詞の集合を示す.
[MATH]は, [MATH]とpvnテーブルに登録されている名詞[MATH]との偏差を示す.
すなわち,式([REF_22])において[MATH]を2とし, [MATH]と[MATH]をそれぞれ, [MATH], [MATH]とする.
さらに式([REF_22])中の動詞と共起する名詞の個数を名詞[MATH]及び[MATH]と共起する動詞の個数に置き換えることにより[MATH]が得られる.
