話し言葉を表現できる汎用的なデータベーススキーマの設計
\label{sec:DB}

本節では，
マルチチャネル・マルチモーダルの話し言葉コーパスを表現できる
汎用的なデータベーススキーマを提案する．
本スキーマは，基本的には，
    \citeA{Noguchi_2008_MPA}と\citeA{Kaplan_2010_APM}が提案した
セグメントとリンクに基づくスキーマに依拠している．
しかし，彼らのスキーマは書き言葉を想定しており，
話し言葉に適用するためにはいくつかの拡張が必要である．
以下，拡張・改良点について順に述べ，我々のスキーマを提案する．

\begin{figure}[t]
\begin{center}
\includegraphics{21-2iaCA1f2.eps}
\end{center}
\caption{セグメントとリンクに基づくスキーマ
（\protect\cite{Kaplan_2010_APM}のFigure 3を改変）}
\label{fig:SLAT}
\end{figure}


\subsection{セグメントとリンクに基づくスキーマ}

セグメントとリンクに基づくスキーマでは以下の2種類のオブジェクトを用いる．

\begin{description}
 \item[セグメント (Segment)]
文書中の特定の開始位置 (start)
と終了位置 (end)
で指定される区間に存在する，特定の型 (type)
の要素．
単語・句・節など．
 \item[リンク (Link)]
参照元セグメント (source)
と参照先セグメント (destination)
の間に設定される，特定の型 (type)
の依存関係．
係り受け関係・照応関係など．
\end{description}

いずれのオブジェクトも型ごとに定まった属性 (name) 
と値 (value) 
の対の集合を持つ．
たとえば，単語型セグメントは品詞・活用型・活用形などの属性を持ちうるし，
係り受け関係型リンクは係り受けの種類（従属と並列の区別）などの属性を
持ちうる．
これらの属性値が付随したセグメントとリンクの集合によって文書を表現する．
セグメントとリンクに基づくスキーマのクラス図を
図\ref{fig:SLAT}に示す\footnote{
 DocumentとTagをつなぐ線は
1つの文書が0個以上のタグの集合からなることを示し，
SegmentやLinkとTagをつなぐ線は
セグメントやリンクがタグの一種であることを示す．
また，矢印は，
リンクが2つのセグメント（sourceとdestination）に依存することや，
各属性・値対がrefで示されたセグメントやリンクに付随することを表す．
}．


\subsection{話し言葉への拡張}
\label{sec:DB:spoken}

セグメントとリンクに基づくスキーマは
もともと書き言葉を想定して作られており，
話し言葉に適用するためにはいくつかの拡張が必要である．


\paragraph{開始・終了位置：}
開始・終了位置としては文書中での文字位置
（文書の先頭から数えて何文字目か）が想定されている．
しかし，話し言葉で対象となる要素（アクセント・音調や視線・頷きなど）は
必ずしもテキスト情報に基づいていない．
そこで，開始・終了位置として文書（音声・映像ファイル）中での
時刻（文書の先頭からの経過時間）を用いる．

\paragraph{単位の融合：}
話し言葉ではしばしば隣接する単位間での融合が生じる．
たとえば，「私は」が融合して「ワタシャ」のように発音されたりする．
\pagebreak
この場合，「私」と「は」の境界は実際の音声中には存在しないので，
個々の単語を時刻に依拠したセグメントとしては表せない．
そこで，セグメントとしては融合した「わたしゃ」全体を一つの単位とし，
個々の形態論情報を担う単位を「時間的に整列されない
セグメント」（非整列セグメント）として別途表現する
（図\ref{fig:subseg}）{\kern-0.5zw}\footnote{
 別の表現方法として，融合された境界に対して
（隣接時刻間に存在する）架空の時刻（たとえば
図\ref{fig:subseg}では1.2など）を設定し，
何らかのフラグによってそれが架空の時刻であることを表現する
という方法が考えられる．
この方法を取れば，非整列セグメントを導入する必要はない．
しかし，話し言葉コーパスの分析では，
単位の継続長や発話速度を算出する機会が多く，その都度，
架空の時刻をスキップするといった処理を行なうのはかえって非効率的である．
}．
これらのセグメントと非整列セグメントの間の依存関係は
後述する階層関係を用いて表現し，
各非整列セグメントが「何個の非整列セグメントからなる
（長さlenの）セグメント中の何番目の要素であるか (nth)」
という情報を与える（図\ref{fig:subseg}ではnth/lenで表記）．

\begin{figure}[t]
\begin{center}
\includegraphics{21-2iaCA1f3.eps}
\end{center}
\caption{非整列セグメントの例}
\label{fig:subseg}
\end{figure}

\paragraph{マルチチャネルへの対応：}

書き言葉の文書は通常，単一のストリームからなる．
しかし，話し言葉の対話データでは，
複数話者によるマルチチャネルのストリームに対応しなければならない．
これはチャネルごとに時刻を相対化することで解決できる．
そのために，
セグメントの表現にチャネル識別子（話者ラベルなど）を追加する．


\paragraph{マルチモーダルへの対応：}

書き言葉の文書にはテキストという単一のモダリティしかない．
しかし，話し言葉のマルチモーダルデータでは，
音声言語に加えて，視線・頷きやジェスチャーなどのモダリティに
対応しなければならない．
セグメントとリンクに基づくスキーマはスタンドオフ形式\footnote{
 文書中の要素間の入れ子構造によって階層関係を表すのではなく，
外部文書中で各要素が占める区間を開始・終了位置で示すことにより，
さまざまな要素間の関係を表す形式．}のため，
このような単一の根ノードにまとまらない単位階層にも自然に対応できる．

一方で，区間の包含関係で階層関係を表すスタンドオフ形式では，
不適切な階層関係が認定されることがある．
たとえば，「うん，そうだね」という発話が頷きを伴ってなされた場合，
「うん」という単語はこの発話の適切な下位単位であるが，
頷きは発話の適切な下位単位とは言えない．
どの型のセグメント間に階層関係が設定されるかは，
各セグメント型の認識論的な位置づけによって
アプリオリに定まっているべきである．
そこで，本スキーマでは，セグメント間の階層関係を明示的に表現する．
これは，下位セグメントを参照元，上位セグメントを参照先とした
特別な型のリンクととらえることができる．


\subsection{スキーマの具体化}
\label{sec:DB:practical}

セグメントとリンクに基づくスキーマは，
さまざまな属性集合を持ちうるさまざまな型のセグメントやリンクを扱うために，
極めて抽象度の高いスキーマになっている
（セグメントとリンクという2種類のオブジェクトしかない）．
\citeA{Noguchi_2008_MPA}や\citeA{Kaplan_2010_APM}は，
「述語」や「項」といったより具体性の高いオブジェクトを操作できる
アノテーションツールやコーパス検索ツールをインターフェースとして
提供することで，ユーザの利便性を図っている．
しかし，既存のアノテーションツールやコーパス検索ツールを用いて
コーパス利用環境を実現しようという本研究においては，
このような利便を図ることはできず，
スキーマ中のオブジェクトがそのままユーザが操作する対象となる．
そこでは，語やアクセント句や節といったオブジェクトが
そのまま操作できたほうがユーザの了解度は高いと思われる．

そこで，（非整列）セグメントや（階層関係を含む）リンクを
型ごとに別々のオブジェクトとして表現し，
属性は各オブジェクトに直接表現する．
属性集合は型ごとに定まるため，型ごとにオブジェクトを別にすれば，
このような表現が可能となる．

また，階層関係については，
「何個の下位セグメントからなる
（長さlenの）上位セグメント中の何番目の要素であるか (nth)」
という情報を付与する．
この情報は時刻の情報から導出できるため，表現としては冗長である．
しかし，話し言葉では，隣接するセグメント間で
先行要素の終了位置と後続要素の開始位置が一致するという
制約が必ずしも成り立たない（間に休止が介在しうる）ため，
SQL言語を用いると，たとえば隣接語対を抽出するのに
煩雑な検索を行なわなければならない．
上述の情報があれば，この検索は簡単に行なえる
（付録\ref{sec:bigram}参照）．


\subsection{提案するデータベーススキーマ}

\begin{figure}[b]
\begin{center}
\includegraphics{21-2iaCA1f4.eps}
\end{center}
\caption{本研究で提案するスキーマ}
\label{fig:model}
\end{figure}

\ref{sec:DB:spoken}と\ref{sec:DB:practical}の議論を踏まえ，
図\ref{fig:model}のスキーマを設計した．
\pagebreak
本スキーマでは以下の4種類のオブジェクトを用いる\footnote{
 実際には，これら以外に，
(1) トーン情報など，区間幅を持たない要素に対するオブジェクト
($\RM{point}\IT{Type}_i$)，
(2) あいづち表現など，あるセグメントの一部のインスタンスに対して
追加的に与えられた属性を表現するオブジェクト
($\RM{add}\IT{Type}_i$)，
(3) 話者情報などのメタ情報を記述するオブジェクト
($\RM{info}\IT{Type}_i$)
の3種類のオブジェクトがある．
}．

\begin{description}
 \item[セグメント ($\RM{seg}\IT{Type}_i$)]
文書中の特定のチャネル (channel) 上の
特定の開始位置 (start) と終了位置 (end) で指定される区間に存在する要素．
型 ($\IT{Type}_i$) ごとに別のオブジェクトとして表現され，それぞれ
特定の属性集合
 ($\RM{attr}_1$, \ldots, $\RM{attr}_{n_i}$) を持つ．
 \item[非整列セグメント ($\RM{useg}\IT{Type}_i$)]
時間的に分節化されない，セグメントの下位要素．
型 ($\IT{Type}_i$)ごとに別のオブジェクトとして表現され，
特定の属性集合
 ($\RM{attr}_1$, \ldots, $\RM{attr}_{n_i}$) を持つ．
 \item[リンク ($\RM{link}\IT{Type}_i$)]
参照元セグメント (source) と参照先セグメント (destination) の間に
設定される依存関係．
型 ($\IT{Type}_i$) ごとに別のオブジェクトとして表現され，それぞれ
特定の属性集合
 ($\RM{attr}_1$, \ldots, $\RM{attr}_{n_i}$) を持つ．
 \item[階層関係
 ($\RM{rel}\IT{Type}_i\RM{2}\IT{Type}_j$)]
下位セグメント (descendant) と
上位セグメント (ancestor) の間に設定される階層関係．
上位・下位セグメントの型の組み合わせ
 ($\IT{Type}_j$と$\IT{Type}_i$) ごとに
別のオブジェクトとして表現され，
同一の上位セグメントに帰属する下位セグメントの総数 (len) と
それらのうち何番目の要素であるか (nth) を属性として持つ．
\end{description}

オブジェクトの種類としては限られているが，
型ごとに別々のオブジェクトとして表現されるため，
実際のオブジェクトの数はしばしば十数個にもなる．

元のセグメントとリンクに基づくスキーマ（図\ref{fig:SLAT}）と比べると，
以下の違いがある．
\begin{enumerate}
 \item 非整列セグメントが導入された．
 \item 階層関係が陽に表現された．
 \item （非整列）セグメントやリンクが
型ごとに別々のオブジェクトとして表現され，属性を内包するようになった．
\end{enumerate}


データベース構築ツールの開発
\label{sec:Tools}

本節では，既存のアノテーションツールで作成された
種々の書式を持つアノテーションから，
\ref{sec:DB}節で提案したスキーマに基づくデータベースを
自動的に構築するツールについて述べる．


\subsection{ツールの概要}

本ツールは現在のところ，
CSVベースのツール，
Praat \cite{Boersma_2013_PDP}，
ELAN \cite{Brugman_2004_AMM}，
Anvil \cite{Kipp_2001_AGA}の4種類のアノテーションツールに対応している．
これらのアノテーションファイルから提案スキーマに基づくデータベースを
生成することが本ツールの目的である．
構築するデータベースは可搬性に優れたSQLiteを採用した．
SQLiteは，すべてのテーブルやインデックスを単一のファイルで実装する
スタンドアローンの関係データベースであり，
『茶器』\cite{Matsumoto_2006_ACM}などのコーパス管理環境でも
利用されている．

4種類のアノテーションの書式は大きく異なるが，
ある一定の規約を設けることにより，
データベースに直接インポートできる表形式ファイルに容易に変換できる．
この規約に従ったアノテーションを「正規形」と呼ぶ．
ELANやAnvilは本研究と類似のスキーマを用いており，
はじめからこの規約に従っている．
一方，CSVやPraatでは前もって正規形に変換する必要がある．
したがって，データベースの構築過程は以下のようになる．

\begin{center}
（アノテーションファイル$\Rightarrow$）
正規形ファイル$\Rightarrow$
表形式ファイル$\Rightarrow$
データベース
\end{center}


\subsection{利用できるアノテーションツール}

本ツールでは以下の4種類のアノテーションツールを利用できる．

\paragraph{CSVベースのツール：}
形態論情報や談話行為など，テキスト情報に基づくアノテーションには，
コンマで区切られたCSV形式の入出力を持つツールを用いることが多い．
たとえば，Microsoft Excelは人文系・理工系を問わず，
広く用いられているCSVベースのツールであり，
形態素解析システムなどの言語処理ツールの出力もCSV形式にできるものが多い．

\paragraph{Praat：}
Praatは高機能な音声アノテーションツールであり，
話し言葉の音声学的アノテーションで標準的なツールとなっている．
分節音・単語境界や韻律情報のアノテーションで広く利用されている．
出力書式は独自のものであるが，基本的にスタンドオフ形式である．


\paragraph{ELAN：}
ELANは高機能な映像アノテーションツールであり，
ジェスチャー研究などで広く利用されている．
本研究と類似のスキーマを用いており，
出力書式はスタンドオフ形式のXMLである．

\paragraph{Anvil：}
Anvilも映像アノテーションツールである．
ELANにはないリンクアノテーションの機能があり，
発話間の関係づけやあいづち表現の反応先などのアノテーションで利用できる．
Anvilの出力書式もスタンドオフ形式のXMLである．



\subsection{正規形ファイル}
\label{sec:Tools:normal}

以上のアノテーションからデータベースを構築するためには，
スキーマを具現化する上で必須の情報が
アノテーションファイルから取得できないといけない．
これらは，セグメントでは開始・終了位置であり，
リンクでは参照元・参照先セグメント（を一意に同定する情報）である．
これらの情報の取得を保証するアノテーションを「正規形」と呼ぶ．
以下，アノテーションファイルの書式ごとに順に述べる．

\paragraph{CSV：}

CSV形式の正規形ファイルの例として，
形態論情報アノテーションの例を図\ref{fig:CSV}に示す．
CSV形式の正規形では，各行に開始・終了時刻が記されているものとする．
たとえば，形態論情報アノテーションでは，
Praatなどを用いて別途ラベリングした単語境界の情報から
単語ごとの開始・終了時刻が転写されているものとする．
ただし，\ref{sec:DB:spoken}で述べた単位の融合などにより
時刻を定められない箇所は「不定」（``NA''で示す）としてよい\footnote{
 したがって，発話ごとにしか時間情報が与えられていないコーパスの場合は，
発話の先頭の単語の開始時刻と末尾の単語の終了時刻以外は
すべて「不定」となる．}．
「不定」でない開始・終了時刻を持つ最小の範囲
（図\ref{fig:CSV}の冒頭の例では「第一」）がセグメントとして認定され，
各行はその下位に位置する非整列セグメントとして認定される．

\begin{figure}[t]
\begin{center}
\includegraphics{21-2iaCA1f5.eps}
\end{center}
\caption{CSV形式の正規形ファイルの例}
\label{fig:CSV}
\end{figure}

1つのCSVファイルで複数の単位をアノテーションする場合がしばしばある．
たとえば，図\ref{fig:CSV}では，
短単位 (SUW) と長単位 (LUW) という複数の粒度で語が認定されている
（「第一母音」は長単位では1つの語であり，短単位では「第」「一」「母音」
という3つの語である）．
このような場合には，IOB2ラベル\cite{TjongKimSang_1999_RTC}によって上位単位の区間を示す
（図\ref{fig:CSV}のluwLabel列）{\kern-0.5zw}\footnote{
 `B'は上位単位の開始位置を示し，
`I'は開始された上位単位の内部（末尾を含む）にあることを示す．
また，`O'は「笑い」など上位単位に含まれない要素であることを示す．
}．

CSV形式でリンクを表すには，ローカルに定義されたid
（文内での文節の通し番号など）を用いて参照元と参照先を示す．
たとえば，係り受け解析器CaboCha \cite{Kudo_2002_JDA}の出力は
このような情報を含んでいる．
データベース構築ツールは
これらのidをデータベース内で利用するグローバルなidに自動的に変換する．

\paragraph{Praat：}

Praatの正規形ファイルの例として，
韻律情報アノテーションの例を図\ref{fig:Praat}に示す．
Praatは多層アノテーションツールであり，
複数階層のセグメントを同時に表すことができる．
図\ref{fig:Praat}では上段の3層，
単語 (Word)・アクセント句 (AP)・イントネーション句 (IP) が
それらに対応する．
韻律情報のアノテーションスキーマとして広く用いられている
    X--JToBI \cite{五十嵐_2006_韻律情}では，
アクセント句やイントネーション句など単語より上位のセグメントを
直接認定することはなく，
これらは単語に対するBreak Indexの情報を用いて派生される．
しかし，X--JToBI自体はこれらの上位セグメントの定義を与えておらず，
上位セグメントをどのように派生するかは
コーパス開発機関ごとに微妙に異なりうる．
データベース構築ツールがこれらの上位セグメントを取得するためには，
上位セグメントが陽に表現されている必要があり，
そのため，Praatの正規形ファイルでは，
すべての上位セグメントが陽に表現されていることを規約とした．

\begin{figure}[t]
\begin{center}
\includegraphics{21-2iaCA1f6.eps}
\end{center}
\caption{Praatの正規形ファイルの例（層は上から順に，Word, AP, IP, break, fbt, tone, pronLabel）}
\label{fig:Praat}
\end{figure}


\paragraph{ELAN/Anvil：}
ELANやAnvilを用いたアノテーションでは，
複数階層のセグメントを陽に表すのが通常である．
たとえば，ジェスチャーのアノテーションでは，
ジェスチャー句とジェスチャーフェーズという複数の階層が用いられるが
\cite{細馬_2009_ジェス}，
それらは異なる層に明示的に表される．
よって，これらのアノテーションははじめから正規形と考えてよい．
なお，Anvilのリンクアノテーションは
ツール内部で生成されたidを用いて表現されているが，
データベース構築ツールは
これらのidをデータベース内で利用するグローバルなidに自動的に変換する．



\subsection{正規形ファイルから表形式ファイルへの変換}
\label{sec:Tools:table}

\ref{sec:Tools:normal}のように正規形ファイルを規約化することにより，
データベースに直接インポートできる表形式ファイルへの変換を
汎用のツールによって実行できる．
このツールは，変換時に用いる諸設定を記述した設定ファイルを読み込み，
各書式の正規形ファイルから表形式ファイルに変換する．
ツールは，シェルスクリプトとPerl，Praatスクリプト，XSLTによって実装した．

設定ファイルでは，どの正規形ファイルからどの属性を抽出し，
どのオブジェクト（セグメントやリンク）の表形式ファイルに
変換するかを記述する．
おもな設定項目を表\ref{tab:config1}に示す．
たとえば，図\ref{fig:CSV}のような形態論情報のCSV形式正規形ファイルから
長単位型セグメントの表形式ファイルを生成するための設定は
図\ref{fig:config1}（左）のようになる．
ここでは，入出力ファイル名がワイルドカードを用いて記述され，
文書id (\TT{doc-id}) がそこからどのように作られるかが指定される\footnote{
 ``\TT{\%$n$@input-file}''は\TT{input-file}変数中の
$n$番目の`\TT{\%}'にマッチする文字列を示す．}．
オブジェクトに含める属性集合は
\TT{label-names}にコンマ区切りで指定する．
長単位のように正規形ファイル中で上位階層に相当するセグメントの場合は，
セグメント区間を示すIOB2ラベルが記された列名を
\TT{unit-tag-column}で指定する．
さらに，属性集合の値が正規形ファイル中のセグメント区間の
先頭行 (\TT{first}) に記述されているか，
最終行 (\TT{last}) に記述されているかを\TT{label-position}で指定する．

\begin{table}[t]
\caption{正規形ファイルから表形式ファイルへの変換で用いる設定項目（抜粋）}
\label{tab:config1}
\input{ca01table01.txt}
\end{table}

\begin{figure}[t]
\begin{center}
\includegraphics{21-2iaCA1f7.eps}
\end{center}
\caption{正規形ファイルから表形式ファイルに変換するための設定の例}
\label{fig:config1}
\end{figure}

図\ref{fig:Praat}のような韻律情報のPraat形式正規形ファイルから
アクセント句型セグメントの表形式ファイルを生成するための設定を
図\ref{fig:config1}（中央）に示す．
CSV形式の場合とほぼ同様であるが，
セグメント区間は特定の層に陽に表現されているため，
その層の名前を\TT{primary-tier}で指定する．
また，Praatではセグメント外の要素（休止区間）も含めて
ラベルが付与されているため，
セグメント外要素であることを示すラベル値を\TT{skip-label}で指定する．

最後に，Anvilファイルからあいづち反応先型リンクの表形式ファイルを
生成するための設定を図\ref{fig:config1}（右）に示す．
Anvilのリンクアノテーションは，
あるトラックの要素（たとえばあいづち表現）から
あるトラックの要素（たとえば単語）への参照を，
参照先要素の内部idを用いて属性値として表現している．
そこで，参照元・参照先トラックの名前をそれぞれ
\TT{source-track}, \TT{destination-track}に指定し，
参照先を記述した属性の名前を\TT{link-attribute}で指定する\footnote{
 対話ではトラックは話者ごとに別個に記述されるため，
実際のトラック名は\TT{A.rt}のようにチャネル名が
前置（または後置）したものになる．
このトラック名の形式は
\TT{channel-name-type}と\TT{channel-name-delimiter}で指定する．
}．


\subsection{表形式ファイルからデータベースへの変換}
\label{sec:Tools:DB}

\ref{sec:Tools:table}で得られた表形式ファイルから
データベースを構築するには，
まずオブジェクトごとにテーブルスキーマ（\TT{CREATE TABLE}文）を
定義しなければならない．
これには，各テーブルの名前や，持っている属性の一覧およびそれらの型などが
含まれる．
この過程には，テーブルスキーマを簡易表現で定義した設定ファイルを利用する．
汎用のツールによって，設定ファイルからテーブルスキーマを定義し，
表形式ファイルからデータをインポートする．

設定ファイル中では，
(1) テーブルの名前，
(2) インポートする表形式ファイルの名前（ワイルドカードで複数指定可能），
(3) 主キーの名前と型，
(4) 属性の名前と型（のリスト）
などを指定する．
属性の型としては，
テキスト型 (\TT{t})・整数型 (\TT{i})・実数型 (\TT{r}) が利用できる．

テーブルスキーマの定義は一般に以下の形式である．

\begin{screen}
\begin{verbatim}
テーブル名=表形式ファイル一覧/主キーの名前:型/属性1の名前:型,属性2の名前:型,...
\end{verbatim}
\end{screen}

たとえば，図\ref{fig:config1}（中央）の設定を用いて生成した
アクセント句型セグメント用の表形式ファイルから
データベースのテーブルを生成するための設定は
図\ref{fig:config2}の\TT{segAP}のようになる．
同様に，図\ref{fig:config1}（右）の設定を用いて生成した
あいづち反応先型リンク用の表形式ファイルから
データベースのテーブルを生成するための設定は
図\ref{fig:config2}の\TT{linkRTTarget}のようになる．

セグメント間の階層関係は，
階層をなしうるセグメント型の名前を下位のものから順に並べて指定する．
たとえば，図\ref{fig:Praat}の
単語・アクセント句・イントネーション句間の階層関係を表現するには，
図\ref{fig:config2}の\TT{groupProsodic}のように指定する．
データベース構築ツールは，
階層関係にあるセグメント対を自動的に導出し，テーブルを作成する．
階層関係は隣接する型の間（relWord2APやrelAP2IP）だけでなく，
離れた型の間 (relWord2IP) でも導出される．

\begin{figure}[t]
\begin{center}
\includegraphics{21-2iaCA1f8.eps}
\end{center}
\caption{表形式ファイルからデータベースを生成するための設定の例}
\label{fig:config2}
\end{figure}


適用事例
\label{sec:CaseStudies}

『日本語話し言葉コーパス』と『千葉大学3人会話コーパス』を対象に，
本稿で提案した手法によりデータベースを構築し運用している．
本節ではその概要について紹介する．


\subsection{『日本語話し言葉コーパス』}

『日本語話し言葉コーパス』(CSJ) は，
2004年に一般公開された661時間の日本語自発音声からなる
データベースである\cite{前川_2004_日本語}．
このうち「コア」と呼ばれるデータ範囲（44時間）には，
おもに表\ref{tab:csjAnno}に示す研究用付加情報が付与されており
\cite{国語研_2006_日本語}，
これらを対象に本手法によりデータベースを構築した（以下CSJ-RDB）
    \cite{小磯_2012_日本語}\footnote{
 CSJでは，各種情報を統合して階層的に表現した
XML文書が提供されている．
しかし，
この階層から逸脱する情報を無理やり特定の単位に埋め込んだり，
別の階層で記述したXML文書が別途提供され，
両者にまたがった検索が困難であったりして使いづらかった．
本手法ではスタンドオフ形式でデータを表現するため，
これらの問題は解消される．
}．

各研究用付加情報はそれぞれ，表\ref{tab:csjAnno}の
「ツール」欄に示す書式
（CSJ構築時（1999〜2003年）とは異なる）で記述されており，
ここから各種中間ファイルを経てデータベースに変換した．

CSJ-RDBの（非整列）セグメントとリンクを図\ref{fig:csjRdb}に示す．
談話中の要素を記述したセグメントは，
次の3種類の階層関係からなる系列に分類される．
\begin{itemize}
 \item 形態統語論系列：短単位$<$長単位$<$文節$<$節単位
 \item 音声系列：分節音$<$音素$<$モーラ$<$短単位$<$間休止単位
 \item 韻律系列：短単位$<$アクセント句$<$イントネーション句
\end{itemize}

このうち短単位と長単位については，
時間的に分節化できる部分をセグメントで表し，
時間的に分節化できない部分は非整列セグメントとして表している．
韻律情報のうちアクセント核や句末音調などのトーン情報は，
どのアクセント句に帰属するかがリンク (linkTone2AP) によって表される．
また文節係り受け関係は，係り元と係り先の依存関係が
リンク (linkDepBunsetsu) によって表される．

\begin{table}[t]
\caption{CSJの研究用付加情報}
\label{tab:csjAnno}
\input{ca01table02.txt}
\end{table}

\begin{figure}[t]
\begin{center}
\includegraphics{21-2iaCA1f9.eps}
\end{center}
\caption{CSJ-RDBの（非整列）セグメントとリンク}
\label{fig:csjRdb}
\end{figure}


\subsection{『千葉大学3人会話コーパス』}

『千葉大学3人会話コーパス』は，
大学キャンパスにおける3人の友達同士の会話を集めた
約6時間からなる対話コーパスである\cite{Den_2007_SAT}．
このうち12会話約2時間のデータには，
表\ref{tab:chibaAnno}に示す研究用付加情報が付与されており
    \cite{Den_2007_SAT,Den_2010_TAO,Den_2011_AOJ,Den_2012_AOR}，
これらを対象にデータベースを構築した（以下Chiba-RDB）．

各研究用付加情報はそれぞれ表\ref{tab:chibaAnno}の「ツール」欄に示す
書式のアノテーションファイルで記述されており，
ここから各種中間ファイルを経てデータベースに変換した．

\begin{table}[b]
\caption{『千葉大学3人会話コーパス』の研究用付加情報}
\label{tab:chibaAnno}
\input{ca01table03.txt}
\end{table}

\begin{figure}[b]
\begin{center}
\includegraphics{21-2iaCA1f10.eps}
\end{center}
\caption{Chiba-RDBの（非整列）セグメントとリンク}
\label{fig:chibaRdb}
\end{figure}

Chiba-RDBの（非整列）セグメントとリンクを図\ref{fig:chibaRdb}に示す．
セグメントは，次の4種類の階層関係からなる系列に分類される．

\begin{itemize}
 \item 形態統語語用論系列：短単位$<$文節$<$節$<$長い発話単位
 \item 韻律系列：短単位$<$アクセント句$<$イントネーション句
 \item 視線系列：視線フェーズ$<$視線句
 \item 頭部動作系列：頭部動作フェーズ$<$頭部動作句
\end{itemize}

CSJ-RDBと異なる部分を中心に見る．
まず，長い発話単位間の連接関係（話者交替）を表す話者移行関係が
リンク (linkLUUTrans) によって表される．
また長い発話単位のうち，あいづち表現については，
あいづちが打たれるきっかけとなった表現（反応先）との関係が
リンク (linkRTTarget) によって表される．
頷きについても同様に，そのきっかけとなった表現（反応先）との関係が
リンク (linkNodTarget) によって表される．


議論
\label{sec:Discussion}


\subsection{関連研究}
\label{sec:Discussion:RelatedResearch}

本節では関連研究との違いについて述べる．
\ref{sec:Introduction}節で述べたように，
本研究は，既存のアノテーションツールやコーパス検索ツールを用いて
コーパス利用環境を実現することに主眼があり，
アノテーションツールやコーパス検索ツールの開発そのものを
目的とするものではない．
\citeA{Noguchi_2008_MPA}や\citeA{Kaplan_2010_APM}をはじめとする
関連研究とは，この点がまず大きく異なる．
さまざまなアノテーションを統合開発環境で行なうアプローチは魅力的ではあるが，
マルチモーダルデータを含む話し言葉コーパスではその実現に多くの困難が伴い，
本研究のアプローチのほうがより現実的な解を提示している．

他のツールで作成されたアノテーションを統合し利用するという点では，
\citeA{Matsumoto_2006_ACM}や\citeA{Calhoun_2010_NSC}がむしろ本研究に近い．
\citeA{Matsumoto_2006_ACM}は，
形態素解析・係り受け解析済みのテキストを読み込んで，
コーパス検索・修正などをGUIで行なうための汎用的なツール
『茶器』を開発している．
もともと書き言葉を想定していたが，最近，
話し言葉も扱えるよう拡張がなされている\cite{浅原_2013_コーパ}．
しかし，『茶器』にインポートできるデータは
決められた書式のものに限られており，
\ref{sec:Tools}節で示したような柔軟性はない．
また，扱える単位も単語・文節あたりに限られており，
\ref{sec:CaseStudies}節で見た事例のような
多岐にわたる単位を扱うことはできない．

\citeA{Calhoun_2010_NSC}は，
長年にわたってさまざまな研究機関でなされてきた，
    Switchboardコーパス\cite{Godfrey_1992_STS}に対する
さまざまな種類のアノテーションを統合し，多層にわたる検索を可能にした．
電話会話のためマルチモーダル情報は含まないが，
音素から統語構造・韻律情報，さらには非流暢性・情報構造・共参照に至るまで，
15種類以上ものアノテーションを含み，
\ref{sec:CaseStudies}節で見た本研究の事例に十分匹敵する．
彼らはさまざまな書式を持つ既存のアノテーションを変換して
この統合をなしているが，
本研究のようにそのための汎用的なツールを開発したわけではない．


\subsection{アノテーション管理について}

本研究では，話し言葉コーパスの統合利用に焦点を当てて述べてきたが，
アノテーション過程の管理もまたコーパスアノテーションの重要な課題である．
\citeA{Kaplan_2010_APM}は，
作業者管理，並行・分散アノテーション，バージョン管理，バージョンの併合
といったマクロレベルの要件を考慮した統合開発環境を提案している．
これに対して，本研究では，話し言葉で広く使われている
既存のアノテーションツールを有効に利用することを最大の要件としてきた．
そのため，統合開発環境に基づいて種々のツール群を開発するという
方向性とは異なる立場に立ってきた．
このことのデメリットについて検討する必要があろう．

統合開発環境に基づくアノテーションツールを使わないことの最大のデメリットは，
異なるツール間で共有される部分
（たとえば『日本語話し言葉コーパス』の短単位）を
あるアノテーションで修正したときに，
その影響を他のアノテーションに簡単に波及できないという点である．
統合開発環境に基づくツール群では，アノテーションデータ自身を共有しているため，
このような波及は作業者が意識しなくても暗黙的になされる．
しかし，個別のアノテーションツールを用いる本手法では，
波及的な修正は自動的には行なえない．

本手法においても，構築したデータベースから
各種アノテーションを再生成することは可能であり，
\ref{sec:CaseStudies}節で紹介した事例では，
実際にそのようなツールを作成し運用している．
このようなツールによって，あるアノテーションで生じた修正を
別のアノテーションに波及すること自体は可能である．
しかし，現状では，この種の波及的修正は，
作業者が能動的に実行しない限り，行なえない．
今後，アノテーションファイルへのアクセス方法などを工夫する
（たとえば常にデータベースから再生成するなど）ことで，
より効果的にアノテーション過程を管理する方策を考える必要がある．

また，バージョン管理の問題についても，本研究では，
汎用のバージョン管理システムSubversionを用いて
アノテーションファイルを管理しているが，これで十分というわけではない．
アノテーション過程の管理については，
既存のアノテーションツールやバージョン管理システムを含む
システム全体の中で，よりよい手段を模索する必要があろう．


\subsection{実用性について}

\ref{sec:DB}節で述べたように，提案スキーマでは，
語やアクセント句や節といった言語学的な概念とスキーマ内のオブジェクトとが
直接対応しており，ユーザの了解度は高いと思われる．
しかし，検索速度の面ではどうであろうか．

この点を調べるために，コーパス言語学でよく用いられる，
以下のような標準的なクエリに対する検索速度を計測した
（付録\ref{sec:ex}参照）．

\begin{description}
 \item[クエリ1] イントネーション句の末尾のアクセント句の先頭のモーラの継
続長を算出
 \item[クエリ2] イントネーション句の次末（末尾から2番目）のアクセント句
の末尾のモーラの継続長を算出
 \item[クエリ3] 文末形式を持つ節単位の先頭の文節の末尾の短単位が
係助詞「は」であるものを抽出し，その短単位の継続長を算出
\end{description}

(1) セグメントとリンクに基づくスキーマのように
抽象度の高い単一のセグメントを用いる場合と
(2) 本手法のように型ごとに個別化されたセグメントを用いる場合
とで比較を行なった．
なお，これ以外の条件を対等にするため，いずれも階層関係を陽に表現した．
実験は，人文系研究者がよく用いている，SQLiteのGUIである
Navicat for SQLite (ver.~11.0.10) を用いて
ノートPC (Sony VPCZ22AJ, Core i7-2640M 2.80~GHz) 上で行ない，
CSJ-RDBを検索対象とした．

\begin{table}[t]
\caption{検索速度の比較（5回の平均．単位は秒）}
\label{tab:speed}
\input{ca01table04.txt}
\end{table}

結果を表\ref{tab:speed}に示す．
「個別」は総じて「単一」の倍程度の速さであり，
個別化されたセグメントを用いることで検索速度も若干改善されることがわかる．
この程度の違いがどれだけの意味を持つかはわからないが，
少なくとも提案スキーマが実用性で劣るということはない．


隣接語対を抽出するクエリ
\label{sec:bigram}

同一節 (segClause) 内で隣接する単語 (segWord) の対を抽出するクエリ．
階層関係テーブル (relWord2Clause) を用いない場合は，
サブクエリを用いた煩雑なクエリとなる．

\begin{query}
-- 階層関係を用いない場合
SELECT W1.id AS current, W2.id AS next
  FROM segClause AS C
 INNER JOIN segWord AS W1 ON W1.docID = C.docID AND W1.channel = C.channel
                         AND W1.start >= C.start AND W1.start < C.end
 INNER JOIN segWord AS W2 ON W2.docID = W1.docID AND W2.channel = W1.channel
 WHERE W2.start = (SELECT MIN(W3.start)
                     FROM segWord AS W3
                    WHERE W3.docID = W1.docID AND W3.channel = W1.channel
                      AND W3.start > W1.start AND W3.start < C.end);
\end{query}

\begin{query}
-- 階層関係を用いた場合
SELECT W1.id AS current, W2.id AS next
  FROM segWord AS W1
 INNER JOIN relWord2Clause AS R1 ON R1.descendant = W1.id
 INNER JOIN relWord2Clause AS R2 ON R2.ancestor = R1.ancestor
 INNER JOIN segWord AS W2 ON W2.id = R2.descendant
 WHERE R2.nth = R1.nth + 1;
\end{query}

