本節では，マルチチャネル・マルチモーダルの話し言葉コーパスを表現できる汎用的なデータベーススキーマを提案する．
本スキーマは，基本的には，[CITE]と[CITE]が提案したセグメントとリンクに基づくスキーマに依拠している．
しかし，彼らのスキーマは書き言葉を想定しており，話し言葉に適用するためにはいくつかの拡張が必要である．
以下，拡張・改良点について順に述べ，我々のスキーマを提案する．
セグメントとリンクに基づくスキーマでは以下の2種類のオブジェクトを用いる．
文書中の特定の開始位置(start)と終了位置(end)で指定される区間に存在する，特定の型(type)の要素．
単語・句・節など．
参照元セグメント(source)と参照先セグメント(destination)の間に設定される，特定の型(type)の依存関係．
係り受け関係・照応関係など．
いずれのオブジェクトも型ごとに定まった属性(name)と値(value)の対の集合を持つ．
たとえば，単語型セグメントは品詞・活用型・活用形などの属性を持ちうるし，係り受け関係型リンクは係り受けの種類（従属と並列の区別）などの属性を持ちうる．
これらの属性値が付随したセグメントとリンクの集合によって文書を表現する．
セグメントとリンクに基づくスキーマのクラス図を図[REF_fig:SLAT]に示す．
セグメントとリンクに基づくスキーマはもともと書き言葉を想定して作られており，話し言葉に適用するためにはいくつかの拡張が必要である．
開始・終了位置としては文書中での文字位置（文書の先頭から数えて何文字目か）が想定されている．
しかし，話し言葉で対象となる要素（アクセント・音調や視線・頷きなど）は必ずしもテキスト情報に基づいていない．
そこで，開始・終了位置として文書（音声・映像ファイル）中での時刻（文書の先頭からの経過時間）を用いる．
話し言葉ではしばしば隣接する単位間での融合が生じる．
たとえば，「私は」が融合して「ワタシャ」のように発音されたりする．
この場合，「私」と「は」の境界は実際の音声中には存在しないので，個々の単語を時刻に依拠したセグメントとしては表せない．
そこで，セグメントとしては融合した「わたしゃ」全体を一つの単位とし，個々の形態論情報を担う単位を「時間的に整列されないセグメント」（非整列セグメント）として別途表現する（図[REF_fig:subseg]）-0.5zw．
これらのセグメントと非整列セグメントの間の依存関係は後述する階層関係を用いて表現し，各非整列セグメントが「何個の非整列セグメントからなる（長さlenの）セグメント中の何番目の要素であるか(nth)」という情報を与える（図[REF_fig:subseg]ではnth/lenで表記）．
書き言葉の文書は通常，単一のストリームからなる．
しかし，話し言葉の対話データでは，複数話者によるマルチチャネルのストリームに対応しなければならない．
これはチャネルごとに時刻を相対化することで解決できる．
そのために，セグメントの表現にチャネル識別子（話者ラベルなど）を追加する．
書き言葉の文書にはテキストという単一のモダリティしかない．
しかし，話し言葉のマルチモーダルデータでは，音声言語に加えて，視線・頷きやジェスチャーなどのモダリティに対応しなければならない．
セグメントとリンクに基づくスキーマはスタンドオフ形式のため，このような単一の根ノードにまとまらない単位階層にも自然に対応できる．
一方で，区間の包含関係で階層関係を表すスタンドオフ形式では，不適切な階層関係が認定されることがある．
たとえば，「うん，そうだね」という発話が頷きを伴ってなされた場合，「うん」という単語はこの発話の適切な下位単位であるが，頷きは発話の適切な下位単位とは言えない．
どの型のセグメント間に階層関係が設定されるかは，各セグメント型の認識論的な位置づけによってアプリオリに定まっているべきである．
そこで，本スキーマでは，セグメント間の階層関係を明示的に表現する．
これは，下位セグメントを参照元，上位セグメントを参照先とした特別な型のリンクととらえることができる．
セグメントとリンクに基づくスキーマは，さまざまな属性集合を持ちうるさまざまな型のセグメントやリンクを扱うために，極めて抽象度の高いスキーマになっている（セグメントとリンクという2種類のオブジェクトしかない）．
[CITE]や[CITE]は，「述語」や「項」といったより具体性の高いオブジェクトを操作できるアノテーションツールやコーパス検索ツールをインターフェースとして提供することで，ユーザの利便性を図っている．
しかし，既存のアノテーションツールやコーパス検索ツールを用いてコーパス利用環境を実現しようという本研究においては，このような利便を図ることはできず，スキーマ中のオブジェクトがそのままユーザが操作する対象となる．
そこでは，語やアクセント句や節といったオブジェクトがそのまま操作できたほうがユーザの了解度は高いと思われる．
そこで，（非整列）セグメントや（階層関係を含む）リンクを型ごとに別々のオブジェクトとして表現し，属性は各オブジェクトに直接表現する．
属性集合は型ごとに定まるため，型ごとにオブジェクトを別にすれば，このような表現が可能となる．
また，階層関係については，「何個の下位セグメントからなる（長さlenの）上位セグメント中の何番目の要素であるか(nth)」という情報を付与する．
この情報は時刻の情報から導出できるため，表現としては冗長である．
しかし，話し言葉では，隣接するセグメント間で先行要素の終了位置と後続要素の開始位置が一致するという制約が必ずしも成り立たない（間に休止が介在しうる）ため，SQL言語を用いると，たとえば隣接語対を抽出するのに煩雑な検索を行なわなければならない．
上述の情報があれば，この検索は簡単に行なえる（付録[REF_sec:bigram]参照）．
[REF_sec:DB:spoken]と[REF_sec:DB:practical]の議論を踏まえ，図[REF_fig:model]のスキーマを設計した．
本スキーマでは以下の4種類のオブジェクトを用いる．
文書中の特定のチャネル(channel)上の特定の開始位置(start)と終了位置(end)で指定される区間に存在する要素．
型([MATH])ごとに別のオブジェクトとして表現され，それぞれ特定の属性集合([MATH],…, [MATH])を持つ．
時間的に分節化されない，セグメントの下位要素．
型([MATH])ごとに別のオブジェクトとして表現され，特定の属性集合([MATH],…, [MATH])を持つ．
参照元セグメント(source)と参照先セグメント(destination)の間に設定される依存関係．
型([MATH])ごとに別のオブジェクトとして表現され，それぞれ特定の属性集合([MATH],…, [MATH])を持つ．
下位セグメント(descendant)と上位セグメント(ancestor)の間に設定される階層関係．
上位・下位セグメントの型の組み合わせ([MATH]と[MATH])ごとに別のオブジェクトとして表現され，同一の上位セグメントに帰属する下位セグメントの総数(len)とそれらのうち何番目の要素であるか(nth)を属性として持つ．
オブジェクトの種類としては限られているが，型ごとに別々のオブジェクトとして表現されるため，実際のオブジェクトの数はしばしば十数個にもなる．
元のセグメントとリンクに基づくスキーマ（図[REF_fig:SLAT]）と比べると，以下の違いがある．
非整列セグメントが導入された．
階層関係が陽に表現された．
（非整列）セグメントやリンクが型ごとに別々のオブジェクトとして表現され，属性を内包するようになった．
本節では，既存のアノテーションツールで作成された種々の書式を持つアノテーションから，[REF_sec:DB]節で提案したスキーマに基づくデータベースを自動的に構築するツールについて述べる．
本ツールは現在のところ，CSVベースのツール，Praat [CITE]，ELAN [CITE]，Anvil [CITE]の4種類のアノテーションツールに対応している．
これらのアノテーションファイルから提案スキーマに基づくデータベースを生成することが本ツールの目的である．
構築するデータベースは可搬性に優れたSQLiteを採用した．
SQLiteは，すべてのテーブルやインデックスを単一のファイルで実装するスタンドアローンの関係データベースであり，『茶器』[CITE]などのコーパス管理環境でも利用されている．
4種類のアノテーションの書式は大きく異なるが，ある一定の規約を設けることにより，データベースに直接インポートできる表形式ファイルに容易に変換できる．
この規約に従ったアノテーションを「正規形」と呼ぶ．
ELANやAnvilは本研究と類似のスキーマを用いており，はじめからこの規約に従っている．
一方，CSVやPraatでは前もって正規形に変換する必要がある．
したがって，データベースの構築過程は以下のようになる．
（アノテーションファイル[MATH]）正規形ファイル[MATH]表形式ファイル[MATH]データベース
本ツールでは以下の4種類のアノテーションツールを利用できる．
形態論情報や談話行為など，テキスト情報に基づくアノテーションには，コンマで区切られたCSV形式の入出力を持つツールを用いることが多い．
たとえば，Microsoft Excelは人文系・理工系を問わず，広く用いられているCSVベースのツールであり，形態素解析システムなどの言語処理ツールの出力もCSV形式にできるものが多い．
Praatは高機能な音声アノテーションツールであり，話し言葉の音声学的アノテーションで標準的なツールとなっている．
分節音・単語境界や韻律情報のアノテーションで広く利用されている．
出力書式は独自のものであるが，基本的にスタンドオフ形式である．
ELANは高機能な映像アノテーションツールであり，ジェスチャー研究などで広く利用されている．
本研究と類似のスキーマを用いており，出力書式はスタンドオフ形式のXMLである．
Anvilも映像アノテーションツールである．
ELANにはないリンクアノテーションの機能があり，発話間の関係づけやあいづち表現の反応先などのアノテーションで利用できる．
Anvilの出力書式もスタンドオフ形式のXMLである．
以上のアノテーションからデータベースを構築するためには，スキーマを具現化する上で必須の情報がアノテーションファイルから取得できないといけない．
これらは，セグメントでは開始・終了位置であり，リンクでは参照元・参照先セグメント（を一意に同定する情報）である．
これらの情報の取得を保証するアノテーションを「正規形」と呼ぶ．
以下，アノテーションファイルの書式ごとに順に述べる．
CSV形式の正規形ファイルの例として，形態論情報アノテーションの例を図[REF_fig:CSV]に示す．
CSV形式の正規形では，各行に開始・終了時刻が記されているものとする．
たとえば，形態論情報アノテーションでは，Praatなどを用いて別途ラベリングした単語境界の情報から単語ごとの開始・終了時刻が転写されているものとする．
ただし，[REF_sec:DB:spoken]で述べた単位の融合などにより時刻を定められない箇所は「不定」（``NA''で示す）としてよい．
「不定」でない開始・終了時刻を持つ最小の範囲（図[REF_fig:CSV]の冒頭の例では「第一」）がセグメントとして認定され，各行はその下位に位置する非整列セグメントとして認定される．
1つのCSVファイルで複数の単位をアノテーションする場合がしばしばある．
たとえば，図[REF_fig:CSV]では，短単位(SUW)と長単位(LUW)という複数の粒度で語が認定されている（「第一母音」は長単位では1つの語であり，短単位では「第」「一」「母音」という3つの語である）．
このような場合には，IOB2ラベル[CITE]によって上位単位の区間を示す（図[REF_fig:CSV]のluwLabel列）-0.5zw．
CSV形式でリンクを表すには，ローカルに定義されたid（文内での文節の通し番号など）を用いて参照元と参照先を示す．
たとえば，係り受け解析器CaboCha [CITE]の出力はこのような情報を含んでいる．
データベース構築ツールはこれらのidをデータベース内で利用するグローバルなidに自動的に変換する．
Praatの正規形ファイルの例として，韻律情報アノテーションの例を図[REF_fig:Praat]に示す．
Praatは多層アノテーションツールであり，複数階層のセグメントを同時に表すことができる．
図[REF_fig:Praat]では上段の3層，単語(Word)・アクセント句(AP)・イントネーション句(IP)がそれらに対応する．
韻律情報のアノテーションスキーマとして広く用いられているX--JToBI [CITE]では，アクセント句やイントネーション句など単語より上位のセグメントを直接認定することはなく，これらは単語に対するBreak Indexの情報を用いて派生される．
しかし，X--JToBI自体はこれらの上位セグメントの定義を与えておらず，上位セグメントをどのように派生するかはコーパス開発機関ごとに微妙に異なりうる．
データベース構築ツールがこれらの上位セグメントを取得するためには，上位セグメントが陽に表現されている必要があり，そのため，Praatの正規形ファイルでは，すべての上位セグメントが陽に表現されていることを規約とした．
ELANやAnvilを用いたアノテーションでは，複数階層のセグメントを陽に表すのが通常である．
たとえば，ジェスチャーのアノテーションでは，ジェスチャー句とジェスチャーフェーズという複数の階層が用いられるが[CITE]，それらは異なる層に明示的に表される．
よって，これらのアノテーションははじめから正規形と考えてよい．
なお，Anvilのリンクアノテーションはツール内部で生成されたidを用いて表現されているが，データベース構築ツールはこれらのidをデータベース内で利用するグローバルなidに自動的に変換する．
[REF_sec:Tools:normal]のように正規形ファイルを規約化することにより，データベースに直接インポートできる表形式ファイルへの変換を汎用のツールによって実行できる．
このツールは，変換時に用いる諸設定を記述した設定ファイルを読み込み，各書式の正規形ファイルから表形式ファイルに変換する．
ツールは，シェルスクリプトとPerl，Praatスクリプト，XSLTによって実装した．
設定ファイルでは，どの正規形ファイルからどの属性を抽出し，どのオブジェクト（セグメントやリンク）の表形式ファイルに変換するかを記述する．
おもな設定項目を表[REF_tab:config1]に示す．
たとえば，図[REF_fig:CSV]のような形態論情報のCSV形式正規形ファイルから長単位型セグメントの表形式ファイルを生成するための設定は図[REF_fig:config1]（左）のようになる．
ここでは，入出力ファイル名がワイルドカードを用いて記述され，文書id (\TT{doc-id})がそこからどのように作られるかが指定される．
オブジェクトに含める属性集合は\TT{label-names}にコンマ区切りで指定する．
長単位のように正規形ファイル中で上位階層に相当するセグメントの場合は，セグメント区間を示すIOB2ラベルが記された列名を\TT{unit-tag-column}で指定する．
さらに，属性集合の値が正規形ファイル中のセグメント区間の先頭行(\TT{first})に記述されているか，最終行(\TT{last})に記述されているかを\TT{label-position}で指定する．
図[REF_fig:Praat]のような韻律情報のPraat形式正規形ファイルからアクセント句型セグメントの表形式ファイルを生成するための設定を図[REF_fig:config1]（中央）に示す．
CSV形式の場合とほぼ同様であるが，セグメント区間は特定の層に陽に表現されているため，その層の名前を\TT{primary-tier}で指定する．
また，Praatではセグメント外の要素（休止区間）も含めてラベルが付与されているため，セグメント外要素であることを示すラベル値を\TT{skip-label}で指定する．
最後に，Anvilファイルからあいづち反応先型リンクの表形式ファイルを生成するための設定を図[REF_fig:config1]（右）に示す．
Anvilのリンクアノテーションは，あるトラックの要素（たとえばあいづち表現）からあるトラックの要素（たとえば単語）への参照を，参照先要素の内部idを用いて属性値として表現している．
そこで，参照元・参照先トラックの名前をそれぞれ\TT{source-track}, \TT{destination-track}に指定し，参照先を記述した属性の名前を\TT{link-attribute}で指定する．
[REF_sec:Tools:table]で得られた表形式ファイルからデータベースを構築するには，まずオブジェクトごとにテーブルスキーマ（\TT{CREATE TABLE}文）を定義しなければならない．
これには，各テーブルの名前や，持っている属性の一覧およびそれらの型などが含まれる．
この過程には，テーブルスキーマを簡易表現で定義した設定ファイルを利用する．
汎用のツールによって，設定ファイルからテーブルスキーマを定義し，表形式ファイルからデータをインポートする．
設定ファイル中では，(1)テーブルの名前，(2)インポートする表形式ファイルの名前（ワイルドカードで複数指定可能），(3)主キーの名前と型，(4)属性の名前と型（のリスト）などを指定する．
属性の型としては，テキスト型(\TT{t})・整数型(\TT{i})・実数型(\TT{r})が利用できる．
テーブルスキーマの定義は一般に以下の形式である．
テーブル名=表形式ファイル一覧/主キーの名前:型/属性1の名前:型,属性2の名前:型,.
..
たとえば，図[REF_fig:config1]（中央）の設定を用いて生成したアクセント句型セグメント用の表形式ファイルからデータベースのテーブルを生成するための設定は図[REF_fig:config2]の\TT{segAP}のようになる．
同様に，図[REF_fig:config1]（右）の設定を用いて生成したあいづち反応先型リンク用の表形式ファイルからデータベースのテーブルを生成するための設定は図[REF_fig:config2]の\TT{linkRTTarget}のようになる．
セグメント間の階層関係は，階層をなしうるセグメント型の名前を下位のものから順に並べて指定する．
たとえば，図[REF_fig:Praat]の単語・アクセント句・イントネーション句間の階層関係を表現するには，図[REF_fig:config2]の\TT{groupProsodic}のように指定する．
データベース構築ツールは，階層関係にあるセグメント対を自動的に導出し，テーブルを作成する．
階層関係は隣接する型の間（relWord2APやrelAP2IP）だけでなく，離れた型の間(relWord2IP)でも導出される．
『日本語話し言葉コーパス』と『千葉大学3人会話コーパス』を対象に，本稿で提案した手法によりデータベースを構築し運用している．
本節ではその概要について紹介する．
『日本語話し言葉コーパス』(CSJ)は，2004年に一般公開された661時間の日本語自発音声からなるデータベースである[CITE]．
このうち「コア」と呼ばれるデータ範囲（44時間）には，おもに表[REF_tab:csjAnno]に示す研究用付加情報が付与されており[CITE]，これらを対象に本手法によりデータベースを構築した（以下CSJ-RDB）[CITE]．
各研究用付加情報はそれぞれ，表[REF_tab:csjAnno]の「ツール」欄に示す書式（CSJ構築時（1999〜2003年）とは異なる）で記述されており，ここから各種中間ファイルを経てデータベースに変換した．
CSJ-RDBの（非整列）セグメントとリンクを図[REF_fig:csjRdb]に示す．
談話中の要素を記述したセグメントは，次の3種類の階層関係からなる系列に分類される．
形態統語論系列：短単位[MATH]長単位[MATH]文節[MATH]節単位
音声系列：分節音[MATH]音素[MATH]モーラ[MATH]短単位[MATH]間休止単位
韻律系列：短単位[MATH]アクセント句[MATH]イントネーション句
このうち短単位と長単位については，時間的に分節化できる部分をセグメントで表し，時間的に分節化できない部分は非整列セグメントとして表している．
韻律情報のうちアクセント核や句末音調などのトーン情報は，どのアクセント句に帰属するかがリンク(linkTone2AP)によって表される．
また文節係り受け関係は，係り元と係り先の依存関係がリンク(linkDepBunsetsu)によって表される．
『千葉大学3人会話コーパス』は，大学キャンパスにおける3人の友達同士の会話を集めた約6時間からなる対話コーパスである[CITE]．
このうち12会話約2時間のデータには，表[REF_tab:chibaAnno]に示す研究用付加情報が付与されており[CITE]，これらを対象にデータベースを構築した（以下Chiba-RDB）．
各研究用付加情報はそれぞれ表[REF_tab:chibaAnno]の「ツール」欄に示す書式のアノテーションファイルで記述されており，ここから各種中間ファイルを経てデータベースに変換した．
Chiba-RDBの（非整列）セグメントとリンクを図[REF_fig:chibaRdb]に示す．
セグメントは，次の4種類の階層関係からなる系列に分類される．
形態統語語用論系列：短単位[MATH]文節[MATH]節[MATH]長い発話単位
韻律系列：短単位[MATH]アクセント句[MATH]イントネーション句
視線系列：視線フェーズ[MATH]視線句
頭部動作系列：頭部動作フェーズ[MATH]頭部動作句
CSJ-RDBと異なる部分を中心に見る．
まず，長い発話単位間の連接関係（話者交替）を表す話者移行関係がリンク(linkLUUTrans)によって表される．
また長い発話単位のうち，あいづち表現については，あいづちが打たれるきっかけとなった表現（反応先）との関係がリンク(linkRTTarget)によって表される．
頷きについても同様に，そのきっかけとなった表現（反応先）との関係がリンク(linkNodTarget)によって表される．
本節では関連研究との違いについて述べる．
[REF_sec:Introduction]節で述べたように，本研究は，既存のアノテーションツールやコーパス検索ツールを用いてコーパス利用環境を実現することに主眼があり，アノテーションツールやコーパス検索ツールの開発そのものを目的とするものではない．
[CITE]や[CITE]をはじめとする関連研究とは，この点がまず大きく異なる．
さまざまなアノテーションを統合開発環境で行なうアプローチは魅力的ではあるが，マルチモーダルデータを含む話し言葉コーパスではその実現に多くの困難が伴い，本研究のアプローチのほうがより現実的な解を提示している．
他のツールで作成されたアノテーションを統合し利用するという点では，[CITE]や[CITE]がむしろ本研究に近い．
[CITE]は，形態素解析・係り受け解析済みのテキストを読み込んで，コーパス検索・修正などをGUIで行なうための汎用的なツール『茶器』を開発している．
もともと書き言葉を想定していたが，最近，話し言葉も扱えるよう拡張がなされている[CITE]．
しかし，『茶器』にインポートできるデータは決められた書式のものに限られており，[REF_sec:Tools]節で示したような柔軟性はない．
また，扱える単位も単語・文節あたりに限られており，[REF_sec:CaseStudies]節で見た事例のような多岐にわたる単位を扱うことはできない．
[CITE]は，長年にわたってさまざまな研究機関でなされてきた，Switchboardコーパス[CITE]に対するさまざまな種類のアノテーションを統合し，多層にわたる検索を可能にした．
電話会話のためマルチモーダル情報は含まないが，音素から統語構造・韻律情報，さらには非流暢性・情報構造・共参照に至るまで，15種類以上ものアノテーションを含み，[REF_sec:CaseStudies]節で見た本研究の事例に十分匹敵する．
彼らはさまざまな書式を持つ既存のアノテーションを変換してこの統合をなしているが，本研究のようにそのための汎用的なツールを開発したわけではない．
本研究では，話し言葉コーパスの統合利用に焦点を当てて述べてきたが，アノテーション過程の管理もまたコーパスアノテーションの重要な課題である．
[CITE]は，作業者管理，並行・分散アノテーション，バージョン管理，バージョンの併合といったマクロレベルの要件を考慮した統合開発環境を提案している．
これに対して，本研究では，話し言葉で広く使われている既存のアノテーションツールを有効に利用することを最大の要件としてきた．
そのため，統合開発環境に基づいて種々のツール群を開発するという方向性とは異なる立場に立ってきた．
このことのデメリットについて検討する必要があろう．
統合開発環境に基づくアノテーションツールを使わないことの最大のデメリットは，異なるツール間で共有される部分（たとえば『日本語話し言葉コーパス』の短単位）をあるアノテーションで修正したときに，その影響を他のアノテーションに簡単に波及できないという点である．
統合開発環境に基づくツール群では，アノテーションデータ自身を共有しているため，このような波及は作業者が意識しなくても暗黙的になされる．
しかし，個別のアノテーションツールを用いる本手法では，波及的な修正は自動的には行なえない．
本手法においても，構築したデータベースから各種アノテーションを再生成することは可能であり，[REF_sec:CaseStudies]節で紹介した事例では，実際にそのようなツールを作成し運用している．
このようなツールによって，あるアノテーションで生じた修正を別のアノテーションに波及すること自体は可能である．
しかし，現状では，この種の波及的修正は，作業者が能動的に実行しない限り，行なえない．
今後，アノテーションファイルへのアクセス方法などを工夫する（たとえば常にデータベースから再生成するなど）ことで，より効果的にアノテーション過程を管理する方策を考える必要がある．
また，バージョン管理の問題についても，本研究では，汎用のバージョン管理システムSubversionを用いてアノテーションファイルを管理しているが，これで十分というわけではない．
アノテーション過程の管理については，既存のアノテーションツールやバージョン管理システムを含むシステム全体の中で，よりよい手段を模索する必要があろう．
[REF_sec:DB]節で述べたように，提案スキーマでは，語やアクセント句や節といった言語学的な概念とスキーマ内のオブジェクトとが直接対応しており，ユーザの了解度は高いと思われる．
しかし，検索速度の面ではどうであろうか．
この点を調べるために，コーパス言語学でよく用いられる，以下のような標準的なクエリに対する検索速度を計測した（付録[REF_sec:ex]参照）．
イントネーション句の末尾のアクセント句の先頭のモーラの継続長を算出
イントネーション句の次末（末尾から2番目）のアクセント句の末尾のモーラの継続長を算出
文末形式を持つ節単位の先頭の文節の末尾の短単位が係助詞「は」であるものを抽出し，その短単位の継続長を算出
(1)セグメントとリンクに基づくスキーマのように抽象度の高い単一のセグメントを用いる場合と(2)本手法のように型ごとに個別化されたセグメントを用いる場合とで比較を行なった．
なお，これ以外の条件を対等にするため，いずれも階層関係を陽に表現した．
実験は，人文系研究者がよく用いている，SQLiteのGUIであるNavicat for SQLite (ver. 11.0.10)を用いてノートPC (Sony VPCZ22AJ, Core i7-2640M 2.80 GHz)上で行ない，CSJ-RDBを検索対象とした．
結果を表[REF_tab:speed]に示す．
「個別」は総じて「単一」の倍程度の速さであり，個別化されたセグメントを用いることで検索速度も若干改善されることがわかる．
この程度の違いがどれだけの意味を持つかはわからないが，少なくとも提案スキーマが実用性で劣るということはない．
