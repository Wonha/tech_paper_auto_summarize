本稿で提案するLR解析表の圧縮方法について，その原理と性質について述べる．
LR構文解析法は，LR表と，スタック，先読み語を参照し，次の動作を決定する．
LR表は，文法が与えられた時点であらかじめ計算できる構文解析過程を表したものである．
LR表の作成(付録.
A参照)には，構文解析中のある状態を表すデータ構造として，LR項(LR Item)を用いる．
LR項とは，ある生成規則(CFG規則)の右辺の記号列中のある位置にドット`・'を付けたデータ構造である．
ドットは，記号列のどの部分まで解析が進んだかを表す．
下記のLR(0)項は，生成規則[MATH]において，[MATH]の先頭部分列[MATH]まで解析が終了し，その後記号列[MATH]を解析する必要がある状態を表す．
[MATH]
[MATH]や[MATH]は空記号列の場合も含まれる．
例えば，生成規則[MATH]に対して，[MATH], [MATH], [MATH], [MATH]の4つのLR項が考えられる．
このように，従来のLR表で用いられるLR項は規則毎に作成され，LR項だけで解析中の規則とその解析位置，解析された記号列([MATH])およびこれから解析すべき記号列([MATH])を特定することができる．
一方，LR構文解析法では，解析途中の状態を表現するデータ構造として，解析済の(終端および非終端)記号を記憶する解析スタックが併用される(文脈自由言語を受理するプッシュダウン・オートマトンのスタックに相当する)．
上の例のLR項が表す状態では，解析スタックには，記号列[MATH]が，スタックトップから逆順に保持されているはずである．
例えば，LR項[MATH]が表す状態では，スタックは[MATH] (ただし，[MATH]は状態番号，スタックトップは右)となる．
したがって，すでに解析済の記号列は，LR項と解析スタックに重複して記載されており，冗長である．
そこで，LR項から冗長な解析済記号列[MATH]の記号情報を捨象することが可能となる．
ここで，捨象可能なのは，記号情報だけで，記号数の情報は保持する必要があることに注意されたい．
解析スタックには，解析済の記号がその記号が属する規則に関係なくフラットに保持される．
スタック[MATH]を見ただけでは，記号[MATH]が規則[MATH]，[MATH]，[MATH]のいずれに属する[MATH]なのか，区別することができない．
そこで，LR項が表す解析状態で，スタックトップからいくつの記号がこの規則で解析中かという情報を保持しなければならない．
以上のことから，従来のLR項のドットの左側の記号列を抽象化して，その記号の個数で置き換え，新しいLR項とする．
すなわち，次のようなLR項を用いる．
[MATH]
ここで，[MATH]は，記号列[MATH]の記号数を表すものとする．
このLR項を左方抽象化LR項と呼ぶことにする．
例えば，生成規則[MATH]に対して，[MATH], [MATH], [MATH], [MATH]の4つの左方抽象化LR項が考えられる．
LR表は，生成規則集合が与えられた時点で，そこから求められる構文解析時のあらゆる解析途中の状態を抽出し，また各状態間の遷移関係を求めて，状態遷移図(プッシュダウンオートマトン)として表現したものである．
ここで解析途中の状態は，LR項の集合(クロージャ)に対応し，規則適用の部分的解析結果(LR項に相当)の複数の可能性(集合)を表している．
この時，解析状態の同一性は，クロージャの同一性で判断される．
例えば，異なる解析パスから，同一のLR項集合が得られる場合，それらは同じ状態とみなすことができる．
クロージャの要素として，従来のLR項の代わりに，不必要な情報が捨象された左方抽象化LR項を用いると，より多くの解析状態(クロージャ)が同一の状態と見なされる．
したがって，結果として得られるLR表の状態数が減少し，表のサイズが縮小される．
これが提案手法の原理である．
LR表作成アルゴリズムは，従来のLR項の代わりに，上記の左方抽象化LR項を用いても，新たな処理を加えること無く若干の修正だけで適用できる．
以下では，LR表作成手順の[クロージャ] [GOTO手続き][LR項集合の集合][LR表の作成]の各手続き(付録.
A参照)，それぞれについて，修正手続きを示す．
(この手法を，提案法1と呼ぶ．
また提案法1によって作成されたLR表を圧縮LR表と呼ぶ．
)
[クロージャ]，[GOTO手続き]，[LR項集合の集合]では，LR項のドットの左側を参照する手続きが存在しないので，左方抽象化LR項を用いて，ほぼそのまま，「LR項集合の集合」を作成できる．
唯一，ドットの左側の生成・修正の手続きに若干の変更を加える．
具体的には，以下の2点を変更する．
[クロージャ]作成手続きのステップ2を次のように変更する．
[MATH]に左方抽象化LR項[MATH]があれば，左辺が[MATH]の全ての生成規則[MATH]について，LR項[MATH]を加える．
この手続きを新たなLR項が加えられなくなるまで繰り返す．
また，[GOTO手続き][MATH]を次のように変更する．
[MATH]中の，ドットのすぐ右が[MATH]である全てのLR項[MATH]に対し，LR項[MATH]を求め，そのクロージャを返す．
得られたLR項集合の集合から[LR表の作成]において，[MATH]表への[MATH]や[MATH]の書き込み，および[MATH]表の作成にも変更点はない．
一方，[MATH]動作の引数には，従来の生成規則の代わりに，生成記号の左辺記号と右辺記号列の記号数のペアを記述する．
すなわち，[LR表の作成]のreduce動作の書き込みを次のように変更する．
[MATH]にLR項[MATH]が存在するならば，[MATH]について，[MATH]に[MATH]を加える．
このように，修正手続きで作成されるLR表では，reduce動作の引数には生成規則のうち，左辺の記号列の記号情報を捨象した一部の情報しか記述されない．
しかし，この情報[MATH]と[MATH]さえあれば，どの生成規則が適用されたかは，構文解析時に特定可能である点に注意されたい．
左辺記号[MATH]と，解析スタックから[MATH]個の記号をポップすることで得られる記号列[MATH]から，[MATH]と復元可能である．
また，提案手法での修正箇所は，既存の表作成アルゴリズム中のある手続きを同等の手続きで置き換えただけであり，新たな手続きの呼び出しは行っていない．
したがって，従来の表作成アルゴリズムと同じ計算オーダで作成可能である．
日本語において，動詞の格を表す句は，語順が自由であり，任意に省略可能であることが多い．
次のような日本語を解析する文法(図[REF_fig:g_example])を考える．
太郎が花子にりんごを与える
花子に太郎がりんごを与える
りんごを太郎が花子に与える
太郎がりんごを与える
りんごを与える
与える
この文法から，従来の表作成アルゴリズムと，提案法による表作成アルゴリズムによってつくられたGOTOグラフの一部(記号`S'を左辺に持つ規則の集合に相当する部分)を，それぞれ図[REF_fig:goto]，図[REF_fig:r_goto]に示す．
従来法では，規則右辺に現れる記号列の文脈によって異なる状態が作成されるため，木の形に分岐したグラフが作成される．
一方提案法では，記号列の文脈によらずに後方部分がマージされたグラフが作成され，状態数が32から12へ大幅に減少することが分かる．
\leavevmode
提案法の効果と効率について，その性質を考察する．
LR項においてドットより左方の記号列が記号数へと抽象化されることにより，従来異なるLR項として認識された以下のような2つのLR項が，同一のLR項として認識されることになる．
[MATH]    ,    [MATH]
where [MATH]
これらから生成されるクロージャも同一のクロージャとなる．
すなわち，「LR項集合の集合」作成時に，従来異なる状態(LR項集合)となっていたものが，1つの状態にマージされることになる．
よって，最終的なLR表の状態数は減少する．
ここで，マージされるLR項が存在するための，文法[MATH]の必要条件を考察する．
上記の同一視される2つのLR項について，[MATH]と[MATH]以外は等しくなければならない．
また，[MATH]，すなわち[MATH]である必要がある．
以上をまとめると，文法[MATH]に，以下の条件を満たす規則のペア[MATH]，[MATH]が少なくとも一組以上存在する必要がある．
左辺記号[MATH]，[MATH]が等しい．
[MATH]と[MATH]の接尾記号列が一致する．
すなわち，[MATH]，[MATH]と書けるとき，[MATH]となる[MATH]が存在する．
[MATH]
このような規則のペアが，文法[MATH]中に多く存在するほど，提案法による状態数の削減の効果は大きい．
圧縮LR表を用いて構文解析を行った場合の効率について考える．
提案法は，すでに解析済の情報(ドットの左側の記号情報)だけを捨象する．
これから解析する部分(ドットの右側の記号情報)には手を加えない．
提案法によって状態の統合が行われた場合，統合後の状態(クロージャ)は以前の状態と同数のLR項を持ち，それぞれのLR項のこれから解析する部分(ドットの右側の記号情報)も等しい．
したがって，統合後もその後の解析の処理量は等しく，構文解析の効率は悪くならない．
[REF_ss:quality]節で述べたように，(1)規則左辺の記号が同じ，(2)右辺の接尾部分が共通，(3)右辺の記号数が同じ，の3条件を満たす規則の組が文法中に多く現れるほど，提案法の効果は大きい．
このうち，(3)右辺記号数の条件は，改善の余地がある．
本節では，この条件を克服するための拡張方法について述べる．
ドットの左側に記号数が必要なのは，reduce動作時にスタックからポップする要素数を記録するためである．
この要素数は，LR表にreduce動作の引数として，静的に記述される．
しかし，このポップ要素数は解析時に動的に求めることもできる．
そこで，図[REF_fig:stack]のように，この情報をスタックに保持することを考える．
すなわち，reduce動作の際，スタックに保持された区切り位置までポップするような構文解析アルゴリズムを考える．
このような区切りをスタックに入れるようなLR表はどのように生成すればよいだろうか．
区切りは，規則右辺の最初の記号をスタックに積む時に挿入すればよい．
すなわち，LR項
[MATH]
からGOTO手続きによって，LR項
[MATH]
を生成する際に，スタックに挿入すればよい．
ドットが最左にある場合の，次の状態への遷移(すなわち，shift動作やgoto)の場合に，スタックに区切りを挿入する．
注意すべきなのは，ある状態(クロージャ)に，ドットのすぐ右の記号が同じで，ドットが最左のものと規則途中にあるものの，2つ以上のLR項が含まれている場合があることである．
すなわち，次のような2つのLR項が，同じクロージャ[MATH]に含まれている可能性がある．
[MATH]    ,    [MATH]
この場合，前者(ドットが最左のもの)と後者(ドットが途中のもの)からの，記号[MATH]による遷移([MATH])を別に扱うことを考える．
例えば，前者を記号[MATH]による遷移，後者を記号[MATH]による遷移とし，[MATH]と[MATH]を別々に計算する．
このように変更したGOTOグラフでは，もはやLR項にドット左の記号数は必要ない．
ただし，ドットが最左であるか，途中であるかの区別は必要となる．
ドットが途中にある場合のLR項を，次のようなドット左方可変長のLR項で表すことにする．
[MATH]
記号[MATH]は，長さ1以上の記号列があることを表す．
このようなLR項を用いることで，ドット左方の記号列に関する情報がさらに抽象化され，GOTOグラフ作成時の状態数がさらに減少することが期待できる．
LR表生成アルゴリズムに必要な変更点は，以下の通りである．
(この変更を行った手法を提案法2とする．
)
[GOTO手続き]
[MATH]中の，ドットのすぐ右が[MATH]であるLR項[MATH]すべてに対し，LR項[MATH]を求め，そのクロージャを[MATH]の返り値とする．
また，LR項[MATH]に対し，LR項[MATH]を求め，そのクロージャを[MATH]の返り値とする．
[LR項集合の集合]
[MATH]の各LR項集合[MATH]，[MATH]のある記号[MATH]，[MATH]について，[MATH]を計算し，LR項集合[MATH]を求め，[MATH]に加える．
この手続きを，[MATH]に新たなLR項集合が加えられなくなるまで繰り返す．
[LR表の作成]
終端記号[MATH]と，[MATH]について，[MATH]ならば，[MATH]に[MATH]を加える．
非終端記号[MATH]，[MATH]について，[MATH]ならば，[MATH]に[MATH]を加える．
構文解析アルゴリズムに必要な変更は，以下の3点である．
shift動作とgoto時に，LR表の記述に従い，スタックに区切り記号を挿入する．
shift動作とgoto時に，shift/shiftコンフリクト，goto/gotoコンフリクトを扱えるようにする．
実装は，GLR法によるshift/reduceコンフリクト，shift/reduceコンフリクトの扱いと同様に，スタックを分岐させればよい．
reduce動作の際，従来の固定数ポップ動作の代わりに，スタックの最初の区切り記号までポップする．
[REF_sec:exp1]節で用いた3種類の文法から，提案法2を用いてLR表を作成した．
実験結果を表[REF_tbl:state]に示す．
LR表のサイズをさらに10 %程度縮小できることを確認した．
また，音声認識システムniNja[CITE]に提案法2の解析アルゴリズムを実装し，従来法と同じ解析結果が得られることを確認した．
本稿で提案するLR解析表の圧縮方法について，その原理と性質について述べる．
LR構文解析法は，LR表と，スタック，先読み語を参照し，次の動作を決定する．
LR表は，文法が与えられた時点であらかじめ計算できる構文解析過程を表したものである．
LR表の作成(付録.
A参照)には，構文解析中のある状態を表すデータ構造として，LR項(LR Item)を用いる．
LR項とは，ある生成規則(CFG規則)の右辺の記号列中のある位置にドット`・'を付けたデータ構造である．
ドットは，記号列のどの部分まで解析が進んだかを表す．
下記のLR(0)項は，生成規則[MATH]において，[MATH]の先頭部分列[MATH]まで解析が終了し，その後記号列[MATH]を解析する必要がある状態を表す．
[MATH]
[MATH]や[MATH]は空記号列の場合も含まれる．
例えば，生成規則[MATH]に対して，[MATH], [MATH], [MATH], [MATH]の4つのLR項が考えられる．
このように，従来のLR表で用いられるLR項は規則毎に作成され，LR項だけで解析中の規則とその解析位置，解析された記号列([MATH])およびこれから解析すべき記号列([MATH])を特定することができる．
一方，LR構文解析法では，解析途中の状態を表現するデータ構造として，解析済の(終端および非終端)記号を記憶する解析スタックが併用される(文脈自由言語を受理するプッシュダウン・オートマトンのスタックに相当する)．
上の例のLR項が表す状態では，解析スタックには，記号列[MATH]が，スタックトップから逆順に保持されているはずである．
例えば，LR項[MATH]が表す状態では，スタックは[MATH] (ただし，[MATH]は状態番号，スタックトップは右)となる．
したがって，すでに解析済の記号列は，LR項と解析スタックに重複して記載されており，冗長である．
そこで，LR項から冗長な解析済記号列[MATH]の記号情報を捨象することが可能となる．
ここで，捨象可能なのは，記号情報だけで，記号数の情報は保持する必要があることに注意されたい．
解析スタックには，解析済の記号がその記号が属する規則に関係なくフラットに保持される．
スタック[MATH]を見ただけでは，記号[MATH]が規則[MATH]，[MATH]，[MATH]のいずれに属する[MATH]なのか，区別することができない．
そこで，LR項が表す解析状態で，スタックトップからいくつの記号がこの規則で解析中かという情報を保持しなければならない．
以上のことから，従来のLR項のドットの左側の記号列を抽象化して，その記号の個数で置き換え，新しいLR項とする．
すなわち，次のようなLR項を用いる．
[MATH]
ここで，[MATH]は，記号列[MATH]の記号数を表すものとする．
このLR項を左方抽象化LR項と呼ぶことにする．
例えば，生成規則[MATH]に対して，[MATH], [MATH], [MATH], [MATH]の4つの左方抽象化LR項が考えられる．
LR表は，生成規則集合が与えられた時点で，そこから求められる構文解析時のあらゆる解析途中の状態を抽出し，また各状態間の遷移関係を求めて，状態遷移図(プッシュダウンオートマトン)として表現したものである．
ここで解析途中の状態は，LR項の集合(クロージャ)に対応し，規則適用の部分的解析結果(LR項に相当)の複数の可能性(集合)を表している．
この時，解析状態の同一性は，クロージャの同一性で判断される．
例えば，異なる解析パスから，同一のLR項集合が得られる場合，それらは同じ状態とみなすことができる．
クロージャの要素として，従来のLR項の代わりに，不必要な情報が捨象された左方抽象化LR項を用いると，より多くの解析状態(クロージャ)が同一の状態と見なされる．
したがって，結果として得られるLR表の状態数が減少し，表のサイズが縮小される．
これが提案手法の原理である．
LR表作成アルゴリズムは，従来のLR項の代わりに，上記の左方抽象化LR項を用いても，新たな処理を加えること無く若干の修正だけで適用できる．
以下では，LR表作成手順の[クロージャ] [GOTO手続き][LR項集合の集合][LR表の作成]の各手続き(付録.
A参照)，それぞれについて，修正手続きを示す．
(この手法を，提案法1と呼ぶ．
また提案法1によって作成されたLR表を圧縮LR表と呼ぶ．
)
[クロージャ]，[GOTO手続き]，[LR項集合の集合]では，LR項のドットの左側を参照する手続きが存在しないので，左方抽象化LR項を用いて，ほぼそのまま，「LR項集合の集合」を作成できる．
唯一，ドットの左側の生成・修正の手続きに若干の変更を加える．
具体的には，以下の2点を変更する．
[クロージャ]作成手続きのステップ2を次のように変更する．
[MATH]に左方抽象化LR項[MATH]があれば，左辺が[MATH]の全ての生成規則[MATH]について，LR項[MATH]を加える．
この手続きを新たなLR項が加えられなくなるまで繰り返す．
また，[GOTO手続き][MATH]を次のように変更する．
[MATH]中の，ドットのすぐ右が[MATH]である全てのLR項[MATH]に対し，LR項[MATH]を求め，そのクロージャを返す．
得られたLR項集合の集合から[LR表の作成]において，[MATH]表への[MATH]や[MATH]の書き込み，および[MATH]表の作成にも変更点はない．
一方，[MATH]動作の引数には，従来の生成規則の代わりに，生成記号の左辺記号と右辺記号列の記号数のペアを記述する．
すなわち，[LR表の作成]のreduce動作の書き込みを次のように変更する．
[MATH]にLR項[MATH]が存在するならば，[MATH]について，[MATH]に[MATH]を加える．
このように，修正手続きで作成されるLR表では，reduce動作の引数には生成規則のうち，左辺の記号列の記号情報を捨象した一部の情報しか記述されない．
しかし，この情報[MATH]と[MATH]さえあれば，どの生成規則が適用されたかは，構文解析時に特定可能である点に注意されたい．
左辺記号[MATH]と，解析スタックから[MATH]個の記号をポップすることで得られる記号列[MATH]から，[MATH]と復元可能である．
また，提案手法での修正箇所は，既存の表作成アルゴリズム中のある手続きを同等の手続きで置き換えただけであり，新たな手続きの呼び出しは行っていない．
したがって，従来の表作成アルゴリズムと同じ計算オーダで作成可能である．
日本語において，動詞の格を表す句は，語順が自由であり，任意に省略可能であることが多い．
次のような日本語を解析する文法(図[REF_fig:g_example])を考える．
太郎が花子にりんごを与える
花子に太郎がりんごを与える
りんごを太郎が花子に与える
太郎がりんごを与える
りんごを与える
与える
この文法から，従来の表作成アルゴリズムと，提案法による表作成アルゴリズムによってつくられたGOTOグラフの一部(記号`S'を左辺に持つ規則の集合に相当する部分)を，それぞれ図[REF_fig:goto]，図[REF_fig:r_goto]に示す．
従来法では，規則右辺に現れる記号列の文脈によって異なる状態が作成されるため，木の形に分岐したグラフが作成される．
一方提案法では，記号列の文脈によらずに後方部分がマージされたグラフが作成され，状態数が32から12へ大幅に減少することが分かる．
\leavevmode
提案法の効果と効率について，その性質を考察する．
LR項においてドットより左方の記号列が記号数へと抽象化されることにより，従来異なるLR項として認識された以下のような2つのLR項が，同一のLR項として認識されることになる．
[MATH]    ,    [MATH]
where [MATH]
これらから生成されるクロージャも同一のクロージャとなる．
すなわち，「LR項集合の集合」作成時に，従来異なる状態(LR項集合)となっていたものが，1つの状態にマージされることになる．
よって，最終的なLR表の状態数は減少する．
ここで，マージされるLR項が存在するための，文法[MATH]の必要条件を考察する．
上記の同一視される2つのLR項について，[MATH]と[MATH]以外は等しくなければならない．
また，[MATH]，すなわち[MATH]である必要がある．
以上をまとめると，文法[MATH]に，以下の条件を満たす規則のペア[MATH]，[MATH]が少なくとも一組以上存在する必要がある．
左辺記号[MATH]，[MATH]が等しい．
[MATH]と[MATH]の接尾記号列が一致する．
すなわち，[MATH]，[MATH]と書けるとき，[MATH]となる[MATH]が存在する．
[MATH]
このような規則のペアが，文法[MATH]中に多く存在するほど，提案法による状態数の削減の効果は大きい．
圧縮LR表を用いて構文解析を行った場合の効率について考える．
提案法は，すでに解析済の情報(ドットの左側の記号情報)だけを捨象する．
これから解析する部分(ドットの右側の記号情報)には手を加えない．
提案法によって状態の統合が行われた場合，統合後の状態(クロージャ)は以前の状態と同数のLR項を持ち，それぞれのLR項のこれから解析する部分(ドットの右側の記号情報)も等しい．
したがって，統合後もその後の解析の処理量は等しく，構文解析の効率は悪くならない．
[REF_ss:quality]節で述べたように，(1)規則左辺の記号が同じ，(2)右辺の接尾部分が共通，(3)右辺の記号数が同じ，の3条件を満たす規則の組が文法中に多く現れるほど，提案法の効果は大きい．
このうち，(3)右辺記号数の条件は，改善の余地がある．
本節では，この条件を克服するための拡張方法について述べる．
ドットの左側に記号数が必要なのは，reduce動作時にスタックからポップする要素数を記録するためである．
この要素数は，LR表にreduce動作の引数として，静的に記述される．
しかし，このポップ要素数は解析時に動的に求めることもできる．
そこで，図[REF_fig:stack]のように，この情報をスタックに保持することを考える．
すなわち，reduce動作の際，スタックに保持された区切り位置までポップするような構文解析アルゴリズムを考える．
このような区切りをスタックに入れるようなLR表はどのように生成すればよいだろうか．
区切りは，規則右辺の最初の記号をスタックに積む時に挿入すればよい．
すなわち，LR項
[MATH]
からGOTO手続きによって，LR項
[MATH]
を生成する際に，スタックに挿入すればよい．
ドットが最左にある場合の，次の状態への遷移(すなわち，shift動作やgoto)の場合に，スタックに区切りを挿入する．
注意すべきなのは，ある状態(クロージャ)に，ドットのすぐ右の記号が同じで，ドットが最左のものと規則途中にあるものの，2つ以上のLR項が含まれている場合があることである．
すなわち，次のような2つのLR項が，同じクロージャ[MATH]に含まれている可能性がある．
[MATH]    ,    [MATH]
この場合，前者(ドットが最左のもの)と後者(ドットが途中のもの)からの，記号[MATH]による遷移([MATH])を別に扱うことを考える．
例えば，前者を記号[MATH]による遷移，後者を記号[MATH]による遷移とし，[MATH]と[MATH]を別々に計算する．
このように変更したGOTOグラフでは，もはやLR項にドット左の記号数は必要ない．
ただし，ドットが最左であるか，途中であるかの区別は必要となる．
ドットが途中にある場合のLR項を，次のようなドット左方可変長のLR項で表すことにする．
[MATH]
記号[MATH]は，長さ1以上の記号列があることを表す．
このようなLR項を用いることで，ドット左方の記号列に関する情報がさらに抽象化され，GOTOグラフ作成時の状態数がさらに減少することが期待できる．
LR表生成アルゴリズムに必要な変更点は，以下の通りである．
(この変更を行った手法を提案法2とする．
)
[GOTO手続き]
[MATH]中の，ドットのすぐ右が[MATH]であるLR項[MATH]すべてに対し，LR項[MATH]を求め，そのクロージャを[MATH]の返り値とする．
また，LR項[MATH]に対し，LR項[MATH]を求め，そのクロージャを[MATH]の返り値とする．
[LR項集合の集合]
[MATH]の各LR項集合[MATH]，[MATH]のある記号[MATH]，[MATH]について，[MATH]を計算し，LR項集合[MATH]を求め，[MATH]に加える．
この手続きを，[MATH]に新たなLR項集合が加えられなくなるまで繰り返す．
[LR表の作成]
終端記号[MATH]と，[MATH]について，[MATH]ならば，[MATH]に[MATH]を加える．
非終端記号[MATH]，[MATH]について，[MATH]ならば，[MATH]に[MATH]を加える．
構文解析アルゴリズムに必要な変更は，以下の3点である．
shift動作とgoto時に，LR表の記述に従い，スタックに区切り記号を挿入する．
shift動作とgoto時に，shift/shiftコンフリクト，goto/gotoコンフリクトを扱えるようにする．
実装は，GLR法によるshift/reduceコンフリクト，shift/reduceコンフリクトの扱いと同様に，スタックを分岐させればよい．
reduce動作の際，従来の固定数ポップ動作の代わりに，スタックの最初の区切り記号までポップする．
[REF_sec:exp1]節で用いた3種類の文法から，提案法2を用いてLR表を作成した．
実験結果を表[REF_tbl:state]に示す．
LR表のサイズをさらに10 %程度縮小できることを確認した．
また，音声認識システムniNja[CITE]に提案法2の解析アルゴリズムを実装し，従来法と同じ解析結果が得られることを確認した．
