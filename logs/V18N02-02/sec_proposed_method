本研究では，文字列は特徴の集合で表現されると仮定する．
文字列の特徴の捉え方は，提案手法に依らず任意であるが，本論文では一貫して文字tri-gramを具体例として用いる．
例えば，文字列[MATH]は，9要素の文字tri-gramから構成される集合[MATH]で表現される．
ここで，文字列の先頭と末尾に`＄'を挿入し，文字列の開始と終了を表現している．
一般に，文字数が[MATH]の文字列[MATH]を文字[MATH]-gramの集合[MATH]で表現したとき，[MATH]という関係が成り立つ．
本論文では，文字列を小文字の変数（[MATH]など）で表し，文字列を特徴の集合に変換したものを特徴集合と呼び，対応する大文字の変数（[MATH]など）で表す．
[MATH]を文字列[MATH]の長さ，[MATH]を文字列[MATH]のサイズと呼び，これらを区別する．
なお，特徴に頻度などの重みが付くときは，特徴の識別子を分割することで，重み付きの集合を模擬する．
例えば，文字列「トラトラトラ」を文字tri-gramで表現するとき，`トラト'と`ラトラ'が2回ずつ出現する．
これを集合で表現するには，tri-gramの末尾に出現回数を表す番号を付加すれば良い．
これにより「トラトラトラ」は，{`＄＄ト'#1, `＄トラ'#1, `トラト'#1, `ラトラ'#1, `トラト'#2, `ラトラ'#2, `トラ＄'#1, `ラ＄＄'#1 }という集合で表現できる．
特徴に出現回数を付与することは実用上重要であるが，説明が冗長になるため，以降では省略する．
本論文では，ダイス係数，ジャッカード係数，コサイン係数，オーバーラップ係数など，集合間のオーバーラップに基づく類似度（集合間類似度）に対して，類似文字列検索アルゴリズムを導出する．
文字列の特徴と類似度関数は，類似文字列検索の精度を左右するので，アプリケーションに応じて慎重に選択する必要がある．
しかし，どのくらいの精度の類似度関数が必要になるかはアプリケーション依存であるため，文字列の特徴や類似度関数の選び方は本論文の対象外とし，与えられた特徴空間と類似度関数に対して，出来るだけ効率よく[MATH]を求めるアルゴリズムを提案することに注力する．
精細な類似度が必要な場合は，適当な類似度関数に対して緩い閾値[MATH]を用い，提案手法で再現率が高くなるように類似文字列を検索し，関連研究（第[REF_sec:related-work]節）で紹介する手法などで精査することで，適合率を改善すればよい．
さて，文字列[MATH]と[MATH]を，それぞれ特徴集合[MATH]と[MATH]で表すとき，[MATH]と[MATH]のコサイン係数は，
この定義式を式[REF_equ:approximate-string-retrieval]に代入すると，類似文字列のための必要十分条件が得られる．
ここで，[MATH]は[MATH]の整数値への切り上げを表す．
また，式[REF_equ:match-condition]には，[MATH]の上限値[MATH]を不等式として組み込んだ．
式[REF_equ:match-condition]は，特徴集合[MATH]と[MATH]のコサイン係数が[MATH]以上になるためには，少なくても[MATH]個の要素を共通に持つ必要があることを示している．
必要十分条件において，[MATH]が取るべき最小の値を，[MATH]と[MATH]の最小オーバーラップ数と呼び，以降この数を[MATH]で表す．
[MATH]は，[MATH]，[MATH]，[MATH]に依存して計算される値である．
ところで，式[REF_equ:match-condition]において[MATH]を無視すると，[MATH]と[MATH]に関する不等式を得る．
この不等式を[MATH]について解くと，類似文字列の必要条件が得られる．
ここで，[MATH]は[MATH]の整数値への切り捨てを表す．
この不等式は，[MATH]に対して類似文字列検索を行う際の，[MATH]に関する探索範囲を表現している．
言い換えれば，特徴集合の要素数がこの範囲外の文字列は，無視できる．
なお，同様の導出は，ダイス係数，ジャッカード係数，オーバーラップ係数などの類似度関数に対しても可能である．
表[REF_tbl:conditions]に，それぞれの類似度関数の条件式をまとめた．
これらの条件式の大元の出典は不明であるが，本論文で導出した条件式は，いくつかの先行研究でも用いられている[CITE]．
ここで，導出した不等式の利用例を説明する．
検索クエリ文字列[MATH]とし，コサイン類似度の閾値[MATH]で類似文字列検索を行う．
また，文字列の特徴を文字tri-gramで表現することとする（したがって，[MATH]である）．
式[REF_equ:necessary-condition]から，[MATH]の要素数に関する探索範囲は[MATH]である．
この範囲内で，例えば[MATH]となる文字列を考慮しているとき，式[REF_equ:match-condition]から，類似文字列の必要十分条件，[MATH]が得られる．
この必要十分条件は，[MATH]のtri-gramのうち，少なくても6個は[MATH]にも出現しなければならないことを表す．
例えば，[MATH]を考えると，[MATH]である．
したがって，[MATH]は類似文字列検索の解の1つである．
実際，[MATH]と[MATH]のコサイン類似度は，[MATH] ([MATH])である．
以上のことをまとめると，種々の類似度関数を用いた類似文字列検索は，次のような一般的な手順で実装することができる．
与えられた検索文字列[MATH]と類似度閾値[MATH]から，[MATH]の範囲を求める
その範囲内で，[MATH]の条件を満たす[MATH]を見つける
次節では，これらの手順を効率良く実装するデータ構造とアルゴリズムを議論する．
前節までの議論により，類似文字列検索は次の部分問題を解くことに帰着される．
[[MATH]オーバーラップ問題]検索クエリ文字列の特徴集合[MATH]が与えられたとき，その特徴を[MATH]個以上共有する文字列[MATH]を全て見つける．
ここで，[MATH]は[MATH]と[MATH]の最小オーバーラップ数で，コサイン係数を類似度関数として用いる場合は，[MATH]である．
この部分問題を効率的に解くため，特徴をキーとして，その特徴を含む文字列のリストを値とする連想配列（転置インデックス）を構築する．
式[REF_equ:match-condition]から，探索すべき文字列のサイズ[MATH]の範囲が絞り込まれること，式[REF_equ:necessary-condition]から，[MATH]に依存して最小オーバーラップ数[MATH]が決まることを考慮し，文字列のサイズ[MATH]毎に転置インデックス[MATH]を構築する．
また，アルゴリズムを効率よく実行するため，文字列をユニークな文字列識別番号(SID)で表現し，転置リストは特徴を含む文字列のSIDを昇順に並べたものを格納することとする．
図[REF_fig:data-structure]に，データ構造の実現例を示した．
例えば，`＄＄ス'を特徴に持つ文字列のSIDは，#267, #452, #743, #2389, .
..
であり，「スパゲッティー」のSIDは#452である．
図[REF_fig:data-structure]では，文字列のサイズ毎にハッシュ表を構築しているが，SQLなどの関係データベースを用いても，同様のデータ構造が実現できる．
図[REF_alg:approximate-string-matching]に，類似文字列検索の擬似コードを示す．
文字列のサイズ[MATH]毎に構成された転置インデックスの配列[MATH]に対して，検索文字列[MATH]，類似度閾値[MATH]が与えられると，この擬似コードは[MATH]との類似度が[MATH]以上の文字列のSIDのリスト[MATH]を返す．
1〜3行目で，クエリ文字列[MATH]を特徴集合[MATH]に変換し，考慮すべき文字列のサイズの範囲を表[REF_tbl:conditions]から求める．
探索範囲内のそれぞれの長さ[MATH]に対し（5行目），最小オーバーラップ数[MATH]を求め（6行目），overlap_join関数で[MATH]オーバーラップ問題を解き，解集合[MATH]を更新する（7行目）．
[REF_sec:data-structure]節では，特徴をキーとして，その特徴を含む文字列(SID)のリストを返す転置インデックスを構築した．
特徴[MATH]の転置リストに含まれている文字列は，特徴[MATH]を含むことが保証されている．
したがって，特徴[MATH]に対応する[MATH]個の転置リストの中で，ある文字列[MATH]が[MATH]個の転置リスト2回出現するならば，[MATH]である．
ゆえに，転置リスト上において[MATH]回以上出現するSIDを見つけることで，[MATH]オーバーラップ問題を解くことができる．
図[REF_alg:t-overlap-naive]に，このアイディアに基づく[MATH]オーバーラップ問題の解法（AllScanアルゴリズム）を示した．
4行目の関数[MATH]は，転置インデックス[MATH]の中で特徴[MATH]に対応する転置リスト（SIDのリスト）を返す関数である．
この擬似コードは，転置インデックス[MATH]，特徴集合[MATH]，最小オーバーラップ数[MATH]を受け取り，SIDの出現頻度，すなわち[MATH]を連想配列[MATH]に格納し，その値が[MATH]に到達したSIDをリスト[MATH]に入れて返すものである．
表[REF_tbl:spaghetti-solutions]は，検索クエリ文字列[MATH]に対して，Web日本語Nグラムコーパスのユニグラムの中で，文字数が7（つまり[MATH]）の文字列を実際に検索するとき，[MATH]の高い文字列10件を示したものである（文字列の特徴はtri-gramで表現）．
コサイン係数が0.7以上の文字列を探すには，[MATH]であるから，類似文字列検索の解は「スパッゲティー」「スパゲティーニ」「スパゲティー・」「スパゲッティー」の4つである．
AllScanアルゴリズムの実装は簡単であるが，検索に用いる特徴が数多くの文字列に出現するとき，走査するSIDの数が非常に大きくなるという欠点がある．
例えば，`ティー'（「ティー」を含む）や`ー＄＄'（「ー」で終わる）などの文字tri-gramは，日本語の多くの語で出現するため，転置リストが大きくなる傾向にある．
表[REF_tbl:spaghetti-stat]に，Web日本語Nグラムコーパスにおいて，「スパゲティー」の各tri-gramの転置リストのサイズ（すなわち，各tri-gramを含む文字列の数）を示した．
この表によると，AllScanアルゴリズムは30,584種類，35,964個のSIDを走査することになるが，その中でたった4個(0.013%)しか解にならない．
走査すべきSIDの数を減らすため，[MATH]オーバーラップ問題に関する次の性質に着目する[CITE]．
要素数が[MATH]の集合[MATH]と，要素数が任意の集合[MATH]がある．
要素数が[MATH]となる任意の部分集合[MATH]を考える．
もし，[MATH]ならば，[MATH]である．
この性質は，その対偶を考えれば明白である．
すなわち，[MATH]ならば，[MATH]の定義から[MATH]であるので，[MATH]．
ゆえに，[MATH]が示される．
性質[REF_prop:signature]の利用例を，先の類似文字列検索を用いて説明する．
検索クエリ文字列[MATH]に対し，[MATH]かつ，[MATH]という条件を満たす文字列[MATH]を検索している．
検索される文字列[MATH]が[MATH]を満たすならば，特徴集合[MATH]中の任意の[MATH]要素で構成された任意の部分集合[MATH]に対し，[MATH]である．
言い換えれば，特徴集合[MATH]中の任意の3要素を選ぶと，対応する転置リストに，類似文字列検索の解が（あるとすれば）必ず含まれている．
この性質を用いると，類似文字列検索の解の候補を絞り込むことができる．
解候補を生成するために用いる要素は，シグニチャ[CITE]と呼ばれる．
では，検索文字列の特徴集合の中で，どの要素をシグニチャとして採用すれば良いのだろうか？シグニチャの特徴数は性質[REF_prop:signature]から決定されるが，その選び方は任意である．
したがって，転置リストのサイズが小さい特徴をシグニチャとして採用すれば，解候補生成時に走査するSIDの数を減らすことができる．
すなわち，文字列データベース中で稀に出現するtri-gramを優先的にシグニチャとして採用し，解の候補を絞り込めばよい．
表[REF_tbl:spaghetti-stat]の例では，「パゲテ」「ゲティ」「スパゲ」をシグニチャとして選択することになる．
シグニチャによる解候補生成を採用したアルゴリズムを，図[REF_alg:t-overlap-cpmerge]に示す．
性質[REF_prop:signature]より，特徴集合[MATH]を，要素数[MATH]のシグニチャ[MATH]と，残り[MATH] [MATH]に分解する．
このアルゴリズムは，2から7行目で類似文字列検索の解候補をシグニチャ[MATH]から獲得し，8行目から21行目で解候補の検証と枝刈りを[MATH]で行う．
このアルゴリズムは，解候補の生成と枝刈りをしながら転置リストをマージしていくので，CPMergeアルゴリズムと命名した．
1行目で，検索文字列の特徴集合の要素を，転置リストのサイズ（要素数）の昇順に並び替える．
このとき，[MATH]の転置リストの内容をすべてメモリに読み込まなくても，[MATH]の値を取得し，[MATH]の要素を並び替えられるようにしておくことは，実用上重要である（この理由は[REF_sect:cpmerge-stat]節で明らかになる）．
特徴集合[MATH]の要素を並び替えたとき，稀な特徴の順番に[MATH]とアクセスできるものとする．
シグニチャ[MATH]として採用されるのは，[MATH]である．
アルゴリズムの2から7行目では，シグニチャの特徴を持つ文字列をデータベース[MATH]から検索し，その転置リストにおける出現回数を連想配列[MATH]に記録する．
先の例と同じ類似文字列検索（[MATH]，[MATH]，[MATH]）に対して，CPMergeアルゴリズムの動作例を表[REF_tbl:spaghetti-process]に示した．
候補生成フェーズでは，「パゲテ」「ゲティ」「スパゲ」のtri-gramを含む文字列を検索し，検索された文字列を解候補とするとともに，該当する箇所に「○」を記している．
シグニチャから獲得される解候補の数は32で，AllScanアルゴリズムと比べると，解候補数を0.105%まで絞り込んだことになる．
アルゴリズムの9行目から21行目では，それぞれの候補文字列が，残りの特徴[MATH]を持っているかどうかを調べる．
それぞれの解候補[MATH]が（10行目），特徴[MATH]を持っているかどうかを，転置リスト[MATH]上における二分探索で調べ（11行目），転置リストが[MATH]を含んでいれば，頻度カウンタをインクリメントする（12行目）．
もし，頻度カウントが[MATH]に到達したら（14行目），[MATH]を結果リスト[MATH]に追加し（15行目），候補[MATH]から削除する（16行目）．
もし，頻度カウントが[MATH]に到達していない場合は，以下の性質を利用して枝刈りの可能性を調べる．
要素数が[MATH]の集合[MATH]と，要素数が任意の集合[MATH]がある．
要素数が[MATH]のある部分集合[MATH]を考える．
もし，[MATH]ならば，[MATH]である．
[MATH]の定義により[MATH]であるから，[MATH]．
したがって，この性質は[MATH]の上限値が[MATH]になることを表現している．
図[REF_alg:t-overlap-cpmerge]のアルゴリズムでは，[MATH]，[MATH]，[MATH]とおき，[MATH]の上限値を[MATH]と計算し，この値が[MATH]を下回っているならば（17行目），候補[MATH]を枝刈りする（18行目）．
表[REF_tbl:spaghetti-process]は，検証フェーズ([MATH])の動作例も示している．
[MATH]では，32個の候補文字列のそれぞれに対して，414個のSIDを含む転置リスト上で二分探索を行い，「＄スパ」というtri-gramを含むかどうか調べている．
候補文字列が特徴を含む場合は「○」，含まない場合は「×」が記される．
もし，候補文字列が「＄スパ」というtri-gramを含んでおらず，これまでの出現頻度が1回だった場合は，今後[MATH]の全ての転置リストに出現しても，出現頻度の最大値は5に留まる．
つまり，[MATH]となることが確定しているので，「アニスパゲス」「イカスバゲティ」などの文字列は，[MATH]において枝刈りする．
表[REF_tbl:spaghetti-process]では，枝刈りされる候補に「×.
」を記している．
枝刈りにより，[MATH]において15個の解候補が枝刈りされ，候補は17文字列に減る．
[MATH]でも同様の処理を行い，解の候補はそれぞれ8個，5個まで絞り込まれる．
[MATH]では，「スパゲティー・」と「スパゲティーニ」の出現回数が6に到達するので，候補集合から解集合に移動させる（\scalebox{1.7}{[MATH]}.
で表示）．
[MATH]では，「スパゲッティー」と「スパッゲティー」の出現回数が6に到達し，全ての候補の検証が終了したことになる．
CPMergeアルゴリズムにおいて，[MATH]の転置リストを処理した後に残る解候補の数を[MATH]，[MATH]の転置リストの要素数を[MATH]とする．
CPMergeの検証フェーズでは，それぞれの候補に対して二分探索を行うため，9行目の各[MATH]に対して，10〜20行目の計算量は[MATH]である．
[MATH]の並び順の定義から，[MATH]が大きくなると[MATH]も増加するが，枝刈りが有効に働けば，[MATH]が小さくなる．
表[REF_tbl:spaghetti-process]の例では，各[MATH]に対して[MATH]の値は，193 ([MATH])，115 ([MATH])，57.5 ([MATH])，45.1 ([MATH])，20.2 ([MATH])であり，9〜21行目のループが進むにつれて，計算量の見積りが減少する．
検索クエリ文字列やデータベースの文字列集合のtri-gramの分布により，[MATH]や[MATH]の傾向が異なるので，計算量の見積りを一般的に行うことは難しい．
そこで，第[REF_sec:evaluation]節では，CPMergeアルゴリズムが実際のデータセットに対して動作する際の，解の候補数，転置リストに含まれるSIDの数などの統計情報を報告する．
図[REF_alg:t-overlap-cpmerge]のアルゴリズムでは，SIDをキーとして頻度を格納する連想配列[MATH]を用いていた．
実は，転置リストが整列済みのSIDで構成されるという性質を利用すれば，情報検索における転置リストのマージ[CITE]と同様に，連想配列をリスト構造（可変長配列）で代用できる．
主要なプログラミング言語では連想配列を容易に扱えるが，アクセスのコストがリスト構造よりも大きいので，連想配列をリスト構造で置き換えることで，検索処理の高速化が期待できる．
図[REF_alg:t-overlap-cpmerge-post]は，図[REF_alg:t-overlap-cpmerge]から連想配列を排除し，リスト構造のみでCPMergeアルゴリズムを実装するもの(CPMerge-opt)である．
図[REF_alg:t-overlap-cpmerge-post]の2〜21行目は，図[REF_alg:t-overlap-cpmerge]の2〜7行目に対応し，解の候補生成を行う．
2行目では，解候補の頻度を計測する変数[MATH]を初期化しているが，その型は連想配列([MATH])から，可変長配列([MATH])に変更されている．
CPMerge-optでは，[MATH]の要素は[MATH]のタプルであり，要素はSIDの昇順に並べる．
3〜21行目の基本的な流れは，[MATH]における解候補リスト[MATH]と，[MATH]の転置リストを，先頭から順に比較していき，一時変数[MATH]に[MATH]における解候補リストを作成する．
最後に，[MATH]を[MATH]で上書きし（20行目），[MATH]のステップへと進む．
各[MATH]において，[MATH]を空のリストで初期化し（4行目），[MATH]と[MATH]でこれから処理する要素の位置（インデックス）を管理する変数[MATH]と[MATH]を，それぞれ[MATH]で初期化する（6行目）．
7行目から19行目までは，[MATH]と[MATH]の全ての要素を処理し終わるまで，以下の処理を繰り返す．
もし転置リスト[MATH]のSID ([MATH])が，[MATH]における解候補リスト[MATH]に含まれていない場合（8行目），[MATH]を新しい候補として[MATH]に登録し（9行目），[MATH]をインクリメントする（10行目）．
もし，[MATH]における解候補リスト[MATH]中のSID ([MATH])が，転置リスト[MATH]に含まれていない場合（11行目），[MATH]を[MATH]にそのまま追加し（12行目），[MATH]をインクリメントする（13行目）．
それ以外の場合，すなわち転置リスト[MATH]の要素[MATH]と解候補リスト[MATH]中の[MATH]が等しい場合（14行目），[MATH]の頻度をインクリメントしたものを[MATH]に追加し（15行目），[MATH]と[MATH]の両方をインクリメントする（16行目）．
図[REF_alg:t-overlap-cpmerge-post]の22〜36行目は，図[REF_alg:t-overlap-cpmerge]の8〜21行目に対応し，解の候補の検証と枝刈りを行っている．
CPMerge-optでは，[MATH]における解候補リスト[MATH]に対して，転置リスト[MATH]で検証を行い，枝刈りされなかった候補を一時変数[MATH]に待避し，[MATH]における処理が終わったら[MATH]を[MATH]で上書きしている．
図[REF_alg:t-overlap-cpmerge]と図[REF_alg:t-overlap-cpmerge-post]のその他の箇所は，ほとんど同じである．
本研究では，文字列は特徴の集合で表現されると仮定する．
文字列の特徴の捉え方は，提案手法に依らず任意であるが，本論文では一貫して文字tri-gramを具体例として用いる．
例えば，文字列[MATH]は，9要素の文字tri-gramから構成される集合[MATH]で表現される．
ここで，文字列の先頭と末尾に`＄'を挿入し，文字列の開始と終了を表現している．
一般に，文字数が[MATH]の文字列[MATH]を文字[MATH]-gramの集合[MATH]で表現したとき，[MATH]という関係が成り立つ．
本論文では，文字列を小文字の変数（[MATH]など）で表し，文字列を特徴の集合に変換したものを特徴集合と呼び，対応する大文字の変数（[MATH]など）で表す．
[MATH]を文字列[MATH]の長さ，[MATH]を文字列[MATH]のサイズと呼び，これらを区別する．
なお，特徴に頻度などの重みが付くときは，特徴の識別子を分割することで，重み付きの集合を模擬する．
例えば，文字列「トラトラトラ」を文字tri-gramで表現するとき，`トラト'と`ラトラ'が2回ずつ出現する．
これを集合で表現するには，tri-gramの末尾に出現回数を表す番号を付加すれば良い．
これにより「トラトラトラ」は，{`＄＄ト'#1, `＄トラ'#1, `トラト'#1, `ラトラ'#1, `トラト'#2, `ラトラ'#2, `トラ＄'#1, `ラ＄＄'#1 }という集合で表現できる．
特徴に出現回数を付与することは実用上重要であるが，説明が冗長になるため，以降では省略する．
本論文では，ダイス係数，ジャッカード係数，コサイン係数，オーバーラップ係数など，集合間のオーバーラップに基づく類似度（集合間類似度）に対して，類似文字列検索アルゴリズムを導出する．
文字列の特徴と類似度関数は，類似文字列検索の精度を左右するので，アプリケーションに応じて慎重に選択する必要がある．
しかし，どのくらいの精度の類似度関数が必要になるかはアプリケーション依存であるため，文字列の特徴や類似度関数の選び方は本論文の対象外とし，与えられた特徴空間と類似度関数に対して，出来るだけ効率よく[MATH]を求めるアルゴリズムを提案することに注力する．
精細な類似度が必要な場合は，適当な類似度関数に対して緩い閾値[MATH]を用い，提案手法で再現率が高くなるように類似文字列を検索し，関連研究（第[REF_sec:related-work]節）で紹介する手法などで精査することで，適合率を改善すればよい．
さて，文字列[MATH]と[MATH]を，それぞれ特徴集合[MATH]と[MATH]で表すとき，[MATH]と[MATH]のコサイン係数は，
この定義式を式[REF_equ:approximate-string-retrieval]に代入すると，類似文字列のための必要十分条件が得られる．
ここで，[MATH]は[MATH]の整数値への切り上げを表す．
また，式[REF_equ:match-condition]には，[MATH]の上限値[MATH]を不等式として組み込んだ．
式[REF_equ:match-condition]は，特徴集合[MATH]と[MATH]のコサイン係数が[MATH]以上になるためには，少なくても[MATH]個の要素を共通に持つ必要があることを示している．
必要十分条件において，[MATH]が取るべき最小の値を，[MATH]と[MATH]の最小オーバーラップ数と呼び，以降この数を[MATH]で表す．
[MATH]は，[MATH]，[MATH]，[MATH]に依存して計算される値である．
ところで，式[REF_equ:match-condition]において[MATH]を無視すると，[MATH]と[MATH]に関する不等式を得る．
この不等式を[MATH]について解くと，類似文字列の必要条件が得られる．
ここで，[MATH]は[MATH]の整数値への切り捨てを表す．
この不等式は，[MATH]に対して類似文字列検索を行う際の，[MATH]に関する探索範囲を表現している．
言い換えれば，特徴集合の要素数がこの範囲外の文字列は，無視できる．
なお，同様の導出は，ダイス係数，ジャッカード係数，オーバーラップ係数などの類似度関数に対しても可能である．
表[REF_tbl:conditions]に，それぞれの類似度関数の条件式をまとめた．
これらの条件式の大元の出典は不明であるが，本論文で導出した条件式は，いくつかの先行研究でも用いられている[CITE]．
ここで，導出した不等式の利用例を説明する．
検索クエリ文字列[MATH]とし，コサイン類似度の閾値[MATH]で類似文字列検索を行う．
また，文字列の特徴を文字tri-gramで表現することとする（したがって，[MATH]である）．
式[REF_equ:necessary-condition]から，[MATH]の要素数に関する探索範囲は[MATH]である．
この範囲内で，例えば[MATH]となる文字列を考慮しているとき，式[REF_equ:match-condition]から，類似文字列の必要十分条件，[MATH]が得られる．
この必要十分条件は，[MATH]のtri-gramのうち，少なくても6個は[MATH]にも出現しなければならないことを表す．
例えば，[MATH]を考えると，[MATH]である．
したがって，[MATH]は類似文字列検索の解の1つである．
実際，[MATH]と[MATH]のコサイン類似度は，[MATH] ([MATH])である．
以上のことをまとめると，種々の類似度関数を用いた類似文字列検索は，次のような一般的な手順で実装することができる．
与えられた検索文字列[MATH]と類似度閾値[MATH]から，[MATH]の範囲を求める
その範囲内で，[MATH]の条件を満たす[MATH]を見つける
次節では，これらの手順を効率良く実装するデータ構造とアルゴリズムを議論する．
前節までの議論により，類似文字列検索は次の部分問題を解くことに帰着される．
[[MATH]オーバーラップ問題]検索クエリ文字列の特徴集合[MATH]が与えられたとき，その特徴を[MATH]個以上共有する文字列[MATH]を全て見つける．
ここで，[MATH]は[MATH]と[MATH]の最小オーバーラップ数で，コサイン係数を類似度関数として用いる場合は，[MATH]である．
この部分問題を効率的に解くため，特徴をキーとして，その特徴を含む文字列のリストを値とする連想配列（転置インデックス）を構築する．
式[REF_equ:match-condition]から，探索すべき文字列のサイズ[MATH]の範囲が絞り込まれること，式[REF_equ:necessary-condition]から，[MATH]に依存して最小オーバーラップ数[MATH]が決まることを考慮し，文字列のサイズ[MATH]毎に転置インデックス[MATH]を構築する．
また，アルゴリズムを効率よく実行するため，文字列をユニークな文字列識別番号(SID)で表現し，転置リストは特徴を含む文字列のSIDを昇順に並べたものを格納することとする．
図[REF_fig:data-structure]に，データ構造の実現例を示した．
例えば，`＄＄ス'を特徴に持つ文字列のSIDは，#267, #452, #743, #2389, .
..
であり，「スパゲッティー」のSIDは#452である．
図[REF_fig:data-structure]では，文字列のサイズ毎にハッシュ表を構築しているが，SQLなどの関係データベースを用いても，同様のデータ構造が実現できる．
図[REF_alg:approximate-string-matching]に，類似文字列検索の擬似コードを示す．
文字列のサイズ[MATH]毎に構成された転置インデックスの配列[MATH]に対して，検索文字列[MATH]，類似度閾値[MATH]が与えられると，この擬似コードは[MATH]との類似度が[MATH]以上の文字列のSIDのリスト[MATH]を返す．
1〜3行目で，クエリ文字列[MATH]を特徴集合[MATH]に変換し，考慮すべき文字列のサイズの範囲を表[REF_tbl:conditions]から求める．
探索範囲内のそれぞれの長さ[MATH]に対し（5行目），最小オーバーラップ数[MATH]を求め（6行目），overlap_join関数で[MATH]オーバーラップ問題を解き，解集合[MATH]を更新する（7行目）．
[REF_sec:data-structure]節では，特徴をキーとして，その特徴を含む文字列(SID)のリストを返す転置インデックスを構築した．
特徴[MATH]の転置リストに含まれている文字列は，特徴[MATH]を含むことが保証されている．
したがって，特徴[MATH]に対応する[MATH]個の転置リストの中で，ある文字列[MATH]が[MATH]個の転置リスト2回出現するならば，[MATH]である．
ゆえに，転置リスト上において[MATH]回以上出現するSIDを見つけることで，[MATH]オーバーラップ問題を解くことができる．
図[REF_alg:t-overlap-naive]に，このアイディアに基づく[MATH]オーバーラップ問題の解法（AllScanアルゴリズム）を示した．
4行目の関数[MATH]は，転置インデックス[MATH]の中で特徴[MATH]に対応する転置リスト（SIDのリスト）を返す関数である．
この擬似コードは，転置インデックス[MATH]，特徴集合[MATH]，最小オーバーラップ数[MATH]を受け取り，SIDの出現頻度，すなわち[MATH]を連想配列[MATH]に格納し，その値が[MATH]に到達したSIDをリスト[MATH]に入れて返すものである．
表[REF_tbl:spaghetti-solutions]は，検索クエリ文字列[MATH]に対して，Web日本語Nグラムコーパスのユニグラムの中で，文字数が7（つまり[MATH]）の文字列を実際に検索するとき，[MATH]の高い文字列10件を示したものである（文字列の特徴はtri-gramで表現）．
コサイン係数が0.7以上の文字列を探すには，[MATH]であるから，類似文字列検索の解は「スパッゲティー」「スパゲティーニ」「スパゲティー・」「スパゲッティー」の4つである．
AllScanアルゴリズムの実装は簡単であるが，検索に用いる特徴が数多くの文字列に出現するとき，走査するSIDの数が非常に大きくなるという欠点がある．
例えば，`ティー'（「ティー」を含む）や`ー＄＄'（「ー」で終わる）などの文字tri-gramは，日本語の多くの語で出現するため，転置リストが大きくなる傾向にある．
表[REF_tbl:spaghetti-stat]に，Web日本語Nグラムコーパスにおいて，「スパゲティー」の各tri-gramの転置リストのサイズ（すなわち，各tri-gramを含む文字列の数）を示した．
この表によると，AllScanアルゴリズムは30,584種類，35,964個のSIDを走査することになるが，その中でたった4個(0.013%)しか解にならない．
走査すべきSIDの数を減らすため，[MATH]オーバーラップ問題に関する次の性質に着目する[CITE]．
要素数が[MATH]の集合[MATH]と，要素数が任意の集合[MATH]がある．
要素数が[MATH]となる任意の部分集合[MATH]を考える．
もし，[MATH]ならば，[MATH]である．
この性質は，その対偶を考えれば明白である．
すなわち，[MATH]ならば，[MATH]の定義から[MATH]であるので，[MATH]．
ゆえに，[MATH]が示される．
性質[REF_prop:signature]の利用例を，先の類似文字列検索を用いて説明する．
検索クエリ文字列[MATH]に対し，[MATH]かつ，[MATH]という条件を満たす文字列[MATH]を検索している．
検索される文字列[MATH]が[MATH]を満たすならば，特徴集合[MATH]中の任意の[MATH]要素で構成された任意の部分集合[MATH]に対し，[MATH]である．
言い換えれば，特徴集合[MATH]中の任意の3要素を選ぶと，対応する転置リストに，類似文字列検索の解が（あるとすれば）必ず含まれている．
この性質を用いると，類似文字列検索の解の候補を絞り込むことができる．
解候補を生成するために用いる要素は，シグニチャ[CITE]と呼ばれる．
では，検索文字列の特徴集合の中で，どの要素をシグニチャとして採用すれば良いのだろうか？シグニチャの特徴数は性質[REF_prop:signature]から決定されるが，その選び方は任意である．
したがって，転置リストのサイズが小さい特徴をシグニチャとして採用すれば，解候補生成時に走査するSIDの数を減らすことができる．
すなわち，文字列データベース中で稀に出現するtri-gramを優先的にシグニチャとして採用し，解の候補を絞り込めばよい．
表[REF_tbl:spaghetti-stat]の例では，「パゲテ」「ゲティ」「スパゲ」をシグニチャとして選択することになる．
シグニチャによる解候補生成を採用したアルゴリズムを，図[REF_alg:t-overlap-cpmerge]に示す．
性質[REF_prop:signature]より，特徴集合[MATH]を，要素数[MATH]のシグニチャ[MATH]と，残り[MATH] [MATH]に分解する．
このアルゴリズムは，2から7行目で類似文字列検索の解候補をシグニチャ[MATH]から獲得し，8行目から21行目で解候補の検証と枝刈りを[MATH]で行う．
このアルゴリズムは，解候補の生成と枝刈りをしながら転置リストをマージしていくので，CPMergeアルゴリズムと命名した．
1行目で，検索文字列の特徴集合の要素を，転置リストのサイズ（要素数）の昇順に並び替える．
このとき，[MATH]の転置リストの内容をすべてメモリに読み込まなくても，[MATH]の値を取得し，[MATH]の要素を並び替えられるようにしておくことは，実用上重要である（この理由は[REF_sect:cpmerge-stat]節で明らかになる）．
特徴集合[MATH]の要素を並び替えたとき，稀な特徴の順番に[MATH]とアクセスできるものとする．
シグニチャ[MATH]として採用されるのは，[MATH]である．
アルゴリズムの2から7行目では，シグニチャの特徴を持つ文字列をデータベース[MATH]から検索し，その転置リストにおける出現回数を連想配列[MATH]に記録する．
先の例と同じ類似文字列検索（[MATH]，[MATH]，[MATH]）に対して，CPMergeアルゴリズムの動作例を表[REF_tbl:spaghetti-process]に示した．
候補生成フェーズでは，「パゲテ」「ゲティ」「スパゲ」のtri-gramを含む文字列を検索し，検索された文字列を解候補とするとともに，該当する箇所に「○」を記している．
シグニチャから獲得される解候補の数は32で，AllScanアルゴリズムと比べると，解候補数を0.105%まで絞り込んだことになる．
アルゴリズムの9行目から21行目では，それぞれの候補文字列が，残りの特徴[MATH]を持っているかどうかを調べる．
それぞれの解候補[MATH]が（10行目），特徴[MATH]を持っているかどうかを，転置リスト[MATH]上における二分探索で調べ（11行目），転置リストが[MATH]を含んでいれば，頻度カウンタをインクリメントする（12行目）．
もし，頻度カウントが[MATH]に到達したら（14行目），[MATH]を結果リスト[MATH]に追加し（15行目），候補[MATH]から削除する（16行目）．
もし，頻度カウントが[MATH]に到達していない場合は，以下の性質を利用して枝刈りの可能性を調べる．
要素数が[MATH]の集合[MATH]と，要素数が任意の集合[MATH]がある．
要素数が[MATH]のある部分集合[MATH]を考える．
もし，[MATH]ならば，[MATH]である．
[MATH]の定義により[MATH]であるから，[MATH]．
したがって，この性質は[MATH]の上限値が[MATH]になることを表現している．
図[REF_alg:t-overlap-cpmerge]のアルゴリズムでは，[MATH]，[MATH]，[MATH]とおき，[MATH]の上限値を[MATH]と計算し，この値が[MATH]を下回っているならば（17行目），候補[MATH]を枝刈りする（18行目）．
表[REF_tbl:spaghetti-process]は，検証フェーズ([MATH])の動作例も示している．
[MATH]では，32個の候補文字列のそれぞれに対して，414個のSIDを含む転置リスト上で二分探索を行い，「＄スパ」というtri-gramを含むかどうか調べている．
候補文字列が特徴を含む場合は「○」，含まない場合は「×」が記される．
もし，候補文字列が「＄スパ」というtri-gramを含んでおらず，これまでの出現頻度が1回だった場合は，今後[MATH]の全ての転置リストに出現しても，出現頻度の最大値は5に留まる．
つまり，[MATH]となることが確定しているので，「アニスパゲス」「イカスバゲティ」などの文字列は，[MATH]において枝刈りする．
表[REF_tbl:spaghetti-process]では，枝刈りされる候補に「×.
」を記している．
枝刈りにより，[MATH]において15個の解候補が枝刈りされ，候補は17文字列に減る．
[MATH]でも同様の処理を行い，解の候補はそれぞれ8個，5個まで絞り込まれる．
[MATH]では，「スパゲティー・」と「スパゲティーニ」の出現回数が6に到達するので，候補集合から解集合に移動させる（\scalebox{1.7}{[MATH]}.
で表示）．
[MATH]では，「スパゲッティー」と「スパッゲティー」の出現回数が6に到達し，全ての候補の検証が終了したことになる．
CPMergeアルゴリズムにおいて，[MATH]の転置リストを処理した後に残る解候補の数を[MATH]，[MATH]の転置リストの要素数を[MATH]とする．
CPMergeの検証フェーズでは，それぞれの候補に対して二分探索を行うため，9行目の各[MATH]に対して，10〜20行目の計算量は[MATH]である．
[MATH]の並び順の定義から，[MATH]が大きくなると[MATH]も増加するが，枝刈りが有効に働けば，[MATH]が小さくなる．
表[REF_tbl:spaghetti-process]の例では，各[MATH]に対して[MATH]の値は，193 ([MATH])，115 ([MATH])，57.5 ([MATH])，45.1 ([MATH])，20.2 ([MATH])であり，9〜21行目のループが進むにつれて，計算量の見積りが減少する．
検索クエリ文字列やデータベースの文字列集合のtri-gramの分布により，[MATH]や[MATH]の傾向が異なるので，計算量の見積りを一般的に行うことは難しい．
そこで，第[REF_sec:evaluation]節では，CPMergeアルゴリズムが実際のデータセットに対して動作する際の，解の候補数，転置リストに含まれるSIDの数などの統計情報を報告する．
図[REF_alg:t-overlap-cpmerge]のアルゴリズムでは，SIDをキーとして頻度を格納する連想配列[MATH]を用いていた．
実は，転置リストが整列済みのSIDで構成されるという性質を利用すれば，情報検索における転置リストのマージ[CITE]と同様に，連想配列をリスト構造（可変長配列）で代用できる．
主要なプログラミング言語では連想配列を容易に扱えるが，アクセスのコストがリスト構造よりも大きいので，連想配列をリスト構造で置き換えることで，検索処理の高速化が期待できる．
図[REF_alg:t-overlap-cpmerge-post]は，図[REF_alg:t-overlap-cpmerge]から連想配列を排除し，リスト構造のみでCPMergeアルゴリズムを実装するもの(CPMerge-opt)である．
図[REF_alg:t-overlap-cpmerge-post]の2〜21行目は，図[REF_alg:t-overlap-cpmerge]の2〜7行目に対応し，解の候補生成を行う．
2行目では，解候補の頻度を計測する変数[MATH]を初期化しているが，その型は連想配列([MATH])から，可変長配列([MATH])に変更されている．
CPMerge-optでは，[MATH]の要素は[MATH]のタプルであり，要素はSIDの昇順に並べる．
3〜21行目の基本的な流れは，[MATH]における解候補リスト[MATH]と，[MATH]の転置リストを，先頭から順に比較していき，一時変数[MATH]に[MATH]における解候補リストを作成する．
最後に，[MATH]を[MATH]で上書きし（20行目），[MATH]のステップへと進む．
各[MATH]において，[MATH]を空のリストで初期化し（4行目），[MATH]と[MATH]でこれから処理する要素の位置（インデックス）を管理する変数[MATH]と[MATH]を，それぞれ[MATH]で初期化する（6行目）．
7行目から19行目までは，[MATH]と[MATH]の全ての要素を処理し終わるまで，以下の処理を繰り返す．
もし転置リスト[MATH]のSID ([MATH])が，[MATH]における解候補リスト[MATH]に含まれていない場合（8行目），[MATH]を新しい候補として[MATH]に登録し（9行目），[MATH]をインクリメントする（10行目）．
もし，[MATH]における解候補リスト[MATH]中のSID ([MATH])が，転置リスト[MATH]に含まれていない場合（11行目），[MATH]を[MATH]にそのまま追加し（12行目），[MATH]をインクリメントする（13行目）．
それ以外の場合，すなわち転置リスト[MATH]の要素[MATH]と解候補リスト[MATH]中の[MATH]が等しい場合（14行目），[MATH]の頻度をインクリメントしたものを[MATH]に追加し（15行目），[MATH]と[MATH]の両方をインクリメントする（16行目）．
図[REF_alg:t-overlap-cpmerge-post]の22〜36行目は，図[REF_alg:t-overlap-cpmerge]の8〜21行目に対応し，解の候補の検証と枝刈りを行っている．
CPMerge-optでは，[MATH]における解候補リスト[MATH]に対して，転置リスト[MATH]で検証を行い，枝刈りされなかった候補を一時変数[MATH]に待避し，[MATH]における処理が終わったら[MATH]を[MATH]で上書きしている．
図[REF_alg:t-overlap-cpmerge]と図[REF_alg:t-overlap-cpmerge-post]のその他の箇所は，ほとんど同じである．
