ここでは最大被覆問題に基づいた要約モデル，最大被覆モデルと，ナップサック問題に基づいた要約モデル，ナップサックモデルを比較する．
[MATH]文の入力および，それらに含まれる[MATH]個の概念を考える．
概念は先に述べたよう単語のユニグラムやバイグラムなどであるが，文中から抽出できる他の何らかの情報でもよい．
[MATH]を文[MATH]が要約に含まれる際に[MATH]となる決定変数を要素とするベクトルとする．
[MATH]を概念[MATH]が要約に含まれる際に[MATH]となる決定変数を要素とするベクトルとする．
[MATH]を概念[MATH]の重要度[MATH]を要素とするベクトルとする．
行列[MATH]の要素[MATH]を文[MATH]に含まれる概念[MATH]の数とする．
[MATH]を文[MATH]の長さ[MATH]を要素とするベクトルとする．
[MATH]を要約長とする．
このとき，最大被覆問題は以下のように定式化される．
\max_{z} &　w^ z
s.t. &　Ax \geqz
&　x \in{0, 1}^{n}
&　z \in{0, 1}^{m}
&　l^ x \leq K
式(1)が目的関数であり，式(2)から式(5)が制約である．
式(4)が示すように[MATH]の要素は0あるいは1である．
もし概念[MATH]が要約に含まれれば，[MATH]となり，その重要度[MATH]は目的関数に加算される．
可能であれば全ての概念を要約に含めたいが，要約長の制限によってはそれは許されない．
式(2)が示すように，概念[MATH]を要約に含めるためには，[MATH]を含むいずれかの文が要約として選択されていなければならない．
仮に文[MATH]が要約に含まれた場合，式(5)の左辺の値は[MATH]だけ増える．
式(5)によって要約として選択された文の長さの合計は[MATH]を超えることが許されない．
式(3)の示すように[MATH]の要素は0あるいは1である．
このことは1つの文は一度しか要約に含めないことを示す．
これらのことから，最大被覆モデルの最適解は，要約長を満たす文の組み合わせを全て試し，全ての組み合わせに対して[MATH]を計算し，[MATH]とかけあわせ，かけあわせた値が最大となる文の組み合わせを探し出せば見つけられるとわかる．
しかし，一部の組み合わせは要約長を満たさない場合があるものの，文の組み合わせの数は[MATH]にもなる．
そのため，全ての組み合わせを列挙することは困難である．
次に，ナップサック問題に目を向けることにする．
[MATH]を文[MATH]が要約に含まれる際に[MATH]となる決定変数を要素とするベクトルとする．
[MATH]を概念[MATH]が要約に含まれる際に[MATH]となる決定変数を要素とするベクトルとする．
上述した最大被覆モデルと同様の記法に従ってナップサックモデルを記述すると以下のようになる．
\max_{z} &　w^ z
s.t. &　Ax = z
&　x \in{0, 1}^{n}
&　z \in( \mathbb{N}^{0} )^{m}
&　l^ x \leq K
ここで，[MATH]は，0を含む，0以上の自然数である．
目的関数である式(6)，1つの文は一度しか要約に含めないとする制約である式(8)，要約の長さに関する制約である式(10)は最大被覆モデルと変わらないものの，式(2)と式(7)，式(4)と式(9)がそれぞれ異なる．
式(4)ではベクトル[MATH]は0と1を要素とするベクトルであったが，式(9)ではベクトル[MATH]は0以上の自然数を要素とするベクトルである．
最大被覆モデルでは要約に同じ概念が何個含まれていようともそれぞれの概念について目的関数において一度しかその重要度を加算しなかった．
それに対してナップサックモデルでは要約に同じ概念が複数含まれていた場合その数だけ重要度を目的関数において加算する．
この性質のため，ナップサックモデルを用いて複数文書要約を行った場合には冗長な要約ができる可能性が高く，したがって，ナップサックモデルの複数文書要約における性能は芳しいものではない．
式(7)は，式(2)と異なり，文が含む概念の数をそのままベクトル[MATH]に反映させる．
例えば，文[MATH]は概念[MATH]を2つ含むとすると，[MATH]である．
文[MATH]は概念[MATH]を1つ含むとすると，[MATH]である．
文1と文2のいずれもが要約に選ばれたとすると（すなわち[MATH]，[MATH]），式(7)から，[MATH]となり概念5は要約に3つ含まれることになる．
前節で述べたように，最大被覆問題が冗長性に強い理由は式(4)にあり，ナップサックモデルが冗長性に弱い理由は式(9)であった．
そこで，式(9)に工夫を施すことでナップサックモデルの冗長性を抑制することを考える．
すなわち，ある単語が要約に含まれる回数を直接制御することで，ナップサックモデルの冗長性を削減する．
本論文の主たる貢献はここにある．
\max_{z} &　w^ z
s.t. &　Ax = z
&　x \in{0, 1}^{n}
&　z \in{ z_{j} | \mathbb{N}^{0} \cap[0, r_{j}] }^{m}
&　l^ x \leq K
式(14)は，ベクトル[MATH]の各要素は0以上[MATH]以下の自然数であることを示す．
すなわち，各概念が要約に含まれてよい個数を制限するベクトル[MATH]を考え，これによって要約の冗長性を削減する．
本論文では式(11)から式(15)で記述される要約モデルを冗長性制約付きナップサックモデルと呼ぶ．
このモデルは最大被覆モデルと等価ではない．
最大被覆モデルは，要約に概念が複数含まれることを許す．
ただし，目的関数を計算する上では1つの概念の重要度は一度しか加えない．
それに対し，冗長性制約付きナップサックモデルは，ある概念が要約に含まれる数を直接制限する．
上に述べた例と同じように，文[MATH]は概念[MATH]を2つ含み([MATH])，文[MATH]は概念[MATH]を1つ含むとする([MATH])．
このとき[MATH]であったとすると，文1と文2を同時に要約に含めることはできない．
概念5は要約には2つしか含めることができないが，文1と文2いずれも要約に含めてしまうと要約には概念5が3つ含まれてしまうからである．
最大被覆モデルでは，長さの制約に違反しない限り，このような組み合わせも許される．
一方，冗長性制約付きナップサックモデルでは式(14)が示す制約を違反する組み合わせは許されない．
ナップサックモデルに式(14)が示す冗長性に関する制約（以下，冗長性制約と呼ぶ）を加えることで冗長性を削減することができるが，動的計画ナップサックアルゴリズムで擬多項式時間で最適解を求めることはできなくなる．
冗長性制約付きナップサックモデルを動的計画法で解くことは可能だが，冗長性制約を考慮するためには，探索の過程において，ある時点での要約に含まれる概念の数を記録しておかなければならない．
ある時点において要約に含まれる概念の数の組み合わせは複数存在するため，これによって探索空間が増大してしまい，素早い求解ができなくなる．
この冗長性制約付きナップサックモデルから冗長性制約を除去すれば，元のナップサックモデルが得られる．
そこで，この冗長性制約をラグランジュ緩和[CITE]する．
以下は，式(14)を緩和し，ベクトル[MATH]による冗長性制約を目的関数に組み込んだものである．
\max_{z} &　w^ z + \boldmath[MATH](r - z)
s.t. &　Ax = z
&　x \in{0, 1}^{n}
&　z \in( \mathbb{N}^{0} )^{m}
&　\boldsymbol \in( \mathbb{R}^{+} )^{m}
&　l^ x \leq K&
[MATH]は非負のラグランジュ乗数ベクトルである．
式(16)から式(21)は，目的関数である式(16)の2つ目の項[MATH]および式(20)を除いてナップサックモデルと同じである．
このラグランジュ緩和問題は，要約に含まれる概念[MATH]の個数[MATH]が[MATH]を超えた際に，非負のラグランジュ乗数[MATH]を通じて目的関数に罰を与える．
例えば，あるとき，概念5が要約に3つ含まれている([MATH])が，ベクトル[MATH]によって要約に2つまでしか含めてはならないと制限されている([MATH])とする．
また，ラグランジュ乗数[MATH]が1だったとする．
このとき[MATH]となり，目的関数は低下する．
[MATH]の調整は，この緩和問題のラグランジュ双対問題[MATH]を解くことで行う．
このように，[MATH]を適切に調整し，冗長性の原因となりやすい概念の重要度を低下させることで，動的計画ナップサックアルゴリズムによって元のナップサックモデルを解いた際でも複数文書要約として良好な解を得ようとするのが本論文の提案である．
具体的なデコーディングの方法については次節で述べる．
デコーディングで必要になるのは，ラグランジュ乗数ベクトル[MATH]の値を適切に設定することである．
[MATH]の値が適切に設定されていれば，あとはそれを動的計画ナップサックアルゴリズムで解くだけでよい．
[MATH]は前節で述べたラグランジュ双対問題を解くことで得られる．
このラグランジュ双対問題は最小化の中に最大化が入れ子になっており，最適化が困難であるものの，劣勾配法[CITE]を用いると良好な近似解が高速に得られることが知られている[CITE]．
劣勾配法は，初期値として適当な[MATH]を設定し，[MATH]の値を繰り返し更新していくものである．
このとき，一度にどの程度[MATH]の値を動かすか，という点が問題となる．
一度に大きく値を動かせばデコーディングに要する時間が短くなると考えられるものの，最適解から離れてしまう可能性もある．
そこで，本論文ではラグランジュヒューリスティック[CITE]を利用する．
ラグランジュヒューリスティックは，ラグランジュ乗数を更新するとき，上界と下界の差を利用してステップサイズを調整する．
また，下界を計算する際に，ヒューリスティックを利用する．
上界はある反復におけるラグランジュ緩和問題の解である．
冗長性制約が緩和されているため，冗長性制約付きナップサックモデルの緩和問題の最適解の目的関数値は，明らかに緩和されていない元問題の最適解の目的関数値より高い．
劣勾配法によってラグランジュ乗数を更新していく過程で，ラグランジュ緩和問題の解は，制約に違反している解，すなわち実行不能解から，徐々に目的関数値を低下させながら実行可能解に近づいていく．
下界はなんらかのヒューリスティックによって得られる実行可能解である．
本論文では，Haddadiによる方法[CITE]と同様に，貪欲法[CITE]を用いて実行可能解を復元する．
詳細については次節で述べる．
ラグランジュヒューリスティックによるデコーディングの具体的なアルゴリズムをAlgorithm 1に示す．
Algorithm 1の基本的な手順は以下のようになる．
[b]
[1] \STATE{[MATH]} \FOR{[MATH] to [MATH]} \STATE{[MATH]} \STATE{[MATH]} \IF{[MATH]} \STATE{[MATH]} \ENDIF\STATE{[MATH]} \IF{[MATH] violates [MATH]} \STATE{[MATH]} \IF{[MATH]} \STATE{[MATH]} \STATE{[MATH]} \ENDIF\STATE{[MATH]} \ELSE\RETURN{[MATH]} \ENDIF\ENDFOR\RETURN{[MATH]}
ラグランジュ乗数ベクトル[MATH]を適当な値に初期化する．
以下の手続きを既定回数だけ繰り返す．
動的計画ナップサックアルゴリズムで式の最適解を得る．
aで得た最適解が制約を満たしているときはそれを下界とし，(3)へ．
そうでなければヒューリスティックを用いて実行可能解を得る．
bで得た実行可能解がこれまでの下界を上回るものであれば，下界を更新する．
下界を出力して終了する．
[MATH]は[MATH]のステップサイズを調整するパラメータである．
ベクトル[MATH]の要素[MATH]は文[MATH]の重要度をあらわす．
各文の重要度は関数[MATH]によって計算される．
関数[MATH]は動的計画ナップサックアルゴリズムである．
動的計画ナップサックアルゴリズムの詳細はAlgorithm 2に示す．
[MATH]と[MATH]はそれぞれ目的関数の下界と上界である．
これらは[MATH]のステップサイズの調整に利用される．
関数[MATH]は要約[MATH]の重要度を計算する．
関数[MATH]は要約[MATH]に含まれる概念の数[MATH]を返す．
[MATH]は下界[MATH]に対応する解である．
ラグランジュ緩和問題の劣勾配ベクトル[MATH]は以下のようになる．
ラグランジュ緩和された集合被覆問題に対するUmetaniらの更新式に基づき[CITE]，ラグランジュ乗数は以下の更新式によって更新する．
[MATH]は更新幅を調整するパラメータである．
更新式の基本的な考え方は，上界[MATH]と下界[MATH]の差が大きい際には更新幅を大きくしつつ，劣勾配ベクトルに従ってラグランジュ乗数を更新していくというものである．
ラグランジュヒューリスティックは，実行不能解から実行可能解を何らかのヒューリスティックを用いて復元するものである．
本論文では，以下の手続きで実行可能解を復元する．
制約に違反している概念を含む文のうち，最も重要度が低いものを要約から除去する．
要約がまだ制約を満たさない場合は(1)へ．
要約が制約を満たした場合は，要約に含まれていない文と，要約長[MATH]と制約を満たした要約の長さの差から，部分問題を生成し，これを貪欲法で解く．
例えば，要約長が300文字であったとする．
制約に違反する文を除去し，制約を満たした要約の長さが200文字だったとすると，100文字分まだ要約に文を含めることができる．
そこで，まだ要約に含まれていない文を，100文字分，貪欲法[CITE]を用いて要約に含めることで，実行可能解を求める．
ナップサックモデルのデコーディングは動的計画ナップサックアルゴリズムを用いて行う．
具体的なアルゴリズムはAlgorithm 2に示す．
[t]
[1] \STATE{[MATH]} \FOR{[MATH] to [MATH]} \STATE{[MATH]} \ENDFOR\FOR{[MATH] to [MATH]} \FOR{[MATH] to [MATH]} \STATE{[MATH]} \STATE{[MATH]} \ENDFOR\FOR{[MATH] to [MATH]} \IF{[MATH]} \STATE{[MATH]} \STATE{[MATH]} \ENDIF\ENDFOR\ENDFOR\STATE{[MATH]} \FOR{[MATH] to [MATH]} \IF{[MATH]} \STATE{[MATH]} \STATE{[MATH]} \ENDIF\ENDFOR\RETURN{[MATH]}
動的計画ナップサックアルゴリズムでは，[MATH]次元の表[MATH]と[MATH]を用意し，これに計算の過程を保存していく．
表[MATH]の要素[MATH]は，文1から文[MATH]までが与えられており，最大要約長が[MATH]であったときのナップサックモデルの最適解の目的関数値を格納している．
表[MATH]の要素[MATH]は，[MATH]の値を計算する際に，すなわちその時点での最適値を計算する際に文[MATH]を要約に利用している場合は1，そうでない場合は0を格納している．
すなわち，[MATH]まで計算し終わった時点で，最大要約長が[MATH]で文1から文[MATH]までが使われた場合にどの文が要約に含まれるか表[MATH]に格納されている．
そのため，[MATH]まで表を埋めたのち，[MATH]に到達するまでの過程を逆にたどることで，ナップサックモデルの最適解を得ることができる．
ここでは最大被覆問題に基づいた要約モデル，最大被覆モデルと，ナップサック問題に基づいた要約モデル，ナップサックモデルを比較する．
[MATH]文の入力および，それらに含まれる[MATH]個の概念を考える．
概念は先に述べたよう単語のユニグラムやバイグラムなどであるが，文中から抽出できる他の何らかの情報でもよい．
[MATH]を文[MATH]が要約に含まれる際に[MATH]となる決定変数を要素とするベクトルとする．
[MATH]を概念[MATH]が要約に含まれる際に[MATH]となる決定変数を要素とするベクトルとする．
[MATH]を概念[MATH]の重要度[MATH]を要素とするベクトルとする．
行列[MATH]の要素[MATH]を文[MATH]に含まれる概念[MATH]の数とする．
[MATH]を文[MATH]の長さ[MATH]を要素とするベクトルとする．
[MATH]を要約長とする．
このとき，最大被覆問題は以下のように定式化される．
\max_{z} &　w^ z
s.t. &　Ax \geqz
&　x \in{0, 1}^{n}
&　z \in{0, 1}^{m}
&　l^ x \leq K
式(1)が目的関数であり，式(2)から式(5)が制約である．
式(4)が示すように[MATH]の要素は0あるいは1である．
もし概念[MATH]が要約に含まれれば，[MATH]となり，その重要度[MATH]は目的関数に加算される．
可能であれば全ての概念を要約に含めたいが，要約長の制限によってはそれは許されない．
式(2)が示すように，概念[MATH]を要約に含めるためには，[MATH]を含むいずれかの文が要約として選択されていなければならない．
仮に文[MATH]が要約に含まれた場合，式(5)の左辺の値は[MATH]だけ増える．
式(5)によって要約として選択された文の長さの合計は[MATH]を超えることが許されない．
式(3)の示すように[MATH]の要素は0あるいは1である．
このことは1つの文は一度しか要約に含めないことを示す．
これらのことから，最大被覆モデルの最適解は，要約長を満たす文の組み合わせを全て試し，全ての組み合わせに対して[MATH]を計算し，[MATH]とかけあわせ，かけあわせた値が最大となる文の組み合わせを探し出せば見つけられるとわかる．
しかし，一部の組み合わせは要約長を満たさない場合があるものの，文の組み合わせの数は[MATH]にもなる．
そのため，全ての組み合わせを列挙することは困難である．
次に，ナップサック問題に目を向けることにする．
[MATH]を文[MATH]が要約に含まれる際に[MATH]となる決定変数を要素とするベクトルとする．
[MATH]を概念[MATH]が要約に含まれる際に[MATH]となる決定変数を要素とするベクトルとする．
上述した最大被覆モデルと同様の記法に従ってナップサックモデルを記述すると以下のようになる．
\max_{z} &　w^ z
s.t. &　Ax = z
&　x \in{0, 1}^{n}
&　z \in( \mathbb{N}^{0} )^{m}
&　l^ x \leq K
ここで，[MATH]は，0を含む，0以上の自然数である．
目的関数である式(6)，1つの文は一度しか要約に含めないとする制約である式(8)，要約の長さに関する制約である式(10)は最大被覆モデルと変わらないものの，式(2)と式(7)，式(4)と式(9)がそれぞれ異なる．
式(4)ではベクトル[MATH]は0と1を要素とするベクトルであったが，式(9)ではベクトル[MATH]は0以上の自然数を要素とするベクトルである．
最大被覆モデルでは要約に同じ概念が何個含まれていようともそれぞれの概念について目的関数において一度しかその重要度を加算しなかった．
それに対してナップサックモデルでは要約に同じ概念が複数含まれていた場合その数だけ重要度を目的関数において加算する．
この性質のため，ナップサックモデルを用いて複数文書要約を行った場合には冗長な要約ができる可能性が高く，したがって，ナップサックモデルの複数文書要約における性能は芳しいものではない．
式(7)は，式(2)と異なり，文が含む概念の数をそのままベクトル[MATH]に反映させる．
例えば，文[MATH]は概念[MATH]を2つ含むとすると，[MATH]である．
文[MATH]は概念[MATH]を1つ含むとすると，[MATH]である．
文1と文2のいずれもが要約に選ばれたとすると（すなわち[MATH]，[MATH]），式(7)から，[MATH]となり概念5は要約に3つ含まれることになる．
前節で述べたように，最大被覆問題が冗長性に強い理由は式(4)にあり，ナップサックモデルが冗長性に弱い理由は式(9)であった．
そこで，式(9)に工夫を施すことでナップサックモデルの冗長性を抑制することを考える．
すなわち，ある単語が要約に含まれる回数を直接制御することで，ナップサックモデルの冗長性を削減する．
本論文の主たる貢献はここにある．
\max_{z} &　w^ z
s.t. &　Ax = z
&　x \in{0, 1}^{n}
&　z \in{ z_{j} | \mathbb{N}^{0} \cap[0, r_{j}] }^{m}
&　l^ x \leq K
式(14)は，ベクトル[MATH]の各要素は0以上[MATH]以下の自然数であることを示す．
すなわち，各概念が要約に含まれてよい個数を制限するベクトル[MATH]を考え，これによって要約の冗長性を削減する．
本論文では式(11)から式(15)で記述される要約モデルを冗長性制約付きナップサックモデルと呼ぶ．
このモデルは最大被覆モデルと等価ではない．
最大被覆モデルは，要約に概念が複数含まれることを許す．
ただし，目的関数を計算する上では1つの概念の重要度は一度しか加えない．
それに対し，冗長性制約付きナップサックモデルは，ある概念が要約に含まれる数を直接制限する．
上に述べた例と同じように，文[MATH]は概念[MATH]を2つ含み([MATH])，文[MATH]は概念[MATH]を1つ含むとする([MATH])．
このとき[MATH]であったとすると，文1と文2を同時に要約に含めることはできない．
概念5は要約には2つしか含めることができないが，文1と文2いずれも要約に含めてしまうと要約には概念5が3つ含まれてしまうからである．
最大被覆モデルでは，長さの制約に違反しない限り，このような組み合わせも許される．
一方，冗長性制約付きナップサックモデルでは式(14)が示す制約を違反する組み合わせは許されない．
ナップサックモデルに式(14)が示す冗長性に関する制約（以下，冗長性制約と呼ぶ）を加えることで冗長性を削減することができるが，動的計画ナップサックアルゴリズムで擬多項式時間で最適解を求めることはできなくなる．
冗長性制約付きナップサックモデルを動的計画法で解くことは可能だが，冗長性制約を考慮するためには，探索の過程において，ある時点での要約に含まれる概念の数を記録しておかなければならない．
ある時点において要約に含まれる概念の数の組み合わせは複数存在するため，これによって探索空間が増大してしまい，素早い求解ができなくなる．
この冗長性制約付きナップサックモデルから冗長性制約を除去すれば，元のナップサックモデルが得られる．
そこで，この冗長性制約をラグランジュ緩和[CITE]する．
以下は，式(14)を緩和し，ベクトル[MATH]による冗長性制約を目的関数に組み込んだものである．
\max_{z} &　w^ z + \boldmath[MATH](r - z)
s.t. &　Ax = z
&　x \in{0, 1}^{n}
&　z \in( \mathbb{N}^{0} )^{m}
&　\boldsymbol \in( \mathbb{R}^{+} )^{m}
&　l^ x \leq K&
[MATH]は非負のラグランジュ乗数ベクトルである．
式(16)から式(21)は，目的関数である式(16)の2つ目の項[MATH]および式(20)を除いてナップサックモデルと同じである．
このラグランジュ緩和問題は，要約に含まれる概念[MATH]の個数[MATH]が[MATH]を超えた際に，非負のラグランジュ乗数[MATH]を通じて目的関数に罰を与える．
例えば，あるとき，概念5が要約に3つ含まれている([MATH])が，ベクトル[MATH]によって要約に2つまでしか含めてはならないと制限されている([MATH])とする．
また，ラグランジュ乗数[MATH]が1だったとする．
このとき[MATH]となり，目的関数は低下する．
[MATH]の調整は，この緩和問題のラグランジュ双対問題[MATH]を解くことで行う．
このように，[MATH]を適切に調整し，冗長性の原因となりやすい概念の重要度を低下させることで，動的計画ナップサックアルゴリズムによって元のナップサックモデルを解いた際でも複数文書要約として良好な解を得ようとするのが本論文の提案である．
具体的なデコーディングの方法については次節で述べる．
デコーディングで必要になるのは，ラグランジュ乗数ベクトル[MATH]の値を適切に設定することである．
[MATH]の値が適切に設定されていれば，あとはそれを動的計画ナップサックアルゴリズムで解くだけでよい．
[MATH]は前節で述べたラグランジュ双対問題を解くことで得られる．
このラグランジュ双対問題は最小化の中に最大化が入れ子になっており，最適化が困難であるものの，劣勾配法[CITE]を用いると良好な近似解が高速に得られることが知られている[CITE]．
劣勾配法は，初期値として適当な[MATH]を設定し，[MATH]の値を繰り返し更新していくものである．
このとき，一度にどの程度[MATH]の値を動かすか，という点が問題となる．
一度に大きく値を動かせばデコーディングに要する時間が短くなると考えられるものの，最適解から離れてしまう可能性もある．
そこで，本論文ではラグランジュヒューリスティック[CITE]を利用する．
ラグランジュヒューリスティックは，ラグランジュ乗数を更新するとき，上界と下界の差を利用してステップサイズを調整する．
また，下界を計算する際に，ヒューリスティックを利用する．
上界はある反復におけるラグランジュ緩和問題の解である．
冗長性制約が緩和されているため，冗長性制約付きナップサックモデルの緩和問題の最適解の目的関数値は，明らかに緩和されていない元問題の最適解の目的関数値より高い．
劣勾配法によってラグランジュ乗数を更新していく過程で，ラグランジュ緩和問題の解は，制約に違反している解，すなわち実行不能解から，徐々に目的関数値を低下させながら実行可能解に近づいていく．
下界はなんらかのヒューリスティックによって得られる実行可能解である．
本論文では，Haddadiによる方法[CITE]と同様に，貪欲法[CITE]を用いて実行可能解を復元する．
詳細については次節で述べる．
ラグランジュヒューリスティックによるデコーディングの具体的なアルゴリズムをAlgorithm 1に示す．
Algorithm 1の基本的な手順は以下のようになる．
[b]
[1] \STATE{[MATH]} \FOR{[MATH] to [MATH]} \STATE{[MATH]} \STATE{[MATH]} \IF{[MATH]} \STATE{[MATH]} \ENDIF\STATE{[MATH]} \IF{[MATH] violates [MATH]} \STATE{[MATH]} \IF{[MATH]} \STATE{[MATH]} \STATE{[MATH]} \ENDIF\STATE{[MATH]} \ELSE\RETURN{[MATH]} \ENDIF\ENDFOR\RETURN{[MATH]}
ラグランジュ乗数ベクトル[MATH]を適当な値に初期化する．
以下の手続きを既定回数だけ繰り返す．
動的計画ナップサックアルゴリズムで式の最適解を得る．
aで得た最適解が制約を満たしているときはそれを下界とし，(3)へ．
そうでなければヒューリスティックを用いて実行可能解を得る．
bで得た実行可能解がこれまでの下界を上回るものであれば，下界を更新する．
下界を出力して終了する．
[MATH]は[MATH]のステップサイズを調整するパラメータである．
ベクトル[MATH]の要素[MATH]は文[MATH]の重要度をあらわす．
各文の重要度は関数[MATH]によって計算される．
関数[MATH]は動的計画ナップサックアルゴリズムである．
動的計画ナップサックアルゴリズムの詳細はAlgorithm 2に示す．
[MATH]と[MATH]はそれぞれ目的関数の下界と上界である．
これらは[MATH]のステップサイズの調整に利用される．
関数[MATH]は要約[MATH]の重要度を計算する．
関数[MATH]は要約[MATH]に含まれる概念の数[MATH]を返す．
[MATH]は下界[MATH]に対応する解である．
ラグランジュ緩和問題の劣勾配ベクトル[MATH]は以下のようになる．
ラグランジュ緩和された集合被覆問題に対するUmetaniらの更新式に基づき[CITE]，ラグランジュ乗数は以下の更新式によって更新する．
[MATH]は更新幅を調整するパラメータである．
更新式の基本的な考え方は，上界[MATH]と下界[MATH]の差が大きい際には更新幅を大きくしつつ，劣勾配ベクトルに従ってラグランジュ乗数を更新していくというものである．
ラグランジュヒューリスティックは，実行不能解から実行可能解を何らかのヒューリスティックを用いて復元するものである．
本論文では，以下の手続きで実行可能解を復元する．
制約に違反している概念を含む文のうち，最も重要度が低いものを要約から除去する．
要約がまだ制約を満たさない場合は(1)へ．
要約が制約を満たした場合は，要約に含まれていない文と，要約長[MATH]と制約を満たした要約の長さの差から，部分問題を生成し，これを貪欲法で解く．
例えば，要約長が300文字であったとする．
制約に違反する文を除去し，制約を満たした要約の長さが200文字だったとすると，100文字分まだ要約に文を含めることができる．
そこで，まだ要約に含まれていない文を，100文字分，貪欲法[CITE]を用いて要約に含めることで，実行可能解を求める．
ナップサックモデルのデコーディングは動的計画ナップサックアルゴリズムを用いて行う．
具体的なアルゴリズムはAlgorithm 2に示す．
[t]
[1] \STATE{[MATH]} \FOR{[MATH] to [MATH]} \STATE{[MATH]} \ENDFOR\FOR{[MATH] to [MATH]} \FOR{[MATH] to [MATH]} \STATE{[MATH]} \STATE{[MATH]} \ENDFOR\FOR{[MATH] to [MATH]} \IF{[MATH]} \STATE{[MATH]} \STATE{[MATH]} \ENDIF\ENDFOR\ENDFOR\STATE{[MATH]} \FOR{[MATH] to [MATH]} \IF{[MATH]} \STATE{[MATH]} \STATE{[MATH]} \ENDIF\ENDFOR\RETURN{[MATH]}
動的計画ナップサックアルゴリズムでは，[MATH]次元の表[MATH]と[MATH]を用意し，これに計算の過程を保存していく．
表[MATH]の要素[MATH]は，文1から文[MATH]までが与えられており，最大要約長が[MATH]であったときのナップサックモデルの最適解の目的関数値を格納している．
表[MATH]の要素[MATH]は，[MATH]の値を計算する際に，すなわちその時点での最適値を計算する際に文[MATH]を要約に利用している場合は1，そうでない場合は0を格納している．
すなわち，[MATH]まで計算し終わった時点で，最大要約長が[MATH]で文1から文[MATH]までが使われた場合にどの文が要約に含まれるか表[MATH]に格納されている．
そのため，[MATH]まで表を埋めたのち，[MATH]に到達するまでの過程を逆にたどることで，ナップサックモデルの最適解を得ることができる．
