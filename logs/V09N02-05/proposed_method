本節ではdiffについて説明する．
本稿でいうdiffとはUNIXのファイル比較ツールdiffのことである．
このコマンドは，与えられた二つのファイルの差分を順序情報を保持したまま行を単位として出力する．
例えば，
今日学校へいく
ということが書いてあるファイルと
今日大学へいく
ということが書いてあるファイルがあるとする．
これらのdiffをとると，差分の部分が
<学校へ>大学へ
のような形で出力される．
ところで，diffコマンドには-Dオプションという便利なオプションがある．
これをつけてdiffコマンドを使うと差分部分だけでなく共通部分も出力される．
つまりファイルのマージが実現される．
また，差分部分はCのプリプロセッサなどで使われるifdef文などで表現される．
この場合，場所によって差分部分の表示の順番が逆転しテキスト全体として差分の状態がわかりにくくなり，また，ifdefという機械的な記号だと人間の目で認識するのが困難であるため，ここでは差分部分は以下のように表示することにする．
;▼▼▼▼▼▼(一つめのファイルにだけある部分) ;●●●(二つめのファイルにだけある部分) ;▲▲▲▲▲▲
ここでは，``;▼▼▼▼▼▼''は差分部分の始まりを，``;▲▲▲▲▲▲''は差分部分の終りを意味し，``;●●●''は差分を構成する二つのデータの境界を意味する．
本稿では，-Dオプションをつけてさらにifdefの部分を上記のように表示して，ファイルのマージを行なう場合のdiffをmdiffと呼ぶ(mはmergeのm)．
(mdiffの構成方法および使用方法については付録[REF_sec:exp_mdiff]をつけておいた．
参考にしてほしい．
)
実際に先ほどのデータに対してmdiffをかけてみると，以下のような結果になる．
今日;▼▼▼▼▼▼学校へ;●●●大学へ;▲▲▲▲▲▲いく
「今日」が一致し，「学校へ」と「大学へ」が差分となり，「いく」がまた共通部分となっている．
mdiffの出力はdiffと異なり一致部分も出力されるためにわかりやすい．
また，mdiffの結果からは元の二つのファイルのデータを完全に復元することができる．
共通部分と，差分部分の黒丸(;●●●)の上側だけを取り出すと，
今日学校へいく
のように一つ目のファイルの情報が取り出される．
また，共通部分と，差分部分の黒丸(;●●●)の下側だけを取り出すと，
今日大学へいく
のように二つ目のファイルの情報が取り出される．
このように元の情報を完全に復元できる．
また，mdiffでは一致部分は片方のデータにあったものだけを表示し，不一致部分のみ両方のデータのものを表示するために，元の二つのデータよりもデータ量は削減できるが，上記のように元の情報を完全に復元できるために，復元できる状態でデータ量を削減するという意味でmdiffはデータ圧縮を実現しているものともいえる．
次に文字を単位としたmdiffを考える．
言語処理の場合は文字単位で差分を取りたい場合が多い．
そのようなときは一度ファイルの中身の情報を，一文字ずつ改行をして出力したファイルでmdiffをとればよい．
例えば先のファイルの情報だと，
今日学校へいく
という形にしてから，mdiffをとればよい．
diffの表示は見にくく，mdiffはdiffで表示される情報を完全に含むので以降の説明はmidffを用いて行なう．
以降の節では，実際にこのmdiffを使った言語処理の実例を見ていくこととする．
本節ではmdiffを用いて差分検出したり，またその差分結果から書き換え規則を獲得する研究などを記述する．
具体的には，以下のものを示す．
複数システムの出力の差分検出
差分の考察と書き換え規則の獲得
筆者は以前，jumanのシステムのバージョン[CITE]が複数乱立しているとき，この複数のjumanの出力をmdiffによりマージして形態素結果の品質を向上させることをしていた．
ここではこれを説明する．
「といったこと」を解析し，jumanのAというバージョンの出力が
とと助詞いった言う動詞ことこと名詞
となっていて，Bのバージョンの出力が
とと助詞いった行く動詞ことこと名詞
となっているとしよう．
「いった」という語は「行く」と「言う」の曖昧性があり，Bのバーションではこれを誤って「行く」の方の語であると出力していたとする．
ここでmidffをとると以下のような結果となる．
とと助詞;▼▼▼▼▼▼いった言う動詞;●●●いった行く動詞;▲▲▲▲▲▲ことこと名詞
mdiffをとることで複数のシステムの出力の差異を容易に検出することができる．
この場合「いった」の部分の出力に差異があることがわかる．
ここで，出力修正の作業者はこのような差分が検出された箇所においてどちらが正しいかを判断し，上が正しければなにもせず下が正しければ「;●●●」の先頭に``x''をつけるなどとすると決めておく．
そのようにすると，``x''がなければ差分の下を，あれば差分の上の情報と区切り記号を消すことで，その作業結果のデータから自動的にそれぞれの差分からよい結果の方を選び，それぞれのバージョンのものよりも高い精度の結果を生成できる．
また，差分の両方が誤っている場合がよくある．
このときは「;●●●」の上の方のデータを実際に書き直すとよい．
この方法を用いると，修正できないものは両方のバージョンで同じように誤るものだけであり，多くの形態素誤りを修正できる．
ここで注意すべきことは異なる性質のシステムを複数用意しないといけないということである．
誤り方が同じシステムの場合だと多くの誤りを見逃すことになる．
また，システムが三つある場合はdiff3コマンドを使うとよい．
diff3は三つのファイルの差分を検出することができる．
上記では形態素解析を例にあげたが，他の解析でも解析結果を行単位にすることでmdiffで差分をとることができる．
ここでは，複数のシステムの出力の差分をとる話をしたが，一つをタグつきコーパスとし，それをなにかのシステムで解析した結果と比較することで，そのタグつきコーパスの誤りを検出し修正するということもできる．
ここでは，文献[CITE]でも述べた話し言葉と書き言葉のdiffの研究について記述する．
この研究では，対応のとれた話し言葉と書き言葉のデータを使い，それらの差分から話し言葉と書き言葉の違いを考察したり，話し言葉から書き言葉への言い換え規則，また，その逆のための規則を獲得した．
データとしては，学会の口頭発表を話し言葉データとし，その口頭発表の内容が記されたその学会の予稿原稿を書き言葉として用いた．
例えば，話し言葉と書き言葉のデータが表[REF_tab:write_talk_juman]のような形で与えられたとする．
ここでは，差分がとりやすいように形態素解析システムなどで1行に1単語がはいるような形に変換してある．
このような書き言葉と話し言葉のデータが与えられたとき，mdiffをとると，表[REF_tab:write_talk_diff]のような結果を得る．
この結果から，差分部分だけを抽出すると表[REF_tab:write_talk_diff_ext]のような結果が得られる．
この結果から，話し言葉には「え」などが挿入されること，また話し言葉では「っていうの」という表現をいれて発話をなめらかにすることなどがわかる．
また，「述べる」が「述べます」と言い換えられることがわかる．
以上のようにmdiffを使うことで話し言葉と書き言葉の差異を検出でき，またそれを考察することで，話し言葉と書き言葉の違いを調査できることがわかる．
また，これらの差分は話し言葉と書き言葉の言い換え規則としてみることもできる．
例えば，「え」の部分は，書き言葉になにもないところに話し言葉に変換する場合「え」をいれるという規則のように見ることができる．
また，「述べる」と「述べます」の部分は，話し言葉に変換する場合は「述べる」を「述べます」に言い換える規則のように見ることができる．
その意味でmdiffを用いることで言い換え規則，もしくは，変換規則を検出できることがわかる．
ここでは，話し言葉と書き言葉のデータを例にとったが，このようなことはさまざまなところで可能である．
例えば，英文校閲前のテキストと英文校閲後のテキストで，mdiffをとると，どのような間違いをどのように直せばよいかがわかるし，また英文校閲用の規則が獲得できる．
また，要約前のテキストと要約後のテキストで，mdiffをとると，どのように要約されているかを如実に見ることができるし，また要約用の規則が獲得できる．
その他にも対応のとれた性質の異なるデータに対してmdiffをとることで，さまざまな考察と，言い換え規則の獲得ができることだろう．
本節ではmdiffのデータをマージする機能，および，そのマージの最適照合能力を利用したものについて記述する．
具体的には以下の三つについて記述する．
対訳コーパスの対応づけ
講演と予稿の対応づけ
最適照合能力を用いた質問応答システム
[t]
\leavevmode
[h]{|l|}\hline{
[h]{4cm} <Section 1>
..
..
..
..
..
..
..
..
..
..
..
..
.
..
..
..
..
..
..
..
..
..
..
..
..
.
<Section 2>
..
..
..
..
..
..
..
..
..
..
..
..
.
..
..
..
..
..
..
..
..
..
..
..
..
.
}
\hline
[t]
\leavevmode
[h]{|l|}\hline{
[h]{4cm} <Section 1>
;▼▼▼▼▼▼
(日本語文の内容)
;●●●
(英語文の内容)
;▲▲▲▲▲▲
<Section 2>
;▼▼▼▼▼▼
(日本語文の内容)
;●●●
(英語文の内容)
;▲▲▲▲▲▲
}
\hline
ここでは対訳コーパスの対応づけを考える．
ここで条件としてそれぞれのコーパスには対応する箇所に同じ記号が入っていることを前提とする．
また，対応づけの単位はこの記号で区切られた部分であるとする．
例を図[REF_tab:mt_corpus]にあげる．
ここでは日本語のコーパスと英語のコーパスがまだばらばらに存在し，対応づけられていないとする．
また，それぞれは図[REF_tab:mt_corpus]のように両方とも<Section 1>などの同じ形をしたセクション情報が与えられているとする．
このとき，日本語と英語では同じセクションのものは同じ内容であるとする．
この場合，これらのデータのmdiffをとることで，図[REF_tab:mt_corpus_mdiff]のような結果を得ることができる．
この結果では，<Section 1>などが共通部分となり，その他の部分が不一致部分となる．
この不一致部分では日本語と英語が上下にわかれて格納されることになる．
このようにすることで，mdiffを用いて対訳データが作成されることになる．
ここで示したものは，文ごとなどの細かい対応づけをするものでなく，セクションなどの大雑把なもので一見役に立たないように思えるかもしれないが，文の対応づけは難しい問題で，まずあらかじめ対応がとれていることがはっきりしている章，段落のレベルで対応づけをしてから細かい対応づけをするという考え方もあり[CITE]，その意味ではこのような粗い対応づけも役に立つ．
また，ここで示したものは<Section 1>などの情報を認識させて区分するだけなのでそのようなことをするプログラムを書くことでも同じように対訳データの対応づけを行なうことができる．
しかし，mdiffを使うとそのようなプログラムも書くこともなく対応づけを容易に実現できるのである．
[t]
\leavevmode
[h]{|l|}\hline{
[h]{4cm} <Chapter 1>
(1章の内容)
</Chapter 1>
<Chapter 2>
(2章の内容)
</Chapter 2>
<Chapter 3>
(3章の内容)
</Chapter 3>
}
\hline
[t]
\leavevmode
[h]{|l|}\hline{
[h]{4cm} ;▼▼▼▼▼▼
<Chapter 1>
(予稿のみの内容)
;●●●
(講演のみの内容)
;▲▲▲▲▲▲
(共通する内容)
;▼▼▼▼▼▼
(予稿のみの内容)
;●●●
(講演のみの内容)
;▲▲▲▲▲▲
(共通する内容)
;▼▼▼▼▼▼
</Chapter 1>
<Chapter 2>
(予稿のみの内容)
;●●●
(講演のみの内容)
;▲▲▲▲▲▲
}
\hline
[t]
\leavevmode
[h]{|l|}\hline{
[h]{4cm} <Chapter 1>
(講演のみの内容)
(共通する内容)
(講演のみの内容)
</Chapter 1>
<Chapter 2>
(講演のみの内容)
}
\hline
本節では講演と予稿の対応づけ[CITE]を考える．
この講演と予稿は，先の書き換え規則の獲得でも述べた書き言葉データと話し言葉データに対応する．
講演は学会の口頭発表で，予稿はその口頭発表に対応する論文のことである．
このような講演と予稿が与えられたとき，講演の各部分と，予稿の各部分の対応がとれると，講演を聞いている時だと，それに対応する予稿の部分を参照できるし，予稿を読んでいるときだと，それに対応する講演の部分を参照できて便利である[CITE]．
本節ではこの講演と予稿の対応づけをmdiffで行なうことを考える．
ここでは特に予稿の各章が講演のどこの部分に対応するかをmdiffでもとめることにする．
ここで予稿と講演とは話は同じ順序でなされると仮定する．
また，予稿の章が認識しやすいように予稿のデータには図[REF_tab:youkou_kousei]のように，``<Chapter 1>''のような記号を挿入しておく．
この形にしておいて，予稿と講演のデータに対して，形態素解析をして各行に単語がくる状態でmdiffを使うことで，図[REF_tab:youkou_mdiff]のような結果を得る．
ここで，差分部分で予稿に対応する上半分の方を，``<Chapter 1>''のような記号を除いてすべて消し去ると図[REF_tab:youkou_mdiff2]のような結果を得る．
図では元の講演のデータに対して``<Chapter 1>''のような記号だけが挿入された形になる．
つまり，講演のどの部分が予稿のどの章にあたるかがわかることになる．
これは簡単にいうと，mdiffの照合能力を用いて予稿と講演を照合し，章の情報だけ残して予稿の情報を消し去ることにより，講演データに章の情報を挿入するということを行なっていることを意味する．
このような予稿と講演の対応づけもmdiffを用いると簡単に行なえるのである．
本節ではmdiffの最適照合能力を用いた質問応答システム[CITE]について記述する．
質問応答システムとは，例えば，「日本の首都はどこですか」と聞くと「東京」と答えそのものをずばり返すシステムである．
知識が自然言語で書かれていると仮定すると，基本的には質問文と知識の文を照合し，その照合結果で疑問詞に対応するところを答えとして出力すればよい．
例えば先の問題だと，「日本の首都は東京です」という文を探してきてこの文で疑問詞に対応する「東京」を解として出力するのである．
ここではこれをmdiffで行なうことを考える．
まず，質問文の疑問詞の部分をXに置き換え，また文末を平叙文に変換し，「日本の首都はXです」を得る．
また，知識ベースから「日本の首都は東京です」を得る．
ここでこの二つを一文字ずつ改行してからmdiffをとると以下のような結果を得る．
日本の首都は;▼▼▼▼▼▼X ;●●●東京;▲▲▲▲▲▲です
ここでXと差分部分で組になっているものを解とすると，「東京」を正しく取り出せることになる．
ところで一文字単位に改行してからmdiffを使う場合少々文に食い違いがあっても答えを正しく取り出すことができる．
例えば，知識ベースの文が「日本国の首都は東京です」であったとする．
この場合はmdiffの結果は以下のようになる．
日本;▼▼▼▼▼▼;●●●国;▲▲▲▲▲▲の首都は;▼▼▼▼▼▼X ;●●●東京;▲▲▲▲▲▲です
差分部分は少し増えるがXに対応する箇所は「東京」のままで，解を正しく抽出できる．
ところで，われわれが提案する質問応答システムでは類似度を尺度として用いた変形をくりかえし，質問文と知識データの文がより一致した状態で上記のような照合を行なう．
このために類似度を定義する必要がある．
mdiffを用いた場合は一致部分と不一致部分が認定できるので，類似度は(一致部分の文字数)/(全文字数)のような形で定義できる．
ここで，「日本国」と「日本」を言い換える規則があれば「日本の首都はXです」を「日本国の首都はXです」と言い換えて照合し，不一致部分を減らすことで，より確実に解を得ることができる．
本付録では読者の便を考えmdiffの構成方法と使い方を記す．
また，現在はこのプログラムは筆者のホームページ(http://www.crl.go.jp/jt/a132/members/murata/software/software.html)からダウンロードできる．
筆者はmdiffはcshとperlを使って構成している．
------------------------------------------------------------ファイルmdiff ------------------------------------------------------------ #! /bin/csh -f
/usr/bin/diff -D@@@mm $* |  username/bin/Perl/tmpdiff_patch.pl
# ------------------------------------------------------------
------------------------------------------------------------ファイル username/bin/Perl/tmpdiff_patch.pl ------------------------------------------------------------ #!/usr/local/bin/perl $|=1;
while( <> ) { if ( /^#ifn?def (\/\*)?\@\@\@mm( \*\/)?/ ) { [MATH]_; while( <> ) { [MATH]_; if ( /^#endif (\/\*)?\@\@\@mm( \*\/)?/ ) { # print ";▼▼▼▼▼▼\n"; print ";▲▲▲▲▲▲\n"; if ( [MATH]con =  /^#ifndef (\/\*)?\@\@\@mm( \*\/)?\n((
.
|\n)*)#else (\/\*)?\@\@\@mm( \*\/)?/ || [MATH]3; } print ";●●●\n"; if ( [MATH]3; } } elsif ( [MATH]con =  /#else (\/\*)?\@\@\@mm( \*\/)?\n((.
|
n)*)#endif (\/\*)?\@\@\@mm( \*\/)?/ ) { print [MATH]con =  /^#ifdef (\/\*)?\@\@\@mm( \*\/)?\n((.
|\n)*)#else (\/\*)?\@\@\@mm( \*\/)?/ || [MATH]3; } } print ";▼▼▼▼▼▼\n"; # print ";▲▲▲▲▲▲\n"; last; } } } else { print; } }
exit;
------------------------------------------------------------
cshのプログラムの中からdiffとperlで書いた整形プログラム
~username/bin/Perl/tmpdiff_patch.plを呼ぶことでdiffによる処理，さらに整形を実現している．
またページの都合上，長い行の部分は`` \\''で分割している．
実際のプログラミングは`` \\''を消してさらに改行せずに記述して欲しい．
また，このプログラムでは本稿の表示と少し違う表示をする．
本稿では
;▼▼▼▼▼▼(一つめのファイルにだけある部分) ;●●●(二つめのファイルにだけある部分) ;▲▲▲▲▲▲
と表示しているところ，このプログラムでは
;▲▲▲▲▲▲(一つめのファイルにだけある部分) ;●●●(二つめのファイルにだけある部分) ;▼▼▼▼▼▼
と表示する．
つまり差分の始まりと終りを示す記号が逆転する．
これは，理論の説明としては差分部分を挟んでいることを示す上の表示がよいが，みやすさとしては下の表示の方が見やすいからそうしているのである．
下の表示だと差分部分とそれ以外との境目で，三角形の底辺が差分部分側に並び差分部分が見やすいのである．
上の表示の方がみやすいという人はプログラムのその部分だけ書き直せばよい．
ちょうど以下のように
# print ";▼▼▼▼▼▼\n"; # print ";▲▲▲▲▲▲\n";
コメントアウトして行があるのでそのコメントを削り，もとのをコメントアウトするとすぐに表示方法をかえることができる．
プログラム中，~usernameとしている部分があるが，そのusernameの部分はそのUNIXシステムにloginしているユーザの名前にしてほしい(例: ``~murata'')．
また，二つのプログラムの実行許可は与えておき，mdiffは環境変数PATHのとおっているところに，~username/bin/Perl/tmpdiff_patch.plは，~username/bin/Perlのディレクトリに置くこと．
また，mdiffのプログラム中の``/bin/csh''と``/usr/bin/diff''の部分と，tmpdiff_patch.plのプログラム中の``/usr/local/bin/perl''の部分は各マシンごとに，それらのコマンドがあるディレクトリに書き直すこと．
上のように二つのプログラムを記述しそれぞれのファイルを所定の場所におくとあとは以下のように打ち込んでmdiffを使うだけである．
mdiff <ファイル1> <ファイル2>
<ファイル1>, <ファイル2>は比較する二つのファイルである．
例えば，二つのファイルが
------------------------------------------------------------ <ファイル1> ------------------------------------------------------------今日学校へいく------------------------------------------------------------ <ファイル2> ------------------------------------------------------------今日大学へいく------------------------------------------------------------
であったとする．
それで，mdiffを動かすと以下の出力を得る．
今日;▲▲▲▲▲▲学校へ;●●●大学へ;▼▼▼▼▼▼いく
「学校へ」と「大学へ」の部分が差分として正しく抽出できる．
あとはうまく行単位にデータを格納したファイルを二つ作り，これらを上記のようにmdiffにかければよい．
そうすると様々な結果がmdiffにより出力される．
