#!/usr/bin/perl -w
use strict;

use utf8;
binmode(STDOUT, ":utf8");
binmode(STDERR, ":utf8");

use constant {
	INTR => "はじめに|まえがき",
	RLTDSTDY => "関連研究",
	PRPSDMTHD => "",
	EXPRMNT => "実験|評価実験|評定実験",
	CNCLSN => "結論|おわりに|終わりに|結び|むすび|まとめ",
};

$#ARGV >= 0 || die "Usage: ./section_classify [NAME OF SOURCE FILES]\n";

my $switch_log = 1;
my $switch_section_file = 1;

# Getting list of path to src from invoked vars. 
my @list_path_src = <@ARGV>;
	print "input files : @{list_path_src}\n";

for my $path_src (@list_path_src) {

# Getting name of src from path to src var.
	my ($name_src_file) = $path_src =~ /.*\/(.*)/;
		print "name of src file: $name_src_file\n";

# Making path for output.
	# make directory for this src file
	my output_path = &make_ouput_path;
	# reopen STDERR and make log directory for classify section program
	&init_log if ($switch_log);
	# Initialize section file path.
	&init_section_file if($switch_section_file);

# Reading contents from src file.
	my $whole_lines_src = &read_file($path_src);

# Seperating contents by '\section{...}' token.
	my(@heads_sec, @bodies_sec);
	&seperate_sections($whole_lines_src, \@heads_sec, \@bodies_sec);

# Classifying sections
	my(@idxs_intr, @idxs_rltdstdy, @idxs_prpsdmthd, @idxs_exprmnt, @idxs_cnclsn);
	&classify_sections(\@heads_sec, \@idxs_intr, \@idxs_rltdstdy, \@idxs_prpsdmthd, \@idxs_exprmnt, \@idxs_cnclsn);

	&make_log_file if ($switch_log);
	&make_section_file if ($switch_section_file);

}

sub read_file {
	my($path_source) = @_;

	open my $fh, '<:encoding(UTF-8)', $path_source || die "Cannot open '$path_source': $!";
	my $whole_lines_source = join '', <$fh>;
	close $fh;

	$whole_lines_source;
}

sub seperate_sections {
	my($entire_lines_src, $heads_sec_ref, $bodies_sec_ref) = @_;

	while ( $entire_lines_src =~ s/
			\\section\{([^\n]+?)\}
			(.*?)
			((?:\\section\{(?:[^\n]+?)\})|(?:\\end\{document\})|(?:\\appendix))
			/$3/sumx ) {
		push @$heads_sec_ref, $1;
		push @$bodies_sec_ref, $2;
	}
	
}

sub classify_sections {
	my($heads_ref, $intrs_ref, $rltdstdys_ref, $prpsdmthds_ref, $exprmnts_ref, $cnclsns_ref) = @_;
	my $last_idx_heads = scalar @$heads_ref - 1;

	for my $idx (0..$last_idx_heads) {
#=begin IF
		if ( @$heads_ref[$idx] =~ /^(@{[INTR]}).*?/su ) {
			push @$intrs_ref, $idx;
		} elsif ( @$heads_ref[$idx] =~ /^(@{[RLTDSTDY]}).*?/su ) {
			push @$rltdstdys_ref, $idx;
		} elsif ( @$heads_ref[$idx] =~ /^(@{[EXPRMNT]}).*?/su ) { 
			push @$exprmnts_ref, $idx;
		} elsif ( @$heads_ref[$idx] =~ /^(@{[CNCLSN]}).*?/su ) {
			push @$cnclsns_ref, $idx;
		} else {
			push @$prpsdmthds_ref, $idx;
		}
#=cut
=begin GIVEN
		{
			use 5.010001;
			given ( @$heads_ref[$idx] ) {
					when ( /^(@{[INTR]}).*?/su ) { push @$intrs_ref, $idx }
					when ( /^(@{[RLTDSTDY]}).*?/su ) { push @$rltdstdys_ref, $idx }
					when ( /^(@{[EXPRMNT]}).*?/su ) { push @$exprmnts_ref, $idx }
					when ( /^(@{[CNCLSN]}).*?/su ) { push @$cnclsns_ref, $idx }
					default { push @$prpsdmthds_ref, $idx; }
				}
		}
=cut
	}
}

sub make_ouput_path {
	
	my $ = split /\./, $name_src;
	my $path_output = "./logs/$name_src";
}
sub init_log {
	my $path_log = "./logs/$name_src/";
	open STDERR, '>:encoding(UTF-8)', $path_log || die "Cannot reopen STDERR: $!";

}

sub init_section_file {

}

sub make_log_file {

	printf STDERR "intro%10s%s\n", ' found: ', $head_sec[$_] for @idxs_intr;
	printf STDERR"relative study%1s%s\n", ' found: ', $head_sec[$_] for @idxs_rltdstdy;
	printf STDERR "proposed method%s%s\n", ' found: ', $head_sec[$_] for @idxs_prpsdmthd;
	printf STDERR "experiment%5s%s\n", ' found: ', $head_sec[$_] for @idxs_exprmnt;
	printf STDERR "conclusion%5s%s\n", ' found: ', $head_sec[$_] for @idxs_cnclsn;

	print STDERR "\nfgrep searched\n";
	system "fgrep \\\\section $path_src >> $path_log";

}

sub make_section_file {


}









